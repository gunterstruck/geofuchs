<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Multi-Landkreis KI-Assistent f√ºr Deutschland">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://unpkg.com; img-src 'self' data: https://*.basemaps.cartocdn.com https://unpkg.com; connect-src 'self' https://api.openai.com https://generativelanguage.googleapis.com https://sgx.geodatenzentrum.de;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <!-- OPTIMIERT: Zus√§tzliche Sicherheits-Meta-Tags hinzugef√ºgt -->
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <title>Multi-Landkreis KI-Assistent</title>

    <!-- Leaflet CSS-Bibliothek f√ºr interaktive Karten -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        /* Grundlegende Layout-Definitionen */
        html, body {
            margin: 0; padding: 0; height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #020617; /* Removed overflow: hidden; */ color: #e2e8f0;
            font-size: 16px;
            line-height: 1.5;
        }

        :root {
            --color-primary: #0d9488;
            --color-primary-dark: #047857;
            --color-primary-light: #14b8a6;
            --color-secondary: #f59e0b;
            --color-background: #020617;
            --color-background-light: #1e293b;
            --color-background-lighter: #2d3748;
            --color-text: #e2e8f0;
            --color-text-light: #94a3b8;
            --color-text-dark: #333;
            --color-border: #334155;
            --color-error: #ef4444;
            --color-success: #10b981;
            --color-info: #3b82f6;
            --color-warning: #f59e0b;
            --shadow-default: 0 4px 15px rgba(0,0,0,0.3);
            --radius-small: 6px;
            --radius-medium: 8px;
            --radius-large: 12px;
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
        }

        /* Hauptbereich: Karte nimmt gesamten Platz ein, abz√ºglich Sidebar-Breite */
        .main { height: 100%; margin-right: 420px; }

        /* Karten-Komponenten Styling */
        #map {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            position: relative; /* Wichtig f√ºr die Positionierung der Attribution */
        }

/* NEU: Karten-Attribution Styling */
#map-attribution {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 900; /* Unterhalb der Sidebar und anderer Controls, aber √ºber der Karte */
    background: rgba(0, 0, 0, 0.6);
    color: rgba(255, 255, 255, 0.8);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.7em;
    pointer-events: auto; /* Links sind klickbar */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

#map-attribution a {
    color: rgba(255, 255, 255, 0.9);
    text-decoration: none;
}

#map-attribution a:hover {
    text-decoration: underline;
}


        /* Ladeanzeige */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;
            background: rgba(255,255,255,0.95); padding: 30px; border-radius: var(--radius-medium);
            font-size: 1.2em; box-shadow: var(--shadow-default);
            text-align: center; color: var(--color-text-dark);
            border: 2px solid var(--color-primary);
        }

        .loader-content { display: flex; flex-direction: column; align-items: center; gap: 15px; }

        .loader-spinner {
            width: 40px; height: 40px; border: 4px solid #e5e7eb;
            border-top: 4px solid var(--color-primary); border-radius: 50%;
            animation: spin 1s linear infinite;
        }

@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Sidebar Layout */
        .sidebar {
            position: fixed; top: 0; right: 0; width: 420px; height: 100%;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            box-shadow: -4px 0 15px rgba(0, 0, 0, 0.5);
            display: flex; flex-direction: column; padding: 1.5em; box-sizing: border-box;
            z-index: 1001; border-left: 3px solid var(--color-primary);
            overflow-y: auto;
            overflow-x: hidden; /* OPTIMIERT: overflow-x bleibt, da es f√ºr die Sidebar-Breite wichtig ist */
        }

        /* API-Schl√ºssel Sektion */
        #api-key-section {
            background: var(--color-background-light);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 1.5em; margin-bottom: 1em; text-align: center;
        }

        #api-key-section h3 { color: var(--color-primary); margin-top: 0; }

        #api-key-section p { font-size: 0.9em; color: var(--color-text-light); margin: 0.5em 0; }

        #model-selector {
            display: flex; justify-content: center; gap: 15px; margin-bottom: 1em;
        }
        #model-selector label {
            cursor: pointer; padding: 8px 12px; border-radius: var(--radius-small);
            border: 2px solid var(--color-border); transition: all 0.2s;
        }
        #model-selector input[type="radio"] { display: none; }
        #model-selector input[type="radio"]:checked + label {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary-light);
        }

        #model-selector input[type="radio"]:focus-visible + label {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .api-key-input-container { margin: 1em 0; }

        .api-key-input {
            width: 100%; box-sizing: border-box; padding: 10px; border-radius: var(--radius-small);
            border: 2px solid var(--color-border); background: var(--color-background);
            color: var(--color-text); font-size: 0.95em;
        }

        .api-key-input:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        textarea::placeholder { color: #64748b; }

        #saveApiKeyButton {
            width: 100%; padding: 10px;
            background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light));
            color: white; border: none; border-radius: var(--radius-small); cursor: pointer;
            font-weight: bold; transition: all 0.3s ease;
        }

        #saveApiKeyButton:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(13, 148, 136, 0.3); }

        #saveApiKeyButton:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        /* Chat-Interface Styling */
        #chat-interface { display: flex; flex-direction: column; flex-grow: 1; min-height: 0; } /* OPTIMIERT: Initial hidden via JS */

        .success-banner {
            background: linear-gradient(135deg, var(--color-success) 0%, #059669 100%);
            color: white; padding: 0.8em; border-radius: var(--radius-medium); margin-bottom: 1em;
            text-align: center; font-weight: bold; border: 2px solid var(--color-primary-dark);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3); font-size: 0.9em;
        }

        /* ENTFERNT: multi-status-panel Styling */

        .marked-district {
            display: flex; align-items: center; margin: 3px 0; font-size: 0.8em;
            padding: 3px 6px; border-radius: 4px; background: rgba(16, 185, 129, 0.1);
        }

        .marked-district-color {
            width: 10px; height: 10px; border-radius: 50%; margin-right: 6px;
            border: 1px solid #333;
        }

        #title { color: #ffffff; margin-bottom: 0.5em; font-size: 1.2em; }

        #subtitle { color: var(--color-text-light); margin-top: -5px; font-size: 0.85em; }

        /* Prompt-Buttons */
        .prompt-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .prompt-buttons button {
            background: linear-gradient(135deg, #334155, #475569);
            color: #cbd5e1; border: 2px solid #475569; border-radius: var(--radius-small);
            padding: 6px 8px; cursor: pointer; text-align: center; font-size: 0.75em;
            transition: all 0.3s ease; font-weight: 500;
        }

        .prompt-buttons button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .prompt-buttons button:hover {
            background: linear-gradient(135deg, #475569, #64748b);
            border-color: var(--color-primary); transform: translateY(-1px);
        }

        /* Chat-Log und Messaging */
        #chatlog {
            flex: 1; background: linear-gradient(180deg, var(--color-background-light), var(--color-background-lighter));
            border: 2px solid var(--color-border); padding: 8px; overflow-y: auto;
            margin-bottom: 12px; border-radius: var(--radius-small); display: flex; flex-direction: column;
            min-height: 180px;
            scrollbar-width: thin;
            scrollbar-color: var(--color-border) transparent;
        }

        #chatlog::-webkit-scrollbar {
            width: 8px;
        }

        #chatlog::-webkit-scrollbar-track {
            background: transparent;
        }

        #chatlog::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 4px;
        }

        textarea {
            width: 100%; margin-bottom: 8px; font-size: 0.85em; border-radius: var(--radius-small);
            border: 2px solid var(--color-border); padding: 8px; box-sizing: border-box;
            font-family: inherit;
            background: linear-gradient(135deg, var(--color-background-light), var(--color-background-lighter));
            color: var(--color-text);
            height: 100px; resize: vertical; transition: all 0.3s ease;
        }

        textarea:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        textarea::placeholder { color: #64748b; }

        /* Nachrichtensprechblasen */
        .bubble {
            padding: 6px 10px; margin: 3px 0; border-radius: var(--radius-large); max-width: 94%;
            white-space: pre-wrap; line-height: 1.3; word-break: break-word;
            opacity: 0; transform: translateY(6px); animation: fadeInBubble 0.4s ease forwards;
            font-size: 0.8em;
        }

@keyframes fadeInBubble { to { opacity: 1; transform: translateY(0); } }

        .user {
            background: linear-gradient(135deg, #475569, #64748b);
            color: #ffffff; align-self: flex-end; border-bottom-right-radius: 4px;
        }

        .assistant {
            background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light));
            color: #ffffff; align-self: flex-start; border-bottom-left-radius: 4px;
        }
        /* Styling for content within assistant bubble */
        .assistant h4 {
            color: #ffffff; /* Ensure title is white */
            margin-top: 0;
            margin-bottom: 0.5em;
            font-size: 1em;
        }
        .assistant code {
            background: rgba(0,0,0,0.2); /* Darker background for code */
            border-radius: 3px;
            padding: 2px 4px;
            font-family: monospace;
            color: #ffffff; /* White text for code */
            white-space: nowrap;
        }
        .assistant ul {
            margin: 0.5em 0 0 1em;
            padding: 0;
            list-style-type: disc;
        }
        .assistant li {
            margin-bottom: 0.3em;
        }


        /* Aktions-Buttons */
        .action-buttons-container { display: flex; gap: 6px; margin-bottom: 8px; }

        .action-buttons-container button {
            color: white; border: none; padding: 8px; border-radius: var(--radius-small);
            cursor: pointer; transition: all 0.3s ease; font-weight: bold; font-size: 0.85em;
        }

        .action-buttons-container button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .action-buttons-container button:hover { transform: translateY(-1px); }

        .action-buttons-container button#sendButton {
            flex-grow: 1; background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light));
        }

        .action-buttons-container button#clearButton {
            flex-basis: 70px; background: linear-gradient(135deg, var(--color-error), #dc2626);
        }

        /* Storage-Buttons Container - NEUE POSITION UNTEN RECHTS */
        .storage-buttons-container {
            position: fixed;
            bottom: 40px;
            right: 430px;
            z-index: 1002;
            display: flex;
            gap: 6px;
            width: 280px; /* Added fixed width to ensure enough space */
        }

        .storage-buttons-container button {
            flex: 1;
            color: white;
            border: none;
            padding: 8px;
            border-radius: var(--radius-small);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.85em;
            white-space: nowrap; /* Ensure text stays on one line */
        }

        .storage-buttons-container button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .storage-buttons-container button:hover {
            transform: translateY(-1px);
        }

        .storage-buttons-container button#saveDataButton {
            background: linear-gradient(135deg, var(--color-info), #2563eb);
        }

        .storage-buttons-container button#loadDataButton {
            background: linear-gradient(135deg, var(--color-warning), #d97706);
        }

        /* Footer und Disclaimer */
        #disclaimer {
            color: var(--color-text-light); font-size: 0.65em; text-align: center;
            margin-top: auto; padding-top: 0.8em; line-height: 1.2;
        }

        /* Tipp-Indikator Animation */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding-left: 10px;
        }

        .typing-dot {
            height: 5px; width: 5px; background-color: #ffffff; border-radius: 50%;
            display: inline-block; margin: 0 1px;
            animation: typing-bounce 1.4s infinite ease-in-out both;
        }

        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing-bounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1.2); opacity: 1; }
        }

        /* Assistent Aktions-Buttons */
        .assistant-action-buttons { margin-top: 8px; }

        .assistant-action-buttons button {
            background: rgba(255,255,255,0.2); color: #ffffff; border: 1px solid rgba(255,255,255,0.3);
            padding: 4px 12px; margin-right: 6px; border-radius: 15px; cursor: pointer;
            font-size: 0.75em; transition: all 0.2s ease;
        }

        .assistant-action-buttons button:hover { background: rgba(255,255,255,0.3); }

        .assistant-action-buttons button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border-left: 4px solid var(--color-error);
            color: white;
            padding: 8px 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .info-message {
            background: rgba(59, 130, 246, 0.2);
            border-left: 4px solid var(--color-info);
            color: white;
            padding: 8px 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Responsive Design f√ºr kleinere Bildschirme */
        @media screen and (max-width: 1024px) {
            .main {
                margin-right: 0; /* Karte nimmt volle Breite ein */
            }
            .sidebar {
                width: 100%; /* Sidebar nimmt volle Breite ein */
                transform: translateX(100%); /* Standardm√§√üig ausgeblendet */
                transition: transform 0.3s ease;
            }
            .sidebar.active {
                transform: translateX(0); /* Eingeblendet */
            }

            /* Mobile toggle button for all screens up to 1024px */
            .mobile-toggle {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 1002;
                background: var(--color-primary);
                color: white;
                border: none;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex; /* OPTIMIERT: Removed !important */
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

            .storage-buttons-container {
                right: 10px;
                width: calc(100% - 20px); /* Adjust width for mobile */
            }
        }

        /* OPTIMIERT: Styling f√ºr die Vertriebsdaten-Anzeige */
        .sales-data {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px dotted rgba(255, 255, 255, 0.2);
            font-size: 0.85em;
        }

        .sales-data-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .sales-data-label {
            color: var(--color-text-light);
        }

        .sales-data-value {
            font-weight: bold;
        }

        /* Dialog zum Bearbeiten der Vertriebsdaten - ERWEITERT F√úR MEHRERE EINTR√ÑGE */
        .edit-sales-dialog {
            position: fixed;
            top: 5%;
            left: 3%;
            transform: translate(0%, 0%);
            background: var(--color-background-light);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 16px;
            box-shadow: var(--shadow-default);
            z-index: 2000;
            width: 350px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .edit-sales-dialog h3 {
            color: var(--color-primary);
            margin-top: 0;
            margin-bottom: 12px;
            text-align: center;
        }

        .edit-sales-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 0.85em;
            color: var(--color-text-light);
        }

        .form-group input {
            padding: 8px;
            border-radius: var(--radius-small);
            border: 1px solid var(--color-border);
            background: var(--color-background);
            color: var(--color-text);
        }

        .dialog-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
        }

        .dialog-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .btn-save {
            background: var(--color-primary);
            color: white;
        }

        .btn-cancel {
            background: var(--color-background-lighter);
            color: var(--color-text-light);
            border: 1px solid var(--color-border) !important;
        }

        .btn-save:hover, .btn-cancel:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .edit-button {
            background: rgba(59, 130, 246, 0.2);
            color: white;
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 4px;
            padding: 2px 6px;
            margin-left: 6px;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-button:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
        }

        /* NEU: Hover-Info-Popup Styling */
        .hover-info-popup {
            position: absolute;
            background: white;
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 10px;
            box-shadow: var(--shadow-default);
            z-index: 1500;
            max-width: 300px; /* GE√ÑNDERT: Breiter f√ºr mehr Inhalt */
            pointer-events: none;
            color: var(--color-text-dark);
            font-size: 11px;
            opacity: 0;
            transform: translateY(-5px);
            transition: opacity 0.2s, transform 0.2s;
        }

        .hover-info-popup.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .hover-info-title {
            font-weight: bold;
            color: var(--color-primary);
            margin-bottom: 5px;
            border-bottom: 1px solid var(--color-primary);
            padding-bottom: 3px;
        }

        .hover-info-content {
            margin-top: 5px;
            max-height: 200px; /* HINZUGEF√úGT: Maximale H√∂he mit Scrollbar */
            overflow-y: auto;
        }

        .hover-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }

        .hover-info-label {
            color: var(--color-text-dark); /* GE√ÑNDERT: Opacity entfernt */
            /* opacity: 0.7; */ /* ENTFERNT */
            font-size: 10px;
        }

        .hover-info-value {
            font-weight: bold;
            font-size: 10px;
        }

        /* HINZUGEF√úGT: Styling f√ºr die Liste der Vertriebsbezirke */
        .sales-districts-list {
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px dotted #ccc;
            font-size: 10px;
        }

        .sales-district-item {
            padding: 3px 5px;
            margin-bottom: 2px;
            border-radius: 3px;
            background-color: rgba(13, 148, 136, 0.1);
        }

        .hover-info-footer {
            font-size: 9px;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px dotted #ccc;
            color: var(--color-info);
            text-align: center;
        }

        /* OPTIMIERT: Farb-Auswahl f√ºr den Bearbeitungsdialog */
        .color-picker-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 5px;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 0 2px var(--color-primary);
        }

        /* GE√ÑNDERT: Styling f√ºr Vertriebsbezirk Infoboxen (Kompakte Ansicht) */
        .sales-district-infobox {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 2px 4px; /* GE√ÑNDERT: Padding noch weiter reduziert */
            box-shadow: var(--shadow-default);
            width: fit-content;
            white-space: nowrap;
            color: var(--color-text-dark);
            font-size: 11px;
            z-index: 999;
            text-align: center;
            pointer-events: auto;
            cursor: pointer; /* HINZUGEF√úGT: Zeigt an, dass die Box klickbar ist */
            opacity: 0; /* Initial hidden for fade-in */
            transition: all 0.3s ease; /* Fade-in transition */
        }

        /* GE√ÑNDERT: Keine Hover-Expansion mehr f√ºr die kompakte Box */
        .sales-district-infobox:hover {
            transform: scale(1.05); /* Leichter Skalierungseffekt beim Hover */
            border-color: var(--color-primary-light);
        }

        .sales-district-infobox-title {
            font-weight: bold;
            color: var(--color-primary);
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        /* ENTFERNT: Details-Box ist jetzt ein separates Popup, nicht mehr Teil der kompakten Infobox */
        .sales-district-infobox-details {
            display: none; /* WIRD NICHT MEHR VERWENDET, ABER ZUR SICHERHEIT AUSGEBLENDET */
        }

        /* NEU: Styling f√ºr das Detail-Popup der Vertriebsbezirke */
        #salesDistrictDetailPopup {
            position: fixed;
            top: 5%;
            left:3%;
            transform: translate(0%, 0%);
            background: var(--color-background-light); /* Dunkler Hintergrund f√ºr besseren Kontrast */
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 16px;
            box-shadow: var(--shadow-default);
            z-index: 2000; /* H√∂her als andere Elemente */
            width: 300px;
            max-width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            color: var(--color-text); /* Heller Text auf dunklem Hintergrund */
            /* display: none; */ /* OPTIMIERT: Initial hidden via JS */
        }

        #salesDistrictDetailPopup h3 {
            color: var(--color-primary);
            margin-top: 0;
            margin-bottom: 12px;
            text-align: center;
        }

        #salesDistrictDetailPopup .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        #salesDistrictDetailPopup .detail-label {
            color: var(--color-text-light); /* Helleres Grau f√ºr Labels */
        }

        #salesDistrictDetailPopup .detail-value {
            font-weight: bold;
        }

        #salesDistrictDetailPopup .detail-list {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dotted var(--color-border);
            max-height: 150px;
            overflow-y: auto;
        }

        #salesDistrictDetailPopup .detail-list-item {
            padding: 3px 0;
            font-size: 0.85em;
        }

        #salesDistrictDetailPopup .close-button {
            background: var(--color-error);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            padding: 8px 12px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 15px;
            width: 100%;
            transition: background-color 0.2s;
        }

        #salesDistrictDetailPopup .close-button:hover {
            background: #dc2626;
        }


        /* MODIFIZIERT: Buttons untereinander anordnen */
        .control-buttons-container {
            position: fixed;
            top: 10px; /* Oben Links */
            left: 10px; /* Oben Links */
            right: unset;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: var(--radius-medium);
            justify-content: flex-start;
            /* flex-wrap: Removed as it's a column layout */
        }

        /* Adjust for mobile to prevent overlap with mobile-toggle */
        @media screen and (max-width: 1024px) { /* Angepasst f√ºr Tablet-Querformat */
            .control-buttons-container {
                left: 10px;
                top: 10px; /* Unterhalb des mobile-toggle Buttons */
            }
        }

        /* NEU: Leaflet Zoom Control Position (Mitte Links) */
        .leaflet-control-zoom {
            position: fixed !important; /* √úberschreibt Leaflet's Standardpositionierung */
            left: 10px !important; /* Abstand vom linken Rand */
            top: 50% !important; /* Vertikal zentriert */
            transform: translateY(-50%) !important; /* Korrektur f√ºr exakte Zentrierung */
            z-index: 1000;
        }

        /* NEU: Farbl√∂schung Option f√ºr den Bearbeitungsdialog */
        .color-remove-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent; /* Changed from var(--color-border) */
            transition: transform 0.2s, border-color 0.2s;
            background: white;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-remove-option::before,
        .color-remove-option::after {
            content: "";
            position: absolute;
            width: 16px;
            height: 2px;
            background-color: var(--color-error);
        }

        .color-remove-option::before {
            transform: rotate(45deg);
        }

        .color-remove-option::after {
            transform: rotate(-45deg);
        }

        .color-remove-option:hover {
            transform: scale(1.1);
            border-color: var(--color-error);
        }

        .color-remove-option.selected {
            border-color: var(--color-error);
            box-shadow: 0 0 0 2px var(--color-error);
        }

        /* NEU: Styling f√ºr die Liste der Vertriebseintr√§ge */
        .sales-entries-list {
            margin-bottom: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .sales-entry-item {
            background: var(--color-background-lighter);
            border-radius: var(--radius-small);
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--color-primary);
        }

        .sales-entry-header {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

.entry-color-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .entry-title {
            flex-grow: 1;
            font-weight: bold;
        }

        .entry-actions {
            display: flex;
            gap: 5px;
        }

        .btn-edit-entry, .btn-delete-entry {
            background: none;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: var(--radius-small);
            padding: 2px 6px;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-edit-entry {
            color: var(--color-info);
        }

        .btn-delete-entry {
            color: var(--color-error);
        }

        .btn-edit-entry:hover, .btn-delete-entry:hover {
            background: rgba(255,255,255,0.1);
        }

        .sales-entry-details {
            font-size: 0.85em;
            color: var(--color-text-light);
            padding-left: 22px;
        }

        .no-entries-message {
            color: var(--color-text-light);
            font-style: italic;
            padding: 10px;
            text-align: center;
        }

        .btn-add-entry {
            background: var(--color-info);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .btn-add-entry:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        /* NEU: Hinzugef√ºgt f√ºr Basic Modus */
        .basic-mode-info {
            margin-top: 10px;
            font-size: 0.8em;
            color: var(--color-text-light);
            text-align: center;
            padding: 5px;
        }

        /* NEU: Styling f√ºr das Dropdown-Men√º */
        .sales-group-filter-container {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--color-background-light);
            padding: 5px 10px;
            border-radius: var(--radius-small);
            border: 1px solid var(--color-border);
        }

        .sales-group-filter-container label {
            color: var(--color-text);
            font-size: 0.85em;
            white-space: nowrap;
        }

        .sales-group-filter-container select {
            background: var(--color-background);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-small);
            padding: 5px 8px;
            font-size: 0.85em;
            cursor: pointer;
            flex-grow: 1;
            min-width: 120px;
        }

        .sales-group-filter-container select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        /* NEU: Styling f√ºr Vertriebsbezirksauswahl-Container */
        .sales-district-selection-container {
            background: var(--color-background-light);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-medium);
            padding: 10px;
            margin-top: 10px;
            /* display: none; */ /* OPTIMIERT: Initial hidden via JS */
            flex-direction: column;
            gap: 8px;
        }

        .sales-district-selection-container label {
            color: var(--color-text);
            font-size: 0.9em;
            font-weight: bold;
        }

        .sales-district-selection-container input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            padding: 8px;
            border-radius: var(--radius-small);
            border: 1px solid var(--color-border);
            background: var(--color-background);
            color: var(--color-text);
            font-size: 0.85em;
        }

        .sales-district-selection-container input[type="text"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        .sales-district-checkboxes {
            max-height: 75px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-small);
            padding: 5px;
            background: var(--color-background);
        }

        .sales-district-checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .sales-district-checkbox-item:last-child {
            margin-bottom: 0;
        }

        .sales-district-checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .sales-district-checkbox-item label {
            font-size: 0.85em;
            color: var(--color-text);
            flex-grow: 1;
            cursor: pointer;
        }

        .sales-district-buttons {
            display: flex;
            gap: 8px;
        }

        .sales-district-buttons button {
            flex-grow: 1;
            padding: 8px;
            border: none;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.2s;
            background: var(--color-primary);
            color: white;
        }

        .sales-district-buttons button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .sales-district-buttons button#deselectAllDistricts {
            background: var(--color-background-lighter);
            color: var(--color-text-light);
            border: 1px solid var(--color-border);
        }
        .sales-district-buttons button#deselectAllDistricts:hover {
            background: #334155;
        }

        /* Custom Toggle Switch Styling */
        .sales-district-toggle {
            position: relative;
            display: inline-block;
            width: 40px; /* Width of the toggle */
            height: 24px; /* Height of the toggle */
            vertical-align: middle; /* Align with text */
            /* margin-left: 10px; Removed, handled by flex container */
        }

        .sales-district-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .sales-district-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--color-border); /* Off state background */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 24px; /* Rounded corners for slider track */
        }

        .sales-district-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px; /* Height of the knob */
            width: 16px; /* Width of the knob */
            left: 4px;
            bottom: 4px;
            background-color: white; /* Knob color */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%; /* Make knob round */
        }

        .sales-district-toggle input:checked + .sales-district-toggle-slider {
            background-color: var(--color-primary); /* On state background */
        }

        .sales-district-toggle input:focus + .sales-district-toggle-slider {
            box-shadow: 0 0 1px var(--color-primary);
        }

        .sales-district-toggle input:checked + .sales-district-toggle-slider:before {
            -webkit-transform: translateX(16px); /* Move knob to the right */
            -ms-transform: translateX(16px);
            transform: translateX(16px);
        }

        /* Adjust the container for the toggles */
        .sales-district-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between; /* To push the toggle to the right */
            width: 100%; /* Ensure it takes full width of its parent */
        }

        /* Custom styles for welcome message truncation */
        .truncated-welcome-message {
            max-height: 4.5em; /* Approximately 3 lines for 1.5em line-height */
            overflow: hidden;
            position: relative;
            transition: max-height 0.5s ease-out;
            margin-bottom: 0.5em; /* Adjust spacing */
            text-align: center; /* Ensure text aligns center */
        }
        .truncated-welcome-message.expanded {
            max-height: 500px; /* Sufficiently large to show full content */
            overflow: visible;
        }
        .read-more-button {
            background: none;
            border: none;
            color: var(--color-primary-light);
            cursor: pointer;
            font-size: 0.9em;
            padding: 5px 0;
            text-align: center;
            width: 100%;
            display: block;
            margin-top: 5px;
            transition: color 0.2s ease;
        }
        .read-more-button:hover {
            color: var(--color-primary);
        }
        .read-more-button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        /* Custom styles for contact button */
        .toggle-contact-button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, var(--color-info), #2563eb);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin-top: 1em; /* Space above button */
        }
        .toggle-contact-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        .toggle-contact-button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        /* NEW: Custom styles for DSGVO truncation */
        .truncated-dsgvo-message {
            max-height: 20em; /* ADJUSTED: Increased to fit more content initially */
            overflow: hidden;
            position: relative;
            transition: max-height 0.5s ease-out;
            margin-top: 1em; /* Space from contact info */
            font-size: 0.8em;
            color: var(--color-text-light);
            text-align: left;
            margin-bottom: 0; /* HINZUGEF√úGT: Entfernt zus√§tzlichen Abstand nach unten */
        }
        .truncated-dsgvo-message.expanded {
            max-height: none; /* Sufficiently large to show full content */
            overflow: visible;
        }
        /* ... andere Stile ... */
        #readMoreDsgvoBtn {
            margin-top: 10px; /* ADJUSTED: Changed from negative to positive margin */
        }

        /* OPTIMIERT: Hidden utility class */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- HTML-Struktur: Hauptcontainer -->
    <main class="main" id="mainContent">
        <button class="mobile-toggle" id="mobileSidebarToggle" aria-label="√ñffne Steuerung" style="display: none;">
            <span aria-hidden="true">‚â°</span>
        </button>

        <div id="map" aria-label="Interaktive Deutschlandkarte" role="application">
            <!-- Ladeanzeige w√§hrend Karteninitialisierung -->
            <div id="loader" role="status" aria-live="polite">
                <div class="loader-content">
                    <div class="loader-spinner" aria-label="Lade Daten"></div>
                    <div>Multi-Landkreis KI-System wird geladen...</div>
                    <div style="font-size: 0.8em; color: #666;">Intelligente Mehrfachmarkierung von Regionen</div>
                </div>
            </div>
<!-- NEU: Karten-Attribution -->
<div id="map-attribution">
  Daten ¬© <a href="https://www.openstreetmap.org/copyright"
             target="_blank" rel="noopener">OpenStreetMap-Mitwirkende</a> ‚Ä¢
  Tiles ¬© <a href="https://carto.com/attribution"
             target="_blank" rel="noopener">CARTO</a>
</div>
        </div>

        <!-- OPTIMIERT: Verbesserte Strukturierung mit zus√§tzlichen ARIA-Attributen -->
        <div class="control-buttons-container" role="region" aria-label="Kartensteuerung">
            <div class="sales-district-toggle-container">
                <span id="vertriebsinfo-label" style="color: white;">Vertriebsbezirke</span>
                <!-- OPTIMIERT: Explicit label mit aria-labelledby f√ºr bessere Zug√§nglichkeit -->
                <label class="sales-district-toggle" title="Schaltet die Anzeige von Vertriebsbezirks-Infoboxen auf der Karte ein/aus. (Sichtbar ab Zoom-Stufe 8)">
                    <input type="checkbox" id="salesDistrictToggle" aria-labelledby="vertriebsinfo-label">
                    <span class="sales-district-toggle-slider"></span>
                </label>
            </div>
            <!-- NEUER TOGGLE HIER EINGEF√úGT -->
            <div class="sales-district-toggle-container">
                <span id="revenue-coloring-label" style="color: white;">F√§rbung: H√∂chster Umsatz</span>
                <label class="sales-district-toggle" title="Zeigt die Farbe des umsatzst√§rksten Vertriebsbezirkes in dieser Region an.">
                    <input type="checkbox" id="revenueColoringToggle" aria-labelledby="revenue-coloring-label">
                    <span class="sales-district-toggle-slider"></span>
                </label>
            </div>
            <!-- NEU: Dropdown f√ºr Vertriebsgruppen-Filter -->
            <div class="sales-group-filter-container">
                <label for="salesGroupFilter">Gruppe:</label>
                <select id="salesGroupFilter" aria-label="Filter nach Vertriebsgruppe">
                    <option value="">Alle Gruppen</option>
                    <!-- Optionen werden dynamisch hinzugef√ºgt -->
                </select>
            </div>
        </div>

        <!-- OPTIMIERT: Verbesserte Beschreibungen und ARIA-Attributen -->
        <div class="storage-buttons-container" role="region" aria-label="Datenverwaltung">
            <button id="saveDataButton" aria-label="Aktuelle Markierungen und Daten speichern">
                üíæ Daten speichern
            </button>
            <button id="loadDataButton" aria-label="Gespeicherte Markierungen und Daten laden">
                üìÇ Daten laden
            </button>
        </div>

        <!-- OPTIMIERT: Hover-Info-Popup mit besserer Semantik -->
        <div id="hoverInfoPopup" class="hover-info-popup" role="tooltip">
            <div class="hover-info-title">Regionsinformation</div>
            <div class="hover-info-content" id="hoverInfoContent"></div>
            <div class="hover-info-footer">Klick zum Bearbeiten</div>
        </div>

        <!-- NEU: Detail-Popup f√ºr Vertriebsbezirke -->
        <div id="salesDistrictDetailPopup" class="hidden" role="dialog" aria-modal="true" aria-labelledby="sales-detail-title">
            <h3 id="sales-detail-title">Vertriebsbezirk Details</h3>
            <div class="detail-row">
                <span class="detail-label">Vertriebsbezirk:</span>
                <span class="detail-value" id="detailDistrict"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Vertriebsgruppe:</span>
                <span class="detail-value" id="detailGroup"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Gesamtumsatz:</span>
                <span class="detail-value" id="detailRevenue"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Anzahl Regionen:</span>
                <span class="detail-value" id="detailRegionCount"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Anzahl Eintr√§ge:</span>
                <span class="detail-value" id="detailEntryCount"></span>
            </div>
            <div class="detail-list">
                <h4>zugeordnete Regionen:</h4>
                <ul id="detailRegionList">
                    <!-- Regionen werden hier dynamisch eingef√ºgt -->
                </ul>
            </div>
            <button class="close-button" id="closeSalesDistrictDetailPopupButton">Schlie√üen</button>
        </div>
    </main>

    <!-- OPTIMIERT: Sidebar mit verbesserter Semantik und Accessibility -->
    <aside class="sidebar" id="sidebar" role="complementary" aria-label="KI-Assistent Steuerung">
        <!-- API-Schl√ºssel und Modellauswahl Sektion -->
        <section id="api-key-section" aria-labelledby="api-key-title">
            <h2 id="app-title" style="color: var(--color-primary); margin-top: 0; margin-bottom: 0.2em; font-size: 1.5em;">
                üåç GeoFuchs ü¶ä
            </h2>
            <p style="font-size: 0.7em; color: var(--color-text-light); margin-top: 0; margin-bottom: 1em;">V1.5 2025</p>
            <h3 id="api-key-title" style="font-size: 1.2em;">üîê KI-Modell & API-Schl√ºssel</h3>

            <!-- Truncated welcome message -->
            <p id="welcomeMessageContainer" class="truncated-welcome-message">
                Willkommen bei **GeoFuchs**, Ihrem intelligenten Multi-Landkreis KI-Assistenten f√ºr interaktive Karten.
                Diese Anwendung erm√∂glicht es Ihnen, Regionen in Deutschland basierend auf Ihren Anfragen zu markieren,
                zu analysieren und mit Vertriebsdaten zu verwalten. Nutzen Sie die KI-Funktionen, um komplexe
                geografische Analysen durchzuf√ºhren oder verwalten Sie Ihre Daten im Basic-Modus.
                Bitte geben Sie Ihren API-Schl√ºssel ein, um die volle Funktionalit√§t der KI-Modelle zu nutzen.
            </p>
            <button id="readMoreBtn" class="read-more-button">Weiter lesen</button>
            <!-- End truncated welcome message -->

            <!-- OPTIMIERT: Radio-Button Auswahl mit verbesserten ARIA-Attributen -->
            <div id="model-selector" role="radiogroup" aria-label="KI-Modell Auswahl">
                <input type="radio" id="model-openai" name="model" value="openai" checked>
                <label for="model-openai">OpenAI GPT-4.1</label>

                <input type="radio" id="model-gemini" name="model" value="gemini">
                <label for="model-gemini">Google Gemini 2.5 Pro</label>
            </div>

            <!-- OPTIMIERT: API-Schl√ºssel Eingabefelder mit verbesserten Validierungsattributen -->
            <div id="openai-key-container" class="api-key-input-container">
                 <!-- OPTIMIERT: Hinzugef√ºgtes pattern f√ºr HTML5-Formvalidierung -->
                 <input type="password" id="openaiApiKeyInput" class="api-key-input"
                        placeholder="OpenAI Key (sk-...)"
                        aria-label="OpenAI API Schl√ºssel"
                        autocomplete="off"
                        pattern="sk-[a-zA-Z0-9]{32,}"
                        title="Der OpenAI Schl√ºssel muss mit 'sk-' beginnen, gefolgt von mindestens 32 Zeichen">
                 <!-- Validierungsnachricht -->
                 <p class="input-validation-message" id="openai-validation-message" aria-live="polite"></p>
            </div>
            <div id="gemini-key-container" class="api-key-input-container hidden">
                 <!-- OPTIMIERT: Hinzugef√ºgtes minlength f√ºr HTML5-Formvalidierung -->
                 <input type="password" id="geminiApiKeyInput" class="api-key-input"
                        placeholder="Google AI Studio Key..."
                        aria-label="Google Gemini API Schl√ºssel"
                        autocomplete="off"
                        minlength="20"
                        title="Der Google Gemini Schl√ºssel sollte mindestens 20 Zeichen lang sein">
                 <!-- Validierungsnachricht -->
                 <p class="input-validation-message" id="gemini-validation-message" aria-live="polite"></p>
            </div>

            <!-- OPTIMIERT: Button mit erg√§nzter ARIA-Beschreibung -->
            <button id="saveApiKeyButton" aria-description="Speichert den eingegebenen API-Schl√ºssel und aktiviert den KI-Assistenten">
                Schl√ºssel speichern & starten
            </button>
            <p style="font-size: 0.75em; margin-top: 1em;">Der Schl√ºssel wird nur in dieser Sitzung gespeichert.</p>
            <!-- Hinzugef√ºgte Zeile -->
            <p style="font-size: 0.75em; color: var(--color-warning); margin-top: 0.5em; font-weight: bold;">
                Achtung: Nur Daten die den Status "CO - Frei verwendbar" haben sind erlaubt.
            </p>

            <!-- NEU: Hinweis f√ºr Basic-Modus -->
            <div class="basic-mode-info">
               ‚ÑπÔ∏è Sie k√∂nnen auch ohne API-Schl√ºssel Regionen bearbeiten und Daten speichern/laden.
            </div>

            <!-- Optimaler Eingabehinweis wurde hier entfernt und wird nun dynamisch im Chatlog angezeigt -->

            <!-- Contact info -->
            <button id="toggleContactBtn" class="toggle-contact-button">DSGVO</button>
            <div id="contactInfoContainer" class="hidden" style="margin-top: 1.5em;">
<p style="font-size: 0.8em; color: var(--color-text-light); text-align: left; margin-top: 0;">
  G√ºnter Struck<br>
 L√∂nsberg 8<br>
  45136 Essen, Deutschland<br>
  E-Mail: <a href="mailto:geofuchs@online.de" style="color: var(--color-primary); text-decoration: none;">geofuchs@online.de</a>
</p>

<p style="font-size: 0.8em; color: var(--color-text-light); text-align: left;">
üîó Website:¬†
¬† <a href="https://gunterstruck.github.io/geofuchs/" target="_blank" rel="noopener" style="color: var(--color-primary);">gunterstruck.github.io/geofuchs</a><br>
üíª Code & Issues:¬†
¬† <a href="https://github.com/gunterstruck/geofuchs" target="_blank" rel="noopener" style="color: var(--color-primary);">GitHub-Repository</a><br>
üìú Datenschutzerkl√§rung:
<a href="https://gunterstruck.github.io/geofuchs/datenschutz.html" target="_blank" rel="noopener" style="color: var(--color-primary);">ansehen</a><br>
ü™™ Lizenz:
<a href="https://gunterstruck.github.io/geofuchs/license.html" target="_blank" rel="noopener" style="color: var(--color-primary);">MIT-Lizenz</a>
</p>



<p style="font-size: 0.75em; color:#94a3b8; text-align:left;">
  <em>Projektstatus:</em> privates, nicht-kommerzielles MVP. Keine Gew√§hr; Nutzung auf eigene Verantwortung.
</p>


                </p>
                <!-- NEW DSGVO Content below -->
                <div id="dsgvoContentContainer" class="truncated-dsgvo-message">
                    <!-- DSGVO content will be injected here by JS -->
                </div>
                <button id="readMoreDsgvoBtn" class="read-more-button hidden">Weiter lesen</button>
            </div>
            <!-- End contact info -->
        </section>

        <!-- NEU: Vertriebsbezirksauswahl-Container -->
        <div class="sales-district-selection-container hidden" id="salesDistrictSelectionContainer">
            <label for="salesDistrictFilterSearch">Vertriebsbezirke filtern:</label>
            <input type="text" id="salesDistrictFilterSearch" placeholder="Bezirk suchen..." aria-label="Vertriebsbezirk suchen">
            <div id="salesDistrictCheckboxes" class="sales-district-checkboxes" role="group" aria-label="Vertriebsbezirke ausw√§hlen">
                <!-- Checkboxen werden hier dynamisch hinzugef√ºgt -->
            </div>
            <div class="sales-district-buttons">
                <button id="selectAllDistricts" aria-label="Alle Vertriebsbezirke ausw√§hlen">Alle ausw√§hlen</button>
                <button id="deselectAllDistricts" aria-label="Alle Vertriebsbezirke abw√§hlen">Alle abw√§hlen</button>
            </div>
        </div>

        <!-- OPTIMIERT: Chat-interface mit verbesserten ARIA-Attributen -->
        <div id="chat-interface" class="hidden" role="region" aria-labelledby="title">
            <!-- Erfolgsbanner -->
            <div class="success-banner" id="successBanner" role="status" aria-live="polite"></div>

            <!-- Titel und Beschreibung -->
            <header>
                <h2 id="title">üó∫Ô∏è Multi-Landkreis KI-Assistent</h2>
                <p id="subtitle">Intelligente Mehrfachmarkierung von Regionen</p>
            </header>

            <!-- OPTIMIERT: Vordefinierte Prompt-Buttons mit verbesserten ARIA-Attributen -->
            <div class="prompt-buttons" id="promptButtons" aria-label="Vordefinierte Anfragen">
                <button data-prompt="Markiere Berlin rot" aria-label="Berlin in rot markieren">
                    üéØ Berlin mit Rot markieren
                </button>
                <!-- NEUE PROMPT BUTTONS -->
                <button data-prompt="Analysiere H30L" aria-label="H30L analysieren">
                    üí∞ Vertriebsbezirk (Beispiel:) H30L analysieren
                </button>
                <button data-prompt="Top 5 Regionen nach Umsatz" aria-label="Top Regionen anzeigen">
                    üèÜ Top Regionen zeigen
                </button>
                <button data-prompt="Analyse Vertriebsgruppe [Vertriebsgruppe: z.B. ISL3]" aria-label="Vertriebsgruppe ISL3 analysieren">
                    üìä Infos Vertriebsgruppe ISL3
                <!-- HIER IST DER NEUE BUTTON, DER DIE KI ANWEIST, DAS BENUTZERFREUNDLICHE FORMAT ZU ERKL√ÑREN -->
                <button data-prompt="Erkl√§re dem Nutzer, wie er Daten direkt im KI-Chatfenster eingeben kann, um Markierungen vorzunehmen. Zeige ein Beispiel in Tabellenform mit den Spalten 'action', 'region', 'regionType', 'color', 'salesGroup', 'salesDistrict', und 'revenue'. Beschreibe die Bedeutung jedes Feldes. Betone, dass die KI diese strukturierten Eingaben direkt verarbeiten und die entsprechenden Aktionen ausf√ºhren wird. Vermeide jegliche Erw√§hnung von JSON, Skripten, Importprozessen oder anderen technischen Backend-Details." aria-label="Optimales Format f√ºr Info-Eingabe im Chat erkl√§ren">
                    üìù Zeige mir das optimale Format um Daten einzuf√ºgen
                </button>
                <button data-prompt="L√∂sche alle Markierungen" aria-label="Alle Markierungen l√∂schen">
                    üóëÔ∏è Alles l√∂schen
                </button>
            </div>

            <!-- OPTIMIERT: Chat-Verlauf Container mit verbesserten ARIA-Attributen -->
            <div id="chatlog" role="log" aria-live="polite" aria-label="Chat-Verlauf"></div>

            <!-- OPTIMIERT: Texteingabefeld mit explizitem Label -->
            <label for="question" class="sr-only">Ihre Anfrage an den KI-Assistenten</label>
            <textarea id="question"
                      placeholder="Fragen Sie mich: 'Markiere Baden-W√ºrttemberg rot', 'Markiere Frankfurt am Main blau'..."
                      aria-label="Ihre Anfrage an den KI-Assistenten"></textarea>

            <!-- OPTIMIERT: Haupt-Aktionsbuttons mit verbesserten ARIA-Attributen -->
            <div class="action-buttons-container">
                <button id="sendButton" aria-label="Nachricht senden">Senden</button>
                <button id="clearButton" aria-label="Alle Markierungen l√∂schen">üîÑ L√∂schen</button>
            </div>

            <!-- Disclaimer-Text -->
<footer id="disclaimer">
  ü§ñ KI-gesteuerte Mehrfachmarkierung ‚Ä¢ Der Assistent kann Fehler machen<br>
  <a href="https://gunterstruck.github.io/geofuchs/" target="_blank" style="color: var(--color-text-light); text-decoration: underline;">Homepage</a>
  &nbsp;‚Ä¢&nbsp;
  <a href="https://gunterstruck.github.io/geofuchs/datenschutz" target="_blank" style="color: var(--color-text-light); text-decoration: underline;">Datenschutzerkl√§rung</a>
  &nbsp;‚Ä¢&nbsp;
  <a href="https://gunterstruck.github.io/geofuchs/LICENSE" target="_blank" style="color: var(--color-text-light); text-decoration: underline;">MIT-Lizenz</a>
  &nbsp;‚Ä¢&nbsp;
  <a href="https://github.com/gunterstruck/geofuchs.github.io" target="_blank" rel="noopener" style="color: var(--color-text-light); text-decoration: underline;">GitHub</a>
</footer>
        </div>
    </aside>

    <!-- OPTIMIERT: Dialog zum Bearbeiten mit verbesserten ARIA-Attributen -->
    <div id="editSalesDialog" class="edit-sales-dialog hidden" role="dialog" aria-labelledby="edit-dialog-title" aria-modal="true">
        <h3 id="edit-dialog-title">Region bearbeiten</h3>

        <!-- OPTIMIERT: Liste mit besserer Semantik -->
        <div id="salesEntriesList" class="sales-entries-list" role="list" aria-label="Vorhandene Vertriebsbezirke">
            <!-- Hier werden die vorhandenen Eintr√§ge dynamisch eingef√ºgt -->
        </div>

        <div class="dialog-buttons">
            <button type="button" class="btn-add-entry" id="addEntryButton" aria-label="Neuen Vertriebsbezirk hinzuf√ºgen">
                Vertriebsbezirk hinzuf√ºgen
            </button>
            <button type="button" class="btn-cancel" id="closeEditDialogButton" aria-label="Dialog schlie√üen">
                Schlie√üen
            </button>
        </div>

        <!-- OPTIMIERT: Formular mit verbesserten Labels und Validierungsattributen -->
        <form id="addEntryForm" class="edit-sales-form hidden">
            <div class="form-group">
                <label for="colorPicker">Farbe:</label>
                <div class="color-picker-container" id="colorPicker" role="radiogroup" aria-labelledby="color-picker-label">
                    <span id="color-picker-label" class="sr-only">Farbauswahl</span>
                    <div class="color-remove-option" id="removeColorOption" title="Farbe l√∂schen" role="radio" aria-label="Farbe l√∂schen"></div>
                    <!-- Farben werden hier dynamisch eingef√ºgt -->
                </div>
            </div>
            <div class="form-group">
                <label for="salesGroupInput">Vertriebsgruppe:</label>
                <input type="text" id="salesGroupInput" placeholder="z.B. Nord oder ISL1"
                       title="Beliebiger Text f√ºr die Vertriebsgruppe" aria-describedby="salesGroupHint">
                <span id="salesGroupHint" class="sr-only">Beliebiger Text f√ºr die Vertriebsgruppe</span>
            </div>
            <div class="form-group">
                <label for="salesDistrictInput">Vertriebsbezirk:</label>
                <input type="text" id="salesDistrictInput" placeholder="z.B. A1 oder H10A"
                       title="Beliebiger Text f√ºr den Vertriebsbezirk" aria-describedby="salesDistrictHint">
                <span id="salesDistrictHint" class="sr-only">Beliebiger Text f√ºr den Vertriebsbezirk</span>
            </div>
            <div class="form-group">
                <label for="revenueInput">Umsatz:</label>
                <input type="number" id="revenueInput" placeholder="z.B. 250000" min="0" aria-describedby="revenueHint">
                <span id="revenueHint" class="sr-only">Numerischer Wert ohne W√§hrungszeichen, zum Beispiel 250000</span>
            </div>
            <input type="hidden" id="editingRegionKey">
            <input type="hidden" id="editingEntryId">
            <input type="hidden" id="selectedColor">
            <div class="dialog-buttons">
                <button type="button" class="btn-cancel" id="cancelAddEntryButton" aria-label="Eingabe abbrechen">
                    Abbrechen
                </button>
                <button type="submit" class="btn-save" id="saveEntryButton" aria-label="Vertriebsdaten speichern">
                    Speichern
                </button>
            </div>
        </form>
    </div>
    <div id="dialogOverlay" class="overlay hidden"></div>

    <!-- Externe Bibliotheken -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin="" defer></script>
    <!-- OPTIMIERT: defer-Attribut hinzugef√ºgt -->
    <script defer>
        // OPTIMIERT: Kapselung des gesamten Skripts in ein IIFE
        (function() {
        /* Globale Konfiguration */
        const CONFIG = {
            // Verf√ºgbare Farben f√ºr Regionsmarkierungen
            colors: {
                'rot': '#ef4444', 'red': '#ef4444',
                'gr√ºn': '#10b981', 'green': '#10b981',
                'blau': '#3b82f6', 'blue': '#3b82f6',
                'gelb': '#f59e0b', 'yellow': '#f59e0b',
                'orange': '#f97316', 'lila': '#8b5cf6', 'purple': '#8b5cf6',
                't√ºrkis': '#0d9488', 'teal': '#0d9488',
                'rosa': '#ec4899', 'pink': '#ec4899',
                'grau': '#6b7280', 'gray': '#6b7280',
                'braun': '#92400e', 'brown': '#92400e',
                'hellblau': '#60a5fa', 'lightblue': '#60a5fa',
                'dunkelgr√ºn': '#166534', 'darkgreen': '#166534',
                'hellgr√ºn': '#86efac', 'lightgreen': '#86efac',
                'default': '#0d9488'
            },

            // Standard-Farbpalette f√ºr automatische Zuweisungen
            defaultColors: ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#f97316', '#ec4899', '#0d9488'],

            // Karten-Styling Definitionen
            mapStyles: {
                default: {
                    fillColor: '#e5e7eb',
                    weight: 1,
                    opacity: 1,
                    color: '#6b7280',
                    fillOpacity: 0.6
                }
            }
        };

        /* Globale Variablen */
        let leafletMap, geojsonLayer;
        let allFeaturesData = [];
        let districtData = {};
        // Namensindex f√ºr schnellen Zugriff auf Regionen nach Namen
        let nameToKeysMap = new Map();
        let markedDistricts = new Map();
        let colorIndex = 0;
        let currentSystemPrompt = "";
        let conversationHistory = []; // <-- ANPASSUNG: 'let' hinzugef√ºgt

        // NEU: Flagge, um zu verfolgen, ob die Willkommensnachricht bereits angezeigt wurde
        let hasWelcomeMessageBeenShown = false; // <-- Diese Zeile hinzuf√ºgen

        // Neue Tabellen-Datenstrukturen
        let regionsTable = [];
        let objIdToLayerMap = new Map();
        let nameToRegionsMap = new Map();

        // Normalisierter Namensindex f√ºr verbesserte Suche
        let normalizedNameMap = new Map();

        // NEU: Hover-Info-Popup-Referenzen
        let hoverInfoPopup;
        let currentHoveredLayer = null;

        // NEU: Vertriebsbezirk-Infoboxes
        let salesDistrictInfoboxes = {};
        let showSalesDistrictInfoboxes = false;
        // NEU: Toggle f√ºr Umsatzvolumen-F√§rbung
        let showRevenueBasedColoring = false;
        // NEU: Set f√ºr ausgew√§hlte Vertriebsbezirke
        let selectedSalesDistricts = new Set();
        // NEU: Flag, ob der Filter aktiv ist (true wenn explizit ausgew√§hlt/abgew√§hlt)
        let isFilterActive = false;
        // NEU: Set aller verf√ºgbaren Vertriebsbezirke
        let allSalesDistricts = new Set();

        // NEU: Mindest-Zoom-Level f√ºr Infoboxen
        const MIN_ZOOM_FOR_INFOBOXES = 7;


        /* DOM-Elemente Referenzen */
        // OPTIMIERT: Caching aller DOM-Elemente
        const DOM = {
            apiKeySection: document.getElementById('api-key-section'),
            openaiApiKeyInput: document.getElementById('openaiApiKeyInput'),
            geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
            saveApiKeyButton: document.getElementById('saveApiKeyButton'),
            chatInterface: document.getElementById('chat-interface'),
            chatlog: document.getElementById('chatlog'),
            questionInput: document.getElementById('question'),
            promptButtons: document.getElementById('promptButtons'),
            successBanner: document.getElementById('successBanner'),
            modelSelector: document.getElementById('model-selector'),
            openaiKeyContainer: document.getElementById('openai-key-container'),
            geminiKeyContainer: document.getElementById('gemini-key-container'),
            openaiValidationMessage: document.getElementById('openai-validation-message'),
            geminiValidationMessage: document.getElementById('gemini-validation-message'),
            mobileSidebarToggle: document.getElementById('mobileSidebarToggle'),
            sidebar: document.getElementById('sidebar'),
            editSalesDialog: document.getElementById('editSalesDialog'),
            dialogOverlay: document.getElementById('dialogOverlay'),
            addEntryForm: document.getElementById('addEntryForm'),
            salesGroupInput: document.getElementById('salesGroupInput'),
            salesDistrictInput: document.getElementById('salesDistrictInput'),
            revenueInput: document.getElementById('revenueInput'),
            editingRegionKey: document.getElementById('editingRegionKey'),
            editingEntryId: document.getElementById('editingEntryId'),
            selectedColor: document.getElementById('selectedColor'),
            colorPicker: document.getElementById('colorPicker'),
            salesDistrictToggle: document.getElementById('salesDistrictToggle'),
            revenueColoringToggle: document.getElementById('revenueColoringToggle'),
            salesDistrictDetailPopup: document.getElementById('salesDistrictDetailPopup'),
            detailDistrict: document.getElementById('detailDistrict'),
            detailGroup: document.getElementById('detailGroup'),
            detailRevenue: document.getElementById('detailRevenue'),
            detailRegionCount: document.getElementById('detailRegionCount'),
            detailEntryCount: document.getElementById('detailEntryCount'),
            detailRegionList: document.getElementById('detailRegionList'),
            salesGroupFilter: document.getElementById('salesGroupFilter'),
            salesDistrictSelectionContainer: document.getElementById('salesDistrictSelectionContainer'),
            salesDistrictFilterSearch: document.getElementById('salesDistrictFilterSearch'),
            salesDistrictCheckboxes: document.getElementById('salesDistrictCheckboxes'),
            selectAllDistrictsButton: document.getElementById('selectAllDistricts'),
            deselectAllDistrictsButton: document.getElementById('deselectAllDistricts'),
            welcomeMessageContainer: document.getElementById('welcomeMessageContainer'),
            readMoreBtn: document.getElementById('readMoreBtn'),
            toggleContactBtn: document.getElementById('toggleContactBtn'),
            contactInfoContainer: document.getElementById('contactInfoContainer'),
            dsgvoContentContainer: document.getElementById('dsgvoContentContainer'),
            readMoreDsgvoBtn: document.getElementById('readMoreDsgvoBtn'),
            saveDataButton: document.getElementById('saveDataButton'),
            loadDataButton: document.getElementById('loadDataButton'),
            sendButton: document.getElementById('sendButton'),
            clearButton: document.getElementById('clearButton'),
            addEntryButton: document.getElementById('addEntryButton'),
            closeEditDialogButton: document.getElementById('closeEditDialogButton'),
            cancelAddEntryButton: document.getElementById('cancelAddEntryButton'),
            salesEntriesList: document.getElementById('salesEntriesList'),
            closeSalesDistrictDetailPopupButton: document.getElementById('closeSalesDistrictDetailPopupButton'),
            editDialogTitle: document.getElementById('edit-dialog-title')
        };


        /* KI-System Prompt Definition */
        const baseSystemPrompt = `Du bist ein Multi-Landkreis-Markierungsassistent f√ºr eine interaktive Deutschlandkarte.

DEINE HAUPTaufGaben:
1. Interpretiere nat√ºrlichsprachliche Befehle zur Markierung von Landkreisen/St√§dten
2. Erstelle strukturierte JSON-Befehle f√ºr das Markierungssystem
3. Beantworte Fragen zu deutschen Landkreisen und deren Eigenschaften sowie zu den aktuellen Vertriebsdaten.

WICHTIG: Bei Regionen wie "Rostock" gibt es sowohl die kreisfreie Stadt als auch den Landkreis.
Achte auf Hinweise wie "Landkreis Rostock" oder "Stadt Rostock" um die richtige Region zu identifizieren.

VERF√úGBARE BEFEHLE (immer als JSON zur√ºckgeben):
1. Einzelne Markierung: {"action": "mark", "region": "Regionname", "regionType": "Landkreis|Kreisfreie Stadt|Region", "color": "Farbe", "salesGroup": "Vertriebsgruppe", "salesDistrict": "Vertriebsbezirk", "revenue": 100000}
2. Mehrfachmarkierung: {"action": "multi_mark", "marks": [{"region": "Region1", "regionType": "Landkreis", "color": "rot", "salesGroup": "Vertriebsgruppe1", "salesDistrict": "Vertriebsbezirk1", "revenue": 100000}, {"region": "Region2", "regionType": "Kreisfreie Stadt", "color": "blau", "salesGroup": "Vertriebsgruppe2", "salesDistrict": "Vertriebsbezirk2", "revenue": 200000}]}
3. Alle l√∂schen: {"action": "clear_all"}
4. Einzelne l√∂schen: {"action": "remove", "region": "Regionname", "regionType": "Landkreis|Kreisfreie Stadt|Region"}
5. Info anzeigen: {"action": "info", "message": "Erkl√§rungstext"}
6. Optimalen Eingabehinweis anzeigen: {"action": "show_optimal_input_hint"}

NEU: Du kannst nun auch Vertriebsinformationen zu den Regionen hinzuf√ºgen. Die Felder salesGroup und salesDistrict k√∂nnen beliebige Texte enthalten:
- salesGroup: Vertriebsgruppe (z.B. "Nord", "ISL1", "Gruppe A")
- salesDistrict: Vertriebsbezirk (z.B. "Gebiet 1", "H10A", "Bezirk XY")
- revenue: Umsatz (numerischer Wert ohne W√§hrungszeichen)

VERF√úGBARE FARBEN: rot, gr√ºn, blau, gelb, orange, lila, t√ºrkis, rosa, grau, braun, hellblau, dunkelgr√ºn, hellgr√ºn

BEISPIELE:
User: "Markiere M√ºnchen rot mit Vertriebsgruppe S√ºd, Bezirk B2 und Umsatz 500000"
Assistant: {"action": "mark", "region": "M√ºnchen", "regionType": "Kreisfreie Stadt", "color": "rot", "salesGroup": "S√ºd", "salesDistrict": "B2", "revenue": 500000}

User: "Markiere Landkreis Rostock gelb mit Vertriebsgruppe Ost, Bezirk Z9 und Umsatz 150000"
Assistant: {"action": "mark", "region": "Rostock", "regionType": "Landkreis", "color": "gelb", "salesGroup": "Ost", "salesDistrict": "Z9", "revenue": 150000}

User: "Zeige alle Landkreise in Bayern"
Assistant: {"action": "info", "message": "Hier sind alle Landkreise in Bayern: Aichach-Friedberg, Alt√∂tting, Amberg-Sulzbach, ..."}

User: "Zeige mir das Format f√ºr optimale Dateneingabe"
Assistant: {"action": "show_optimal_input_hint"}

`; // This will be appended by the dynamic prompt generation

        /* NEU: Inhalt f√ºr den optimalen Eingabehinweis */
        const OPTIMAL_INPUT_HINT_CONTENT = `Sie k√∂nnen Regionen markieren und Vertriebsdaten zuweisen:<br><ul><li><strong>Einzelne Zeile (KI-gesteuert):</strong><br><code>Markiere [Region] [Farbe] mit Vertriebsgruppe [Gruppe], Bezirk [Bezirk] und Umsatz [Zahl]</code><br><small>Beispiel: <code>Markiere Berlin rot mit Vertriebsgruppe Nord, Bezirk A1 und Umsatz 500000</code></small></li><li><strong>Mehrere Zeilen (Tabellarisch, ohne KI):</strong><br><code>[Typ] [Region] [Gruppe] [Bezirk] [Farbe] [Umsatz]</code><br><small>Beispiel:<br><code>Landkreis Rostock Nord A1 gelb 300000</code><br><code>Kreisfreie Stadt M√ºnchen S√ºd B2 rot 750000</code></small></li></ul><small>Die Felder f√ºr Vertriebsgruppe und Bezirk k√∂nnen beliebige Texte enthalten.</small>`;

        /* NEU: DSGVO-Text */
        const FULL_DSGVO_TEXT_RAW = `
üìú Datenschutzerkl√§rung
(Deutsch, DSGVO-konform, Stand: 2025)
GeoFuchs ‚Äì Interaktive KI-Kartenanwendung

Verantwortlich: G√ºnter Struck
E-Mail: geofuchs@online.de

1. Allgemeines
Diese App dient der interaktiven Visualisierung und Analyse deutscher Landkreise und nutzt dazu KI-Dienste sowie √∂ffentlich zug√§ngliche Kartendaten. Die Nutzung erfolgt ohne Registrierung und ohne Werbetracking.

2. Verarbeitung personenbezogener Daten
Die App verarbeitet keine personenbezogenen Daten im Sinne der DSGVO dauerhaft.

Tempor√§re Eingaben (z.‚ÄØB. √ºber das Chatfeld) k√∂nnen bei Nutzung der KI-Funktion an folgende Anbieter √ºbermittelt werden:

OpenAI (api.openai.com)

Google AI Studio (Gemini) (generativelanguage.googleapis.com)

Diese Daten werden ausschlie√ülich zum Zweck der KI-Verarbeitung verwendet. Die Verarbeitung erfolgt nach den Datenschutzrichtlinien der jeweiligen Anbieter. Es erfolgt keine dauerhafte Speicherung durch den App-Entwickler.

3. Kartendaten & Standort
Die Kartenansicht basiert auf OpenStreetMap-Kacheln, bereitgestellt durch:

basemaps.cartocdn.com (CARTO)

Leaflet.js

Diese Dienste k√∂nnen beim Laden der Karte technische Informationen wie die IP-Adresse √ºbertragen bekommen. Eine personenbezogene Auswertung findet seitens des App-Anbieters nicht statt.

4. Lokale Speicherung
Vom Nutzer erzeugte Daten (z.‚ÄØB. Markierungen, Ums√§tze, Gruppenzuordnungen) k√∂nnen lokal im Ger√§t oder tempor√§r im Browsercache gespeichert werden, sofern dies vom Nutzer ausgel√∂st wird (‚Äûüíæ Daten speichern‚Äú).

Es erfolgt keine automatische √úbertragung oder externe Speicherung dieser Inhalte durch den Anbieter.

5. Keine Haftung
Diese App wird als MVP (Minimum Viable Product) ohne Gew√§hr bereitgestellt. Trotz sorgf√§ltiger Umsetzung wird keine Haftung f√ºr die Richtigkeit, Vollst√§ndigkeit oder Verf√ºgbarkeit der bereitgestellten Funktionen oder Daten √ºbernommen.

Die Nutzung erfolgt auf eigene Verantwortung.

6. Rechte gem√§√ü DSGVO
Als Nutzer:in haben Sie das Recht auf:

Auskunft √ºber verarbeitete Daten

Berichtigung oder L√∂schung

Einschr√§nkung der Verarbeitung

Widerspruch gegen die Verarbeitung

Da keine personenbezogenen Daten dauerhaft gespeichert werden, ist die Aus√ºbung dieser Rechte aktuell nicht notwendig.

7. Kontakt
Bei Fragen zum Datenschutz wenden Sie sich bitte an:
G√ºnter Struck
E-Mail: geofuchs@online.de
`;
        // MODIFIED: Changed the truncation marker to hide "GeoFuchs ‚Äì Interaktive KI-Kartenanwendung" and everything after it initially
        const DSGVO_TRUNCATION_MARKER = "GeoFuchs ‚Äì Interaktive KI-Kartenanwendung";
        let truncatedDsgvoContent = '';
        let expandedDsgvoContent = '';

        /* Live-Validierung f√ºr API-Keys */
        // OPTIMIERT: Event-Listener direkt registrieren
        DOM.openaiApiKeyInput.addEventListener('input', validateOpenAIKey);
        DOM.geminiApiKeyInput.addEventListener('input', validateGeminiKey);

        function validateOpenAIKey() {
            const key = DOM.openaiApiKeyInput.value.trim();
            if (!key) {
                DOM.openaiValidationMessage.textContent = "";
                return false;
            }

            if (!key.startsWith('sk-')) {
                DOM.openaiValidationMessage.textContent = "OpenAI-Schl√ºssel sollten mit 'sk-' beginnen";
                DOM.openaiValidationMessage.className = "error-message";
                return false;
            }

            if (key.length < 20) {
                DOM.openaiValidationMessage.textContent = "Schl√ºssel scheint zu kurz zu sein";
                DOM.openaiValidationMessage.className = "info-message";
                return false;
            }

            DOM.openaiValidationMessage.textContent = "‚úì Format g√ºltig";
            DOM.openaiValidationMessage.className = "info-message";
            return true;
        }

        function validateGeminiKey() {
            const key = DOM.geminiApiKeyInput.value.trim();
            if (!key) {
                DOM.geminiValidationMessage.textContent = "";
                return false;
            }

            if (key.length < 20) {
                DOM.geminiValidationMessage.textContent = "Schl√ºssel scheint zu kurz zu sein";
                DOM.geminiValidationMessage.className = "info-message";
                return false;
            }

            DOM.geminiValidationMessage.textContent = "‚úì Format g√ºltig";
            DOM.geminiValidationMessage.className = "info-message";
            return true;
        }

        /* Funktion zum Speichern des API-Schl√ºssels und Aktivieren des Systems */
        // OPTIMIERT: Event-Listener direkt registrieren
        DOM.saveApiKeyButton.addEventListener('click', () => {
            const selectedModel = document.querySelector('input[name="model"]:checked').value;
            let key = '';
            let isValid = false;

            if (selectedModel === 'openai') {
                key = DOM.openaiApiKeyInput.value.trim();
                isValid = validateOpenAIKey();
                sessionStorage.setItem('openai_api_key', key);
            } else {
                key = DOM.geminiApiKeyInput.value.trim();
                isValid = validateGeminiKey();
                sessionStorage.setItem('gemini_api_key', key);
            }

            if (key && isValid) {
                sessionStorage.setItem('selected_model', selectedModel);
                DOM.apiKeySection.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.chatInterface.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                initializeChatInterface();

                setTimeout(() => DOM.questionInput.focus(), 100);
            } else {
                const errorMessage = key ? "Der eingegebene API-Schl√ºssel scheint ung√ºltig zu sein."
                                     : "Bitte geben Sie einen API-Schl√ºssel ein.";
                appendErrorMessage(errorMessage);
            }
        });

        /* Funktion zum Anzeigen von Fehlermeldungen */
        function appendErrorMessage(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            errorDiv.setAttribute('role', 'alert');

            // OPTIMIERT: Pr√ºfen, ob API-Key-Sektion sichtbar ist
            if (!DOM.apiKeySection.classList.contains('hidden')) {
                DOM.apiKeySection.appendChild(errorDiv);

                setTimeout(() => {
                    if (errorDiv.parentElement === DOM.apiKeySection) {
                        DOM.apiKeySection.removeChild(errorDiv);
                    }
                }, 5000);
            } else {
                appendMessageToChatLog('‚ùå ' + message, 'assistant');
            }
        }

        /* Chat-Interface Initialisierung */
        function initializeChatInterface() {
            // Pr√ºfen, ob die Willkommensnachricht in dieser Sitzung bereits angezeigt wurde
            if (hasWelcomeMessageBeenShown) {
                return; // Wenn ja, beende die Funktion, um eine doppelte Anzeige zu verhindern
            }
            const selectedModel = sessionStorage.getItem('selected_model');
            let modelName = '';

            if (selectedModel === 'openai') {
                modelName = 'OpenAI GPT-4.1';
            } else {
               modelName = 'Google Gemini 2.5 Pro';
            }

            DOM.successBanner.textContent = `üéØ KI-SYSTEM AKTIV (${modelName}!`;

            appendMessageToChatLog(
                `Willkommen! üéâ\nIch bin Ihr KI-Assistent f√ºr Landkreismarkierungen\n\n` +
                "Was kann ich tun:\n" +
                "‚Ä¢ 'Markiere Berlin rot'\n" +
                "‚Ä¢ 'Markiere Landkreis Rostock gelb mit Vertriebsgruppe Nord, Vertriebsbezirk A1 und Umsatz 300000'\n" +
                "Sie k√∂nnen mehrere Vertriebsbezirke pro Region hinzuf√ºgen und die Daten sp√§ter durch Klicken auf 'Bearbeiten' verwalten.\n" +
                "Fragen Sie mich nach der optimalen Dateneingabe (Tabelle), ich zeige Ihnen gerne das Format.\n\n" +
                "Wie kann ich Ihnen helfen? Eine Basis-Schulung?",
                'assistant'
            );

            DOM.questionInput.focus();
hasWelcomeMessageBeenShown = true; // Setze die Flagge auf true, nachdem die Nachricht angezeigt wurde
        }

        /* NEU: Verbesserte Funktion zum Parsen von tabellarischen Daten */
        function parseTableData(input) {
            if (!input || typeof input !== 'string') return { success: false, message: "Keine Eingabe vorhanden." };

            const lines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
            if (lines.length === 0) return { success: false, message: "Keine Daten zum Verarbeiten gefunden." };

            const results = {
                success: false,
                processed: 0,
                failed: 0,
                entries: [],
                failedLines: []
            };

            // Regex for a full line with flexible spaces and ANY salesGroup/salesDistrict
            // GE√ÑNDERT: Region Name ist jetzt nicht-gierig (mit '?') und SalesGroup/SalesDistrict sind \S+
            const fullPattern = /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)(?:\s*(\d+))?$/i;

            lines.forEach((line, index) => {
                try {
                    const match = line.trim().match(fullPattern);

                    if (match) {
                        const regionType = match[1];
                        const regionName = match[2].trim();
                        const salesGroup = match[3].trim();
                        const salesDistrict = match[4].trim();
                        const color = match[5].toLowerCase();
                        const revenue = match[6] ? parseInt(match[6]) : 0;

                        // Basic validation after extraction and cleaning
                        if (!regionType || !regionType.match(/^(Landkreis|Kreisfreie Stadt|Stadt|Region)$/i)) {
                            throw new Error("Ung√ºltiger Regionstyp");
                        }
                        if (!regionName || regionName.trim().length === 0) {
                            throw new Error("Ung√ºltiger Regionsname");
                        }
                        // Removed specific salesGroup/salesDistrict format validation
                        if (!color || !CONFIG.colors[color]) {
                            throw new Error("Ung√ºltige Farbe");
                        }
                        if (isNaN(revenue)) {
                            throw new Error("Umsatz muss eine Zahl sein");
                        }

                        const entry = {
                            action: "mark",
                            region: regionName,
                            regionType: regionType,
                            color: color,
                            salesGroup: salesGroup,
                            salesDistrict: salesDistrict,
                            revenue: revenue
                        };

                        results.entries.push(entry);
                        results.processed++;
                    } else {
                        throw new Error("Ung√ºltiges Format der Zeile");
                    }
                } catch (error) {
                    results.failed++;
                    results.failedLines.push({
                        lineNumber: index + 1,
                        content: line,
                        error: error.message
                    });
                }
            });

            if (results.processed > 0) {
                results.success = true;
                results.message = `${results.processed} von ${results.processed + results.failed} Zeilen erfolgreich verarbeitet.`;
            } else {
                results.message = "Keine Daten konnten erfolgreich verarbeitet werden.";
            }

            return results;
        }

        /* NEU: Funktion zum Verarbeiten tabellarischer Daten und Ausf√ºhren der Markierungen */
        function processTableData(input) {
            try {
                const parseResult = parseTableData(input);

                if (!parseResult.success) {
                    appendMessageToChatLog(`‚ùå ${parseResult.message}`, 'assistant');
                    return false;
                }

                // Erfolgreich verarbeitete Eintr√§ge
                if (parseResult.entries && parseResult.entries.length > 0) {
                    // Erstelle ein multi_mark Kommando f√ºr alle Eintr√§ge
                    const multiMarkCommand = {
                        action: "multi_mark",
                        marks: parseResult.entries
                    };

                    // F√ºhre das Kommando aus
                    executeCommand(multiMarkCommand);

                    // Erfolgsstatistik anzeigen
                    let successMessage = `‚úÖ ${parseResult.processed} von ${parseResult.processed + parseResult.failed} Zeilen erfolgreich verarbeitet.`;

                    if (parseResult.failed > 0) {
                        successMessage += `\n‚ùå ${parseResult.failed} Zeilen konnten nicht verarbeitet werden.`;
                    }

                    appendMessageToChatLog(successMessage, 'assistant');
                    return true;
                } else {
                    appendMessageToChatLog("‚ùå Keine Daten konnten verarbeitet werden.", 'assistant');
                    return false;
                }
            } catch (error) {
                appendMessageToChatLog(`‚ùå Fehler bei der Verarbeitung: ${error.message}`, 'assistant');
                return false;
            }
        }

        /* OPTIMIERT: Erkennung von tabellarischen Daten in mehrzeiligen Eingaben */
        function isTableData(input) {
            if (!input || typeof input !== 'string') return false;

            // Teile die Eingabe in Zeilen auf
            const lines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
            if (lines.length <= 1) return false; // Nicht mehrzeilig

            // √úberpr√ºfe, ob die erste Zeile dem Tabellenformat entspricht
            const firstLine = lines[0].trim();

            // Pr√ºfe auf verschiedene Tabellenmuster (gelockerte Vertriebsdaten-Muster)
            // GE√ÑNDERT: Region Name ist jetzt nicht-gierig (mit '?') und SalesGroup/SalesDistrict sind \S+
            const tablePattern = /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)(?:\s*(\d+))?$/i;

            // Wenn die erste Zeile dem Muster entspricht, handelt es sich wahrscheinlich um Tabellendaten
            return tablePattern.test(firstLine);
        }

        /* √úBERARBEITET: Verarbeitung mehrzeiliger Eingaben mit verbesserter Tabellenunterst√ºtzung */
        function processMultiLineInput(input) {
            if (!input || typeof input !== 'string') return false;

            // Teile die Eingabe in Zeilen auf
            const lines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
            if (lines.length <= 1) return false; // Nicht mehrzeilig

            // NEU: Pr√ºfe zuerst auf tabellarische Daten
            if (isTableData(input)) {
                processTableData(input);
                return true; // Beenden, wenn Tabellendaten verarbeitet wurden
            }

            // Sonst verarbeite jede Zeile einzeln wie zuvor
            let processedLines = 0;
            let failedLines = [];

            // Verarbeite jede Zeile
            lines.forEach((line, index) => {
                const success = processLineCommand(line.trim());
                if (success) {
                    processedLines++;
                } else {
                    failedLines.push(line);
                }
            });

            // Erfolgsmeldung
            if (processedLines > 0) {
                appendMessageToChatLog(
                    `‚úÖ ${processedLines} von ${lines.length} Zeilen wurden erfolgreich verarbeitet!` +
                    (failedLines.length > 0 ? `\n‚ùå Folgende Zeilen konnten nicht verarbeitet werden:\n${failedLines.join('\n')}` : ''),
                    'assistant'
                );
            }
            else {
                appendMessageToChatLog(`‚ùå Keine der Zeilen konnte verarbeitet werden.`, 'assistant');
                return false;
            }

            return true;
        }

        /* OPTIMIERT: Verarbeitet eine einzelne Befehlszeile mit verbesserter Farb-/Umsatzerkennung */
        function processLineCommand(line) {
            if (!line) return false;

            // 1. Pr√ºfe auf JSON-Format
            if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                try {
                    const command = JSON.parse(line);
                    if (command && command.action) { // Nur ausf√ºhren, wenn es ein g√ºltiger Befehl ist
                        executeCommand(command);
                        return true;
                    }
                } catch (error) {
                    // Fehler beim JSON-Parsen, ignoriere und versuche andere Formate
                }
            }

            // 2. Pr√ºfe auf direktes Format: "Landkreis Verden Blau"
            const directRegionColorPattern = /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)$/i;
            const directMatch = line.match(directRegionColorPattern);

            if (directMatch) {
                const regionType = directMatch[1];
                const regionName = directMatch[2].trim();
                const color = directMatch[3].toLowerCase();

                const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                const success = markAllMatchingRegions(regionName, regionType, colorHex, true);
                return success.success || success === true;
            }

            // 3. Pr√ºfe auf "Markiere XYZ Farbe"-Format
            const markRegionPattern = /^Markiere\s+(Landkreis|Kreisfreie Stadt|Stadt|Region)?\s*([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)$/i;
            const markMatch = line.match(markRegionPattern);

            if (markMatch) {
                const regionType = markMatch[1] || null;
                const regionName = markMatch[2].trim();
                const color = markMatch[3].toLowerCase();

                const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                const success = markAllMatchingRegions(regionName, regionType, colorHex, true);
                return success.success || success === true;
            }

            // 4. OPTIMIERT: Pr√ºfe auf tabellarisches Format mit flexiblen Trennzeichen und Farb-/Umsatzformaten
            const tablePatterns = [
                // Muster 1: "Landkreis Name Gruppe Bezirk rot 123456" - with spaces, any group/district
                // GE√ÑNDERT: Region Name ist jetzt nicht-gierig (mit '?') und SalesGroup/SalesDistrict sind \S+
                /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)\s+(\d+)$/i,

                // Muster 2: "Landkreis Name Gruppe Bezirk rot123456" - with spaces, combined color/revenue
                // GE√ÑNDERT: Region Name ist jetzt nicht-gierig (with '?') and SalesGroup/salesDistrict are \S+
                /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)(\d+)$/i
            ];

            // Pr√ºfe jedes Muster
            for (const pattern of tablePatterns) {
                const match = line.match(pattern);
                if (match) {
                    const regionType = match[1];
                    const regionName = match[2].trim();
                    const salesGroup = match[3].trim();
                    const salesDistrict = match[4].trim();
                    const color = match[5].toLowerCase();
                    const revenue = parseInt(match[6]);

                    const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                    const success = markAllMatchingRegions(regionName, regionType, colorHex, true, salesGroup, salesDistrict, revenue);
                    return success.success || success === true;
                }
            }

            // 5. OPTIMIERT: Pr√ºfe auf "Markiere"-Pr√§fix mit Vertriebsdaten und flexiblen Formaten
            const markWithSalesPatterns = [
                // Muster 1: "Markiere Landkreis Name Gruppe Bezirk rot 123456" - with spaces
                // GE√ÑNDERT: Region Name ist jetzt nicht-gierig (with '?') and SalesGroup/SalesDistrict are \S+
                /^Markiere\s+(Landkreis|Kreisfreie Stadt|Stadt|Region)?\s*([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)\s+(\d+)$/i,

                // Muster 2: "Markiere Landkreis Name Gruppe Bezirk rot123456" - with spaces, combined color/revenue
                // GE√ÑNDERT: Region Name ist jetzt nicht-gierig (with '?') and SalesGroup/SalesDistrict are \S+
                /^Markiere\s+(Landkreis|Kreisfreie Stadt|Stadt|Region)?\s*([\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|gr√ºn|blau|gelb|orange|lila|t√ºrkis|rosa|grau|braun|hellblau|dunkelgr√ºn|hellgr√ºn)(\d+)$/i
            ];

            // Pr√ºfe jedes Muster
            for (const pattern of markWithSalesPatterns) {
                const match = line.match(pattern);
                if (match) {
                    const regionType = match[1] || null;
                    const regionName = match[2].trim();
                    const salesGroup = match[3].trim();
                    const salesDistrict = match[4].trim();
                    const color = match[5].toLowerCase();
                    const revenue = parseInt(match[6]);

                    const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                    const success = markAllMatchingRegions(regionName, regionType, colorHex, true, salesGroup, salesDistrict, revenue);
                    return success.success || success === true;
                }
            }

            // 6. Wenn nichts passt, kann die Zeile nicht direkt verarbeitet werden
            return false;
        }

        /* MODIFIZIERTE FUNKTION: KI-Kommunikation mit verbesserter Tabellenunterst√ºtzung */
        async function sendMessage() {
            const selectedModel = sessionStorage.getItem('selected_model');
            const apiKey = sessionStorage.getItem(selectedModel === 'openai' ? 'openai_api_key' : 'gemini_api_key');

            if (!apiKey) {
                appendMessageToChatLog("Sie sind im Basic-Modus. F√ºr KI-Funktionen ben√∂tigen Sie einen API-Schl√ºssel.", 'assistant');
                return;
            }

            const question = DOM.questionInput.value.trim();
            if (!question) return;

            // Zeige die Anfrage im Chat-Log an
            appendMessageToChatLog(escapeHtml(question), 'user');
            DOM.questionInput.value = "";
            DOM.promptButtons.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden

            // NEU: Pr√ºfe zuerst auf tabellarische Daten
            if (isTableData(question)) {
                processTableData(question);
                return; // Beenden, wenn Tabellendaten verarbeitet wurden
            }

            // Pr√ºfe auf mehrzeilige Eingabe
            if (processMultiLineInput(question)) {
                return; // Beenden, wenn mehrere Zeilen erfolgreich verarbeitet wurden
            }

            // Versuche, einzelne Zeile direkt zu verarbeiten
            if (processLineCommand(question)) {
                return; // Beenden, wenn die Zeile erfolgreich verarbeitet wurde
            }

            // Falls keine direkte Verarbeitung m√∂glich war, frage die KI
            // Dynamisch den System-Prompt generieren
            currentSystemPrompt = generateDynamicSystemPrompt();

            showTypingIndicator();
            conversationHistory.push({ role: "user", content: question });

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                let reply = '';

                if (selectedModel === 'openai') {
                    reply = await callOpenAI(apiKey, controller.signal);
                } else {
                    reply = await callGemini(apiKey, controller.signal);
                }

                clearTimeout(timeoutId);

                conversationHistory.push({ role: "assistant", content: reply });
                processAssistantReply(reply);

            } catch (error) {
                console.error("API-Fehler:", error);
                let errorMessage;

                if (error.name === 'AbortError') {
                    errorMessage = "Die Anfrage hat zu lange gedauert und wurde abgebrochen.";
                } else if (error.message.includes('429')) {
                    errorMessage = "API-Limit √ºberschritten. Bitte warten Sie einen Moment und versuchen Sie es erneut.";
                } else {
                    errorMessage = `Ein Fehler ist aufgetreten: ${error.message}`;
                }

                appendMessageToChatLog(`‚ùå ${errorMessage}`, 'assistant');
            } finally {
                removeTypingIndicator();
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /* OpenAI API-Aufruf */
        async function callOpenAI(apiKey, signal) {
            const messages = [
                { role: "system", content: currentSystemPrompt },
                ...conversationHistory.slice(-10)
            ];

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                signal: signal,
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    model: "gpt-4",
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 500
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`OpenAI API Fehler: ${response.status} - ${errorData.error?.message || 'Unbekannter Fehler'}`);
            }

            const data = await response.json();
            return data.choices?.[0]?.message?.content || "Keine Antwort von OpenAI erhalten.";
        }

        /* Google Gemini API-Aufruf */
        async function callGemini(apiKey, signal) {
            const geminiHistory = conversationHistory.slice(-10).map(msg => ({
                role: msg.role === 'assistant' ? 'model' : 'user',
                parts: [{ text: msg.content }]
            }));

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${apiKey}`;

            const response = await fetch(url, {
                method: "POST",
                signal: signal,
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ contents: geminiHistory, system_instruction: { parts: [{ text: currentSystemPrompt }] } })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Google Gemini API Fehler: ${response.status} - ${errorData.error?.message || 'Unbekannter Fehler'}`);
            }

            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "Keine Antwort von Gemini erhalten.";
        }

        /* KI-Antwort Verarbeitung */
        function processAssistantReply(reply) {
            if (!reply) {
                appendMessageToChatLog("Keine Antwort erhalten.", 'assistant');
                return;
            }

            try {
                const jsonMatch = reply.match(/(\{[\s\S]*?\})(?!\s*[,:])/);

                if (jsonMatch) {
                    try {
                        const command = JSON.parse(jsonMatch[0]);
                        executeCommand(command);

                        const additionalText = reply.replace(jsonMatch[0], '').trim();
                        if (additionalText) {
                            appendMessageToChatLog(escapeHtml(additionalText), 'assistant');
                        }
                    } catch (jsonError) {
                        console.error("JSON Parse Fehler:", jsonError);
                        appendMessageToChatLog(escapeHtml(reply), 'assistant');
                    }
                } else {
                    appendMessageToChatLog(escapeHtml(reply), 'assistant');
                }
            } catch (error) {
                console.error("Fehler bei der Antwortverarbeitung:", error);
                appendMessageToChatLog(escapeHtml(reply), 'assistant');
            }
        }

        /* Befehlsausf√ºhrung */
        function executeCommand(command) {
            if (!command || typeof command !== 'object') {
                appendMessageToChatLog("‚ö†Ô∏è Ung√ºltiger Befehl erhalten", 'assistant');
                return;
            }

            switch(command.action) {
                case 'mark':
                    if (command.region) {
                        const color = CONFIG.colors[command.color] || CONFIG.colors.default;
                        const regionType = command.regionType || null;

                        // Verwende die neue Mehrfachmarkierungsfunktion statt highlightDistrictMulti
                        const success = markAllMatchingRegions(
                            command.region,
                            regionType,
                            color,
                            false,
                            command.salesGroup,
                            command.salesDistrict,
                            command.revenue
                        );

                        if (success) {
                            // Die Erfolgsmeldung wird bereits in markAllMatchingRegions erzeugt
                        } else {
                            appendMessageToChatLog(
                                `‚ùå Die Region "${escapeHtml(command.region)}"${regionType ? ` (${regionType})` : ''} konnte nicht gefunden werden.`,
                                'assistant'
                            );
                        }
                    }
                    break;

                case 'multi_mark':
                    if (command.marks && Array.isArray(command.marks)) {
                        let successCount = 0;
                        let totalMarked = 0;
                        let failedRegions = [];

                        command.marks.forEach(mark => {
                            if (mark && mark.region) {
                                const color = CONFIG.colors[mark.color] || CONFIG.colors.default;
                                const regionType = mark.regionType || null;

                                // Verwende die neue Mehrfachmarkierungsfunktion
                                const result = markAllMatchingRegions(
                                    mark.region,
                                    regionType,
                                    color,
                                    true,
                                    mark.salesGroup,
                                    mark.salesDistrict,
                                    mark.revenue
                                );

                                if (result.success) {
                                    successCount++;
                                    totalMarked += result.count;
                                } else {
                                    failedRegions.push(`${mark.region}${regionType ? ` (${regionType})` : ''}`);
                                }
                            }
                        });

                        let message = `‚úÖ ${successCount} von ${command.marks.length} Regionstypen erfolgreich markiert! (Insgesamt ${totalMarked} Regionen)`;
                        if (failedRegions.length > 0) {
                            message += `\n‚ùå Nicht gefunden: ${escapeHtml(failedRegions.join(', '))}`;
                        }

                        appendMessageToChatLog(message, 'assistant');
                    }
                    break;

                case 'clear_all':
                    clearAllMarkings();
                    break;

                case 'remove':
                    if (command.region) {
                        removeMarking(command.region, command.regionType);
                    }
                    break;

                case 'info':
                    if (command.message) {
                        appendMessageToChatLog(escapeHtml(command.message), 'assistant');
                    }
                    break;

                case 'show_optimal_input_hint': // NEU: Fall f√ºr optimalen Eingabehinweis
                    // Hier wird der HTML-Inhalt direkt √ºbergeben, um die Formatierung zu erhalten
                    appendMessageToChatLog(OPTIMAL_INPUT_HINT_CONTENT, 'assistant');
                    break;

                // NEUE KI-BEFEHLE
                case 'analyze_revenue':
                    if (command.type) {
                        const message = analyzeRevenue(command.type, command.filter);
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("‚ö†Ô∏è Fehlender 'type' f√ºr analyze_revenue Befehl.", 'assistant');
                    }
                    break;
                case 'top_list':
                    if (command.type && command.limit) {
                        const message = getTopList(command.type, command.limit);
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("‚ö†Ô∏è Fehlende 'type' oder 'limit' f√ºr top_list Befehl.", 'assistant');
                    }
                    break;
                case 'analyze_district':
                    if (command.salesDistrict || command.salesGroup) {
                        const message = analyzeDistrict(command); // Pass the whole command as filter
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("‚ö†Ô∏è Fehlender 'salesDistrict' oder 'salesGroup' f√ºr analyze_district Befehl.", 'assistant');
                    }
                    break;
                case 'compare':
                    if (command.type === 'districts' && command.items && Array.isArray(command.items) && command.items.length === 2) {
                        const message = compareDistricts(command.items);
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("‚ö†Ô∏è Ung√ºltige Parameter f√ºr compare Befehl.", 'assistant');
                    }
                    break;

                default:
                    appendMessageToChatLog("‚ö†Ô∏è Befehl nicht erkannt: " + command.action, 'assistant');
            }
        }

        /* OPTIMIERT: Normalisiert einen Regionsnamen f√ºr verbesserte Suche */
        function normalizeRegionName(name) {
            if (!name) return '';

            // Zu Kleinbuchstaben konvertieren
            let normalized = name.toLowerCase();

            // Umlaute korrekt normalisieren (statt nur √§ -> a, auch √§ -> ae usw.)
            normalized = normalized.replace(/√§/g, 'ae')
                                  .replace(/√∂/g, 'oe')
                                  .replace(/√º/g, 'ue')
                                  .replace(/√ü/g, 'ss');

            // Mehrfache Leerzeichen durch einzelne ersetzen
            normalized = normalized.replace(/\s+/g, ' ');

            // Sonderzeichen entfernen
            normalized = normalized.replace(/[^\w√§√∂√º√Ñ√ñ√ú√ü\s\-.,()]/g, ''); // Erlaubt auch Klammern und Punkte

            // Leerzeichen an Anfang und Ende entfernen
            normalized = normalized.trim();

            return normalized;
        }

        /* OPTIMIERT: Verbesserte und pr√§zisere Regionstyp-Normalisierung mit "Region" */
        function normalizeRegionType(type) {
            if (!type) return '';

            // Zu Kleinbuchstaben und Entfernung √ºberfl√ºssiger Leerzeichen
            const typeLC = type.toLowerCase().trim();

            // Detailliertere Mapping-Tabelle f√ºr pr√§zisere Unterscheidung
            // OPTIMIERT: Erweiterte Kategorien f√ºr "Landkreis", "Kreisfreie Stadt" und "Region"
            const typeMap = {
                // Landkreis-Varianten
                'landkreis': 'landkreis',
                'kreis': 'landkreis',
                'lk': 'landkreis',
                'lkr': 'landkreis',
                'landkr': 'landkreis',
                'landrat': 'landkreis',
                'staedteregion': 'landkreis', // HINZUGEF√úGT f√ºr "St√§dteregion Aachen"

                // Stadt-Varianten
                'kreisfreie stadt': 'kreisfreie stadt',
                'kreisfrei': 'kreisfreie stadt',
                'kreisstadt': 'kreisfreie stadt',
                'stadt': 'kreisfreie stadt',
                'stadtkreis': 'kreisfreie stadt',

                // Region-Varianten hinzugef√ºgt
                'region': 'region'
            };

            // Direkter Schl√ºsselabgleich
            if (typeMap[typeLC]) {
                return typeMap[typeLC];
            }

            // Teilstring-Erkennung f√ºr komplexere Ausdr√ºcke
            for (const [key, value] of Object.entries(typeMap)) {
                // Exaktere Teilstring-Erkennung mit Wortgrenzen
                // Das verbessert insbesondere die Unterscheidung zwischen "Stadt" und "Landkreis"
                if (typeLC.includes(key) ||
                    typeLC.match(new RegExp(`\\b${key}\\b`))) {
                    return value;
                }
            }

            // Gibt den urspr√ºnglichen Wert zur√ºck, wenn keine √úbereinstimmung
            return typeLC;
        }

        /* NEU: Funktion zum Mischen von Farben f√ºr mehrere Vertriebsbezirke */
        function mixColors(colors) {
            if (!colors || colors.length === 0) return CONFIG.colors.default;
            if (colors.length === 1) return colors[0];

            // RGB-Werte extrahieren und mitteln
            let r = 0, g = 0, b = 0;
            colors.forEach(hexColor => {
                if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                const rValue = parseInt(hexColor.slice(1, 3), 16);
                const gValue = parseInt(hexColor.slice(3, 5), 16);
                const bValue = parseInt(hexColor.slice(5, 7), 16);
                r += rValue;
                g += gValue;
                b += bValue;
            });

            // Durchschnitt berechnen
            r = Math.round(r / colors.length);
            g = Math.round(g / colors.length);
            b = Math.round(b / colors.length);

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        /* NEU: Funktion zum Generieren einer eindeutigen ID */
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        /* NEU: Funktion zum Ermitteln der Farbe basierend auf dem h√∂chsten Umsatz */
        function getRevenueBasedColor(salesEntries) {
            if (!salesEntries || salesEntries.length === 0) {
                return null; // Kein Eintrag, keine Farbe
            }

            let maxRevenue = -1;
            let colorOfMaxRevenueEntry = null;

            salesEntries.forEach(entry => {
                if (entry.revenue > maxRevenue) {
                    maxRevenue = entry.revenue;
                    colorOfMaxRevenueEntry = entry.color;
                }
            });

            // Wenn alle Ums√§tze 0 oder negativ sind, oder kein Umsatz gefunden wurde,
            // greife auf die gemischte Farbe zur√ºck (falls vorhanden) oder Standardfarbe
            if (maxRevenue <= 0 && salesEntries.length > 0) {
                return mixColors(salesEntries.map(e => e.color)); // Fallback zur gemischten Farbe
            }

            return colorOfMaxRevenueEntry || CONFIG.colors.default;
        }

        /* KORRIGIERT: Markiere alle passenden Regionen mit verbesserter Regionstyp-Erkennung und Vertriebsdaten */
        function markAllMatchingRegions(searchTerm, regionType, color, suppressMessage = false, salesGroup = null, salesDistrict = null, revenue = null) {
            let matchCount = 0;
            let result = { success: false, count: 0 };

            try {
                // Verwenden Sie die robuste findRegionInTable, um alle potenziellen √úbereinstimmungen zu erhalten
                const foundRegions = findRegionInTable(searchTerm, regionType, true); // true f√ºr findAll

                if (!foundRegions || foundRegions.length === 0) {
                    result = { success: false, count: 0 };
                    if (!suppressMessage) {
                        appendMessageToChatLog(
                            `‚ùå Die Region "${escapeHtml(searchTerm)}"${regionType ? ` (${regionType})` : ''} konnte nicht gefunden werden.`,
                            'assistant'
                        );
                    }
                    return suppressMessage ? result : false;
                }

                const numGeographicalParts = foundRegions.length; // Dies ist die Gesamtzahl der geografischen Teile f√ºr die administrative Einheit

                foundRegions.forEach(region => {
                    const layer = objIdToLayerMap.get(region.objid);

                    if (layer) {
                        const combinedKey = `${region.name}__${region.type}__${region.objid}`;

                        const newSalesEntry = {
                            id: generateUniqueId(),
                            color: color,
                            salesGroup: salesGroup || "",
                            salesDistrict: salesDistrict || "",
                            revenue: revenue // Vollst√§ndiger administrativer Umsatz
                        };

                        if (markedDistricts.has(combinedKey)) {
                            const existingData = markedDistricts.get(combinedKey);
                            let entryToUpdateIndex = -1;

                            // Vorhandenen Eintrag nach salesDistrict finden, oder den ersten leeren, wenn der neue leer ist
                            if (newSalesEntry.salesDistrict !== "") {
                                entryToUpdateIndex = existingData.salesEntries.findIndex(
                                    entry => entry.salesDistrict === newSalesEntry.salesDistrict
                                );
                            } else { // Wenn der neue Eintrag keinen salesDistrict hat, versuchen, einen vorhandenen leeren zu aktualisieren
                                entryToUpdateIndex = existingData.salesEntries.findIndex(
                                    entry => entry.salesDistrict === ""
                                );
                                // Wenn kein leerer salesDistrict-Eintrag, aber andere Eintr√§ge vorhanden sind, den ersten aktualisieren
                                if (entryToUpdateIndex === -1 && existingData.salesEntries.length > 0) {
                                    entryToUpdateIndex = 0;
                                }
                            }

                            if (entryToUpdateIndex !== -1) {
                                const originalId = existingData.salesEntries[entryToUpdateIndex].id;
                                existingData.salesEntries[entryToUpdateIndex] = { ...newSalesEntry, id: originalId };
                            } else {
                                existingData.salesEntries.push(newSalesEntry);
                            }

                            const colors = existingData.salesEntries.map(entry => entry.color);
                            existingData.displayColor = mixColors(colors);
                            existingData.numGeographicalParts = numGeographicalParts; // Auch f√ºr bestehende aktualisieren
                        } else {
                            // Neue Markierung
                            markedDistricts.set(combinedKey, {
                                layer: layer,
                                regionName: region.name,
                                regionType: region.type,
                                timestamp: Date.now(),
                                objid: region.objid,
                                salesEntries: [newSalesEntry],
                                displayColor: color,
                                numGeographicalParts: numGeographicalParts
                            });
                        }

                        layer.bringToFront();

                        if (layer._path) {
                            layer._path.setAttribute('aria-checked', 'true');
                            layer._path.setAttribute('aria-description',
                                `${region.name} (${region.type}) markiert mit Farbe ${getColorNameFromHex(color)}`);
                        }

                        matchCount++;
                    }
                });

                if (matchCount > 0) {
                    updateAllDisplays();

                    result = { success: true, count: matchCount };

                    if (!suppressMessage) {
                        const colorName = getColorNameFromHex(color);
                        const regTypeName = regionType || "alle Typen";

                        let message = `‚úÖ ${matchCount} Region${matchCount !== 1 ? 'en' : ''} f√ºr ${escapeHtml(searchTerm)} (${regTypeName}) wurden ${colorName} markiert!`;

                        if (salesGroup || salesDistrict || revenue) {
                            message += "\nVertriebsdaten gesetzt:";
                            if (salesGroup) message += ` Gruppe=${escapeHtml(salesGroup)}`;
                            if (salesDistrict) message += ` Bezirk=${escapeHtml(salesDistrict)}`;
                            if (revenue) message += ` Umsatz=${revenue}`;
                        }

                        appendMessageToChatLog(message, 'assistant');
                    }
                    return suppressMessage ? result : true;
                } else {
                    // Dieser Pfad ist mit der verbesserten findRegionInTable weniger wahrscheinlich, aber zur Sicherheit beibehalten
                    result = { success: false, count: 0 };
                    if (!suppressMessage) {
                        appendMessageToChatLog(
                            `‚ùå Die Region "${escapeHtml(searchTerm)}"${regionType ? ` (${regionType})` : ''} konnte nicht gefunden werden.`,
                            'assistant'
                        );
                    }
                    return suppressMessage ? result : false;
                }

            } catch (error) {
                console.error(`Fehler bei der Mehrfachmarkierung: ${error.message}`);
                result = { success: false, count: 0, error: error.message };
                if (!suppressMessage) {
                    appendMessageToChatLog(`‚ùå Ein interner Fehler ist aufgetreten: ${error.message}`, 'assistant');
                }
                return suppressMessage ? result : false;
            }
        }

        /* Regionsmarkierung Funktionen (√ºberarbeitet f√ºr Mehrfachmarkierung) */
        function highlightDistrictMulti(searchTerm, color = CONFIG.colors.default, additive = true, regionType = null) {
            // Diese Funktion ist jetzt ein Wrapper f√ºr markAllMatchingRegions
            return markAllMatchingRegions(searchTerm, regionType, color);
        }

        /* OPTIMIERT: Verbesserte Funktion zum Suchen einer Region in der Tabelle */
        function findRegionInTable(searchTerm, requestedType = null, findAll = false) {
            if (!searchTerm || typeof searchTerm !== 'string' || regionsTable.length === 0) return null;

            const normalizedSearch = normalizeRegionName(searchTerm);
            const normalizedRequestedType = requestedType ? normalizeRegionType(requestedType) : null;

            let bestMatches = [];

            // Stufe 1: Exakte Namens√ºbereinstimmung
            if (normalizedNameMap.has(normalizedSearch)) {
                const candidates = normalizedNameMap.get(normalizedSearch);
                if (normalizedRequestedType) {
                    const typeMatches = candidates.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                    if (typeMatches.length > 0) {
                        bestMatches = typeMatches;
                    } else {
                        // Wenn kein exakter Typ √ºbereinstimmt, aber der Name passt, alle Kandidaten f√ºr diesen Namen nehmen
                        bestMatches = candidates;
                    }
                } else {
                    // Kein angeforderter Typ, alle Kandidaten f√ºr diesen Namen nehmen
                    bestMatches = candidates;
                }
            }

            // Stufe 2: Partielle Namens√ºbereinstimmung (wenn noch keine exakte Namens√ºbereinstimmung gefunden wurde)
            if (bestMatches.length === 0) {
                for (const [normalizedNameInMap, regions] of normalizedNameMap.entries()) {
                    // Pr√ºfen, ob der Suchbegriff Teil des Regionsnamens ist oder umgekehrt
                    if (normalizedNameInMap.includes(normalizedSearch) || normalizedSearch.includes(normalizedNameInMap)) {
                        if (normalizedRequestedType) {
                            const typeMatches = regions.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                            if (typeMatches.length > 0) {
                                bestMatches = [...bestMatches, ...typeMatches];
                            } else {
                                // Wenn kein exakter Typ √ºbereinstimmt, aber der Name passt, trotzdem ber√ºcksichtigen
                                bestMatches = [...bestMatches, ...regions];
                            }
                        } else {
                            // Kein angeforderter Typ, alle Regionen hinzuf√ºgen, die dem partiellen Namen entsprechen
                            bestMatches = [...bestMatches, ...regions];
                        }
                    }
                }
            }

            // Stufe 3: Fuzzy-Matching (wenn noch keine √úbereinstimmungen gefunden wurden)
            if (bestMatches.length === 0) {
                let bestScore = 0;
                let fuzzyCandidates = [];
                for (const [normalizedNameInMap, regions] of normalizedNameMap.entries()) {
                    const score = calculateSimilarity(normalizedSearch, normalizedNameInMap);
                    if (score > bestScore && score > 0.6) { // Schwellenwert f√ºr Fuzzy-Match
                        bestScore = score;
                        fuzzyCandidates = regions; // Fuzzy-Kandidaten f√ºr einen besseren Score zur√ºcksetzen
                    } else if (score === bestScore && score > 0.6) {
                        fuzzyCandidates = [...fuzzyCandidates, ...regions]; // Hinzuf√ºgen, wenn gleicher Score
                    }
                }
                if (fuzzyCandidates.length > 0) {
                    // Typfilter auf Fuzzy-Matches anwenden, aber auch hier flexibel sein
                    if (normalizedRequestedType) {
                        const typeMatches = fuzzyCandidates.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                        if (typeMatches.length > 0) {
                            bestMatches = typeMatches;
                        } else {
                            bestMatches = fuzzyCandidates; // Fallback auf Namens√ºbereinstimmung, wenn der Typ nicht passt
                        }
                    } else {
                        bestMatches = fuzzyCandidates;
                    }
                }
            }

            // Endg√ºltige Filterung und R√ºckgabe
            if (bestMatches.length === 0) {
                return null; // Keine √úbereinstimmung gefunden
            }

            // Duplikate entfernen (kann bei partiellen √úbereinstimmungen vorkommen)
            const uniqueBestMatches = Array.from(new Set(bestMatches.map(r => r.objid)))
                                        .map(objid => bestMatches.find(r => r.objid === objid));

            if (findAll) {
                return uniqueBestMatches;
            } else {
                // Wenn mehrere √úbereinstimmungen, nach Typ priorisieren, falls m√∂glich, oder die erste zur√ºckgeben
                if (uniqueBestMatches.length > 1 && normalizedRequestedType) {
                    const exactTypeMatches = uniqueBestMatches.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                    if (exactTypeMatches.length > 0) {
                        return exactTypeMatches[0];
                    }
                }
                // Fallback auf die erste √úbereinstimmung, wenn keine spezifische Typ-Pr√§ferenz oder keine exakte Typ-√úbereinstimmung
                return uniqueBestMatches[0];
            }
        }

        /* OPTIMIERT: Verbesserte Funktion zur Ermittlung des Farbnamens aus Hex-Wert */
        function getColorNameFromHex(hexColor) {
            for (const [name, hex] of Object.entries(CONFIG.colors)) {
                if (hex === hexColor) {
                    // Nur deutsche Namen zur√ºckgeben (keine englischen Duplikate)
                    if (name === 'red') return 'Rot';
                    if (name === 'green') return 'Gr√ºn';
                    if (name === 'blue') return 'Blau';
                    if (name === 'yellow') return 'Gelb';
                    if (name === 'purple') return 'Lila';
                    if (name === 'teal') return 'T√ºrkis';
                    if (name === 'pink') return 'Rosa';
                    if (name === 'gray') return 'Grau';
                    if (name === 'brown') return 'Braun';
                    if (name === 'lightblue') return 'Hellblau';
                    if (name === 'darkgreen') return 'Dunkelgr√ºn';
                    if (name === 'lightgreen') return 'Hellgr√ºn';

                    // Erste Buchstabe gro√ü
                    return name.charAt(0).toUpperCase() + name.slice(1);
                }
            }
            return 'Eigene Farbe';
        }

        /* Berechnet √Ñhnlichkeit zwischen zwei Strings */
        function calculateSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;

            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;

            if (longer.length === 0) return 1.0;

            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / parseFloat(longer.length);
        }

        /* Implementierung der Levenshtein-Distanz f√ºr Fuzzy-Matching */
        function levenshteinDistance(str1, str2) {
            if (!str1 || !str2) return 0;

            const matrix = [];

            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // Substitution
                            matrix[i][j - 1] + 1,     // Insertion
                            matrix[i - 1][j] + 1      // Deletion
                        );
                    }
                }
            }

            return matrix[str2.length][str1.length];
        }

        /* OPTIMIERT: Verbesserte Entfernung von Markierungen */
        function removeMarking(regionName, regionType = null) {
            try {
                // Normalisiere den Regionsnamen f√ºr bessere Suche
                const normalizedName = normalizeRegionName(regionName);

                // OPTIMIERT: Verbesserte Regionstyp-Normalisierung
                const normalizedRequestedType = regionType ? normalizeRegionType(regionType) : null;

                let removed = 0;

                // Suche passende Markierungen
                for (const [key, data] of markedDistricts.entries()) {
                    // Normalisiere den gespeicherten Namen f√ºr Vergleich
                    const storedNormalized = normalizeRegionName(data.regionName);

                    // Pr√ºfe auf √úbereinstimmung mit normalisiertem Namen
                    if (storedNormalized === normalizedName ||
                        storedNormalized.includes(normalizedName) ||
                        normalizedName.includes(storedNormalized)) {

                        // √úberpr√ºfe Typ, wenn angegeben
                        let typeMatches = true;

                        if (regionType) {
                            const storedNormalizedType = normalizeRegionType(data.regionType);
                            typeMatches = storedNormalizedType === normalizedRequestedType;
                        }

                        if (typeMatches) {
                            // Entferne Markierung
                            geojsonLayer.resetStyle(data.layer);
                            markedDistricts.delete(key);

                            if (data.layer._path) {
                                data.layer._path.setAttribute('aria-checked', 'false');
                                data.layer._path.removeAttribute('aria-description');
                            }

                            removed++;
                        }
                    }
                }

                if (removed > 0) {
                    updateAllDisplays();
                    appendMessageToChatLog(`‚úÖ ${removed} Markierung${removed !== 1 ? 'en' : ''} f√ºr ${regionName}${regionType ? ` (${regionType})` : ''} entfernt.`, 'assistant');
                    return true;
                } else {
                    appendMessageToChatLog(`‚ùå Keine Markierungen f√ºr "${regionName}"${regionType ? ` (${regionType})` : ''} gefunden.`, 'assistant');
                    return false;
                }
            } catch (error) {
                console.error(`Fehler beim Entfernen der Markierung: ${error.message}`);
                appendMessageToChatLog(`‚ùå Fehler beim Entfernen: ${error.message}`, 'assistant');
                return false;
            }
        }

        /* L√∂scht alle Markierungen */
        function clearAllMarkings() {
            try {
                markedDistricts.forEach((data, key) => {
                    if (data.layer && geojsonLayer) {
                        geojsonLayer.resetStyle(data.layer);

                        if (data.layer._path) {
                            data.layer._path.setAttribute('aria-checked', 'false');
                            data.layer._path.removeAttribute('aria-description');
                        }
                    }
                });

                const totalMarked = markedDistricts.size;
                markedDistricts.clear();
                colorIndex = 0;
                // NEU: Vertriebsbezirksauswahl zur√ºcksetzen
                selectedSalesDistricts.clear();
                isFilterActive = false; // Filterzustand zur√ºcksetzen

                updateAllDisplays();

                appendMessageToChatLog(`üîÑ Alle ${totalMarked} Markierungen wurden gel√∂scht. Die Karte ist bereit f√ºr neue Markierungen.`, 'assistant');
            } catch (error) {
                console.error(`Fehler beim L√∂schen aller Markierungen: ${error.message}`);
                appendMessageToChatLog(`‚ùå Fehler beim L√∂schen: ${error.message}`, 'assistant');
            }
        }

        /* UI-Update Funktionen */
        function updateAllDisplays() {
            try {
                populateSalesGroupFilter(); // NEU: Aktualisiert das Vertriebsgruppen-Filter-Dropdown
                populateSalesDistrictCheckboxes(); // NEU: Aktualisiert die Vertriebsbezirks-Checkboxen
                updateSalesDistrictInfoboxes();
                applyRegionColoring(); // Ruft applyRegionColoring auf
                announceForScreenReader(`${markedDistricts.size} Regionen markiert.`);
            } catch (error) {
                console.error(`Fehler beim Aktualisieren der Anzeigen: ${error.message}`);
            }
        }

        /* NEU: Funktion zum Anwenden der Regionen-F√§rbung basierend auf dem Toggle-Status */
        function applyRegionColoring() {
            const selectedFilterGroup = DOM.salesGroupFilter.value; // Holt die ausgew√§hlte Gruppe

            geojsonLayer.eachLayer(layer => {
                const props = layer.feature.properties;
                const combinedKey = `${props.gen}__${props.bez}__${props.objid}`;
                const markingData = markedDistricts.get(combinedKey);

                if (markingData) {
                    // Filter nach Vertriebsgruppe
                    const passesGroupFilter = selectedFilterGroup === "" ||
                                              markingData.salesEntries.some(entry => entry.salesGroup === selectedFilterGroup);

                    // Filter nach ausgew√§hlten Vertriebsbezirken
                    // Wenn der Filter nicht aktiv ist, werden alle markierten Bezirke angezeigt.
                    // Wenn der Filter aktiv ist, werden nur die im selectedSalesDistricts Set enthaltenen Bezirke angezeigt.
                    const passesDistrictFilter = !isFilterActive ||
                                                 markingData.salesEntries.some(entry => selectedSalesDistricts.has(entry.salesDistrict));

                    const shouldDisplay = passesGroupFilter && passesDistrictFilter;

                    if (shouldDisplay) {
                        let targetColor;
                        if (showRevenueBasedColoring) {
                            targetColor = getRevenueBasedColor(markingData.salesEntries);
                            if (!targetColor) {
                                targetColor = markingData.displayColor;
                            }
                        } else {
                            targetColor = markingData.displayColor;
                        }

                        layer.setStyle({
                            fillColor: targetColor,
                            fillOpacity: 0.7,
                            color: targetColor,
                            weight: 3,
                            dashArray: '3, 3'
                        });
                        layer.bringToFront();
                    } else {
                        // Region ist markiert, aber durch den Filter ausgeblendet
                        geojsonLayer.resetStyle(layer); // Setzt auf Standard zur√ºck
                    }
                } else {
                    // Region ist nicht markiert, immer Standardstil
                    geojsonLayer.resetStyle(layer);
                }
            });
        }

        function announceForScreenReader(message) {
            const announcer = document.createElement('div');
            announcer.className = 'sr-only';
            announcer.setAttribute('role', 'status');
            announcer.setAttribute('aria-live', 'polite');
            announcer.textContent = message;

            document.body.appendChild(announcer);
            setTimeout(() => document.body.removeChild(announcer), 3000);
        }

        /* ENTFERNT: updateMarkedRegionsDisplay Funktion, da das Panel entfernt wurde */

        /* NEU: Verbesserte Funktion zum Anzeigen der Hover-Info mit allen Vertriebsbezirksnamen */
        function showHoverInfo(e, layer, markingData) {
            if (!hoverInfoPopup) return;

            const props = layer.feature.properties;
            const regionName = props.gen || "Unbekannt";
            const regionType = props.bez || "Unbekannt";

            let contentHTML = `
                <div class="hover-info-row">
                    <span class="hover-info-label">Name:</span>
                    <span class="hover-info-value">${escapeHtml(regionName)}</span>
                </div>
                <div class="hover-info-row">
                    <span class="hover-info-label">Typ:</span>
                    <span class="hover-info-value">${escapeHtml(regionType)}</span>
                </div>`;

            if (markingData) {
                let displayedColor = markingData.displayColor;
                if (showRevenueBasedColoring) {
                    const revenueColor = getRevenueBasedColor(markingData.salesEntries);
                    if (revenueColor) {
                        displayedColor = revenueColor;
                    }
                }

                contentHTML += `
                    <div class="hover-info-row">
                        <span class="hover-info-label">Farbe:</span>
                        <span class="hover-info-value">
                            <span style="display:inline-block; width:10px; height:10px; background-color:${displayedColor}; border-radius:50%; margin-right:4px;"></span>
                            ${getColorNameFromHex(displayedColor)}
                        </span>
                    </div>`;

                if (markingData.salesEntries && markingData.salesEntries.length > 0) {
                    // NEU: Der administrative Gesamtumsatz f√ºr diese Region ist im ersten Eintrag verf√ºgbar
                    // (da alle Eintr√§ge f√ºr dieselbe administrative Einheit denselben vollen Umsatz haben sollten)
                    const administrativeTotalRevenue = markingData.salesEntries[0].revenue || 0;

                    contentHTML += `<div style="margin-top: 5px; padding-top: 5px; border-top: 1px dotted #ccc;">`;
                    contentHTML += `
                        <div class="hover-info-row">
                            <span class="hover-info-label">Vertriebsbezirke:</span>
                            <span class="hover-info-value">${markingData.salesEntries.length}</span>
                        </div>`;

                    if (administrativeTotalRevenue > 0) {
                        contentHTML += `
                            <div class="hover-info-row">
                                <span class="hover-info-label">Gesamtumsatz (Admin.):</span>
                                <span class="hover-info-value">${new Intl.NumberFormat('de-DE').format(administrativeTotalRevenue)} ‚Ç¨</span>
                            </div>`;
                    }

                    contentHTML += `<div class="sales-districts-list">`;
                    markingData.salesEntries.forEach(entry => {
                        if (entry.salesDistrict) {
                            contentHTML += `
                                <div class="sales-district-item">
                                    <span style="display:inline-block; width:8px; height:8px; background-color:${entry.color}; border-radius:50%; margin-right:4px;"></span>
                                    ${escapeHtml(entry.salesDistrict)}
                                    (${escapeHtml(entry.salesGroup || "keine Gruppe")})
                                    ${entry.revenue ? ` - ${new Intl.NumberFormat('de-DE').format(entry.revenue)} ‚Ç¨` : ''}
                                </div>`;
                        }
                    });
                    contentHTML += `</div>`;
                    contentHTML += `</div>`;
                } else {
                    contentHTML += `
                        <div style="margin-top: 5px; padding-top: 5px; border-top: 1px dotted #ccc; text-align:center; font-style:italic;">
                            Keine Vertriebsdaten vorhanden
                        </div>`;
                }

                hoverInfoPopup.querySelector('.hover-info-footer').textContent = 'Klick zum Bearbeiten';
            } else {
                contentHTML += `
                    <div class="hover-info-row">
                        <span class="hover-info-label">Hover-Farbe:</span>
                        <span class="hover-info-value">
                            <span style="display:inline-block; width:10px; height:10px; background-color:${CONFIG.mapStyles.default.fillColor}; border-radius:50%; margin-right:4px;"></span>
                            ${getColorNameFromHex(CONFIG.mapStyles.default.fillColor)}
                        </span>
                    </div>`;
                hoverInfoPopup.querySelector('.hover-info-footer').textContent = 'Klick zum Markieren und Bearbeiten';
            }

            const hoverInfoContent = document.getElementById('hoverInfoContent');
            if (hoverInfoContent) {
                hoverInfoContent.innerHTML = contentHTML;
            }

            const containerPoint = e.containerPoint;
            const x = containerPoint.x + 15;
            const y = containerPoint.y - hoverInfoPopup.offsetHeight / 2;

            hoverInfoPopup.style.left = x + 'px';
            hoverInfoPopup.style.top = y + 'px';

            hoverInfoPopup.classList.add('visible');
        }

        /* NEU: Initialisierung des Hover-Info-Popups */
        function initializeHoverInfoPopup() {
            hoverInfoPopup = document.getElementById('hoverInfoPopup');
            if (!hoverInfoPopup) {
                hoverInfoPopup = document.createElement('div');
                hoverInfoPopup.id = 'hoverInfoPopup';
                hoverInfoPopup.className = 'hover-info-popup';
                hoverInfoPopup.setAttribute('role', 'tooltip');
                hoverInfoPopup.innerHTML = `
                    <div class="hover-info-title">Regionsinformation</div>
                    <div class="hover-info-content" id="hoverInfoContent"></div>
                    <div class="hover-info-footer">Klick zum Bearbeiten</div>
                `;
                document.body.appendChild(hoverInfoPopup);
            }
        }

        /* NEU: Entfernt Hover-Effekt und Info-Popup */
        function resetHighlightMulti(e) {
            const layer = e.target;
            if (!layer || !layer.feature || !layer.feature.properties) return;

            // Wenn der Layer nicht mehr gehovered wird, setzen wir currentHoveredLayer zur√ºck
            if (currentHoveredLayer === layer) {
                currentHoveredLayer = null;
            }

            // Setze Stil immer auf den durch applyRegionColoring bestimmten Zustand zur√ºck
            applyRegionColoring();

            // Verstecke das Popup
            if (hoverInfoPopup) {
                hoverInfoPopup.classList.remove('visible');
            }
        }

        /* NEU: Behandelt Klicks auf Regionen - √ñffnet direkt den Bearbeitungsdialog */
        function toggleDistrictMarking(e) {
            try {
                const layer = e.target;
                if (!layer || !layer.feature || !layer.feature.properties) return;

                // Bestimme Eigenschaften des Features
                const gen = layer.feature.properties.gen;
                const bez = layer.feature.properties.bez || 'Unbekannt';
                const objid = layer.feature.properties.objid;

                // Erstelle eindeutigen Schl√ºssel mit objID
                let combinedKey = `${gen}__${bez}__${objid}`;

                // Pr√ºfe, ob diese exakte Region bereits markiert ist
                let isMarked = markedDistricts.has(combinedKey);
                let existingMarking = null;

                // Alternative: Pr√ºfe, ob irgendeine Markierung diese Layer-Referenz verwendet
                if (!isMarked) {
                    markedDistricts.forEach((data, key) => {
                        if (data.layer === layer) {
                            isMarked = true;
                            existingMarking = data;
                            combinedKey = key; // Verwende den vorhandenen Schl√ºssel
                        }
                    });
                } else {
                    existingMarking = markedDistricts.get(combinedKey);
                }

                // NEU: Wenn noch nicht markiert, markiere die Region mit Standardfarbe
                if (!isMarked) {
                    const color = CONFIG.defaultColors[colorIndex % CONFIG.defaultColors.length];
                    colorIndex++;

                    // Neue Markierung hinzuf√ºgen mit salesEntries-Array
                    markedDistricts.set(combinedKey, {
                        layer: layer,
                        regionName: gen,
                        regionType: bez,
                        timestamp: Date.now(),
                        objid: objid,
                        // Leere Vertriebsdaten-Array mit eindeutiger ID
                        salesEntries: [
                            {
                                id: generateUniqueId(),
                                color: color,
                                salesGroup: "",
                                salesDistrict: "",
                                revenue: 0
                            }
                        ],
                        displayColor: color
                    });

                    // Stil wird durch applyRegionColoring gesetzt
                    // layer.setStyle({
                    //     fillColor: color, fillOpacity: 0.7, color: color, weight: 3, dashArray: '3, 3'
                    // });
                    layer.bringToFront();

                    if (layer._path) {
                        layer._path.setAttribute('aria-checked', 'true');
                        layer._path.setAttribute('aria-description',
                            `${gen} (${bez}) markiert mit Farbe ${getColorNameFromHex(color)}`);
                    }

                    // Display aktualisieren
                    updateAllDisplays();
                }

                // NEU: √ñffne direkt den Bearbeitungsdialog f√ºr die Region
                openEditDialog(combinedKey);

            } catch (error) {
                console.error(`Fehler bei Karteninteraktion: ${error.message}`);
            }
        }

        /* NEU: Hover-Effekt f√ºr Regionen mit Daten-Popup */
        function highlightFeatureMulti(e) {
            const layer = e.target;
            if (!layer || !layer.feature || !layer.feature.properties) return;

            // Speichern des aktuell gehoverden Layers
            currentHoveredLayer = layer;

            // Pr√ºfen ob Region bereits markiert ist
            // Suchen nach einer Markierung mit dieser Layer-Referenz
            let isMarked = false;
            let markingData = null;

            markedDistricts.forEach(data => {
                if (data.layer === layer) {
                    isMarked = true;
                    markingData = data;
                }
            });

            if (!isMarked) {
                geojsonLayer.resetStyle(layer); // Setzt auf Standard zur√ºck
                layer.setStyle(CONFIG.mapStyles.default); // Wendet Hover-Stil an
            }
            layer.bringToFront();

            // NEU: Hover-Info anzeigen
            showHoverInfo(e, layer, markingData);
        }

        /* OPTIMIERT: Initialisiere Farbpicker im Dialog mit Farbl√∂schungsoption */
        function initializeColorPicker() {
            const colorPickerContainer = DOM.colorPicker; // OPTIMIERT: DOM-Referenz nutzen
            if (!colorPickerContainer) return;

            // Entferne bestehende Farb-Optionen aber behalte die L√∂schoption
            const removeColorOption = document.getElementById('removeColorOption');
            colorPickerContainer.innerHTML = '';

            // F√ºge zuerst die L√∂schoption wieder hinzu
            if (removeColorOption) {
                colorPickerContainer.appendChild(removeColorOption);
            } else {
                // Falls nicht vorhanden, erstelle die Farbl√∂schungsoption
                const removeOption = document.createElement('div');
                removeOption.id = 'removeColorOption';
                removeOption.className = 'color-remove-option';
                removeOption.title = 'Farbe l√∂schen';
                removeOption.setAttribute('role', 'radio');
                removeOption.setAttribute('aria-label', 'Farbe l√∂schen');
                removeOption.setAttribute('aria-checked', 'false');
                removeOption.tabIndex = 0;

                // OPTIMIERT: Verbesserte Zug√§nglichkeit mit Tastaturunterst√ºtzung
                removeOption.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.click();
                    }
                });

                removeOption.addEventListener('click', function() { // OPTIMIERT: Event-Listener direkt registrieren
                    // Entferne 'selected' von allen Optionen
                    document.querySelectorAll('.color-option, .color-remove-option').forEach(option => {
                        option.classList.remove('selected');
                        option.setAttribute('aria-checked', 'false');
                    });

                    // Markiere die L√∂schoption als ausgew√§hlt
                    this.classList.add('selected');
                    this.setAttribute('aria-checked', 'true');

                    // Setze den Farbwert auf "" (keine Farbe)
                    DOM.selectedColor.value = ""; // OPTIMIERT: DOM-Referenz nutzen
                });

                colorPickerContainer.appendChild(removeOption);
            }

            // F√ºge alle Farben als Optionen hinzu
            for (const [name, hex] of Object.entries(CONFIG.colors)) {
                // √úberspringe englische Duplikate
                if (['red', 'green', 'blue', 'yellow', 'purple', 'teal', 'pink', 'gray', 'brown', 'lightblue', 'darkgreen', 'lightgreen'].includes(name)) {
                    continue;
                }

                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = hex;
                colorOption.setAttribute('data-color', hex);
                colorOption.setAttribute('data-name', name);
                colorOption.title = name.charAt(0).toUpperCase() + name.slice(1);
                colorOption.setAttribute('role', 'radio');
                colorOption.setAttribute('aria-label', name);
                colorOption.setAttribute('aria-checked', 'false');
                colorOption.tabIndex = 0;

                // OPTIMIERT: Verbesserte Zug√§nglichkeit mit Tastaturunterst√ºtzung
                colorOption.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.click();
                    }
                });

                colorOption.addEventListener('click', function() { // OPTIMIERT: Event-Listener direkt registrieren
                    // Entferne 'selected' von allen Optionen
                    document.querySelectorAll('.color-option, .color-remove-option').forEach(option => {
                        option.classList.remove('selected');
                        option.setAttribute('aria-checked', 'false');
                    });

                    // Markiere die ausgew√§hlte Option
                    this.classList.add('selected');
                    this.setAttribute('aria-checked', 'true');

                    // Speichere die ausgew√§hlte Farbe
                    DOM.selectedColor.value = this.getAttribute('data-color'); // OPTIMIERT: DOM-Referenz nutzen
                });

                colorPickerContainer.appendChild(colorOption);
            }
        }

        /* OPTIMIERT: Dialog zum Bearbeiten der Vertriebsdaten und Farbe mit mehreren Eintr√§gen */
        function openEditDialog(regionKey) {
            try {
                const data = markedDistricts.get(regionKey);
                if (!data) return;

                // Setze den regionKey f√ºr sp√§teren Zugriff
                DOM.editingRegionKey.value = regionKey; // OPTIMIERT: DOM-Referenz nutzen

                // OPTIMIERT: Dialogtitel mit Regionsname
                DOM.editDialogTitle.textContent = `Region bearbeiten: ${data.regionName}`; // OPTIMIERT: DOM-Referenz nutzen

                // Zeige die Liste der vorhandenen Vertriebseintr√§ge
                DOM.salesEntriesList.innerHTML = ''; // OPTIMIERT: DOM-Referenz nutzen

                if (data.salesEntries && data.salesEntries.length > 0) {
                    data.salesEntries.forEach(entry => {
                        const entryDiv = document.createElement('div');
                        entryDiv.className = 'sales-entry-item';
                        entryDiv.setAttribute('role', 'listitem');
                        entryDiv.innerHTML = `
                            <div class="sales-entry-header">
                                <div class="entry-color-indicator" style="background-color: ${entry.color}"
                                     aria-label="Farbe: ${getColorNameFromHex(entry.color)}"></div>
                                <div class="entry-title">
                                    ${entry.salesDistrict || 'Kein Vertriebsbezirk'}
                                    (${entry.salesGroup || 'Keine Gruppe'})
                                </div>
                                <div class="sales-entry-details">
                                    <div>Umsatz: ${new Intl.NumberFormat('de-DE').format(entry.revenue || 0)} ‚Ç¨</div>
                                </div>
                                <div class="entry-actions">
                                    <button class="btn-edit-entry" data-entry-id="${entry.id}"
                                            aria-label="Eintrag bearbeiten">Bearbeiten</button>
                                    <button class="btn-delete-entry" data-entry-id="${entry.id}"
                                            aria-label="Eintrag l√∂schen">L√∂schen</button>
                                </div>
                            </div>
                        `;
                        DOM.salesEntriesList.appendChild(entryDiv); // OPTIMIERT: DOM-Referenz nutzen
                    });
                } else {
                    DOM.salesEntriesList.innerHTML = '<div class="no-entries-message" role="status">Keine Vertriebsdaten vorhanden</div>'; // OPTIMIERT: DOM-Referenz nutzen
                }

                // Zeige den Dialog und die Liste der Eintr√§ge
                DOM.salesEntriesList.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.addEntryForm.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.dialogOverlay.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.editSalesDialog.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden

                // Setze Fokus auf ersten Button f√ºr bessere Tastaturnavigation
                setTimeout(() => {
                    const firstButton = DOM.editSalesDialog.querySelector('button');
                    if (firstButton) firstButton.focus();
                }, 100);
            } catch (error) {
                console.error(`Fehler beim √ñffnen des Bearbeitungsdialogs: ${error.message}`);
            }
        }

        function closeEditDialog() {
            DOM.dialogOverlay.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.editSalesDialog.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.editingRegionKey.value = ''; // OPTIMIERT: DOM-Referenz nutzen
            DOM.editingEntryId.value = ''; // OPTIMIERT: DOM-Referenz nutzen
        }

        /* NEU: Funktion zum Bearbeiten eines bestehenden Vertriebseintrags */
        function editEntry(entryId) {
            const regionKey = DOM.editingRegionKey.value; // OPTIMIERT: DOM-Referenz nutzen
            const data = markedDistricts.get(regionKey);
            if (!data || !data.salesEntries) return;

            const entry = data.salesEntries.find(e => e.id === entryId);
            if (!entry) return;

            // Initialisiere den Farbpicker
            initializeColorPicker();

            // Setze die Werte im Formular
            DOM.salesGroupInput.value = entry.salesGroup || ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.salesDistrictInput.value = entry.salesDistrict || ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.revenueInput.value = entry.revenue || ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.editingEntryId.value = entryId; // OPTIMIERT: DOM-Referenz nutzen
            DOM.selectedColor.value = entry.color; // OPTIMIERT: DOM-Referenz nutzen

            // Markiere die ausgew√§hlte Farbe im Farbpicker
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
                option.setAttribute('aria-checked', 'false');
                if (option.getAttribute('data-color') === entry.color) {
                    option.classList.add('selected');
                    option.setAttribute('aria-checked', 'true');
                }
            });

            // Deaktiviere die Farbl√∂schung
            const removeColorOption = document.getElementById('removeColorOption');
            if (removeColorOption) {
                removeColorOption.classList.remove('selected');
                removeColorOption.setAttribute('aria-checked', 'false');
            }

            // Zeige das Formular an
            DOM.salesEntriesList.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.addEntryForm.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden

            // Setze Fokus auf erstes Eingabefeld
            setTimeout(() => DOM.salesGroupInput.focus(), 100); // OPTIMIERT: DOM-Referenz nutzen
        }

        /* NEU: Funktion zum Anzeigen des Formulars f√ºr einen neuen Vertriebseintrag */
        function showAddEntryForm() {
            // Initialisiere den Farbpicker
            initializeColorPicker();

            // Leere das Formular
            DOM.salesGroupInput.value = ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.salesDistrictInput.value = ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.revenueInput.value = ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.editingEntryId.value = ""; // Kein Entry-ID bedeutet neuer Eintrag // OPTIMIERT: DOM-Referenz nutzen

            // W√§hle eine Standardfarbe
            const defaultColor = CONFIG.colors.default;
            DOM.selectedColor.value = defaultColor; // OPTIMIERT: DOM-Referenz nutzen

            // Markiere die Standardfarbe im Farbpicker
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
                option.setAttribute('aria-checked', 'false');
                if (option.getAttribute('data-color') === defaultColor) {
                    option.classList.add('selected');
                    option.setAttribute('aria-checked', 'true');
                }
            });

            // Deaktiviere die Farbl√∂schung
            const removeColorOption = document.getElementById('removeColorOption');
            if (removeColorOption) {
                removeColorOption.classList.remove('selected');
                removeColorOption.setAttribute('aria-checked', 'false');
            }

            // Zeige das Formular an
            DOM.salesEntriesList.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.addEntryForm.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden

            // Setze den Fokus auf das erste Feld
            setTimeout(() => DOM.salesGroupInput.focus(), 100); // OPTIMIERT: DOM-Referenz nutzen
        }

        /* NEU: Funktion zum Abbrechen der Bearbeitung/Hinzuf√ºgung */
        function cancelAddEntry() {
            // Zur√ºck zur √úbersicht der Eintr√§ge
            DOM.addEntryForm.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.salesEntriesList.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
        }
        /* OPTIMIERT: Speichern eines neuen oder bearbeiteten Vertriebseintrags */
        DOM.addEntryForm.addEventListener('submit', function(e) { // OPTIMIERT: Event-Listener direkt registrieren
            e.preventDefault();

            const regionKey = DOM.editingRegionKey.value; // OPTIMIERT: DOM-Referenz nutzen
            if (!regionKey || !markedDistricts.has(regionKey)) {
                closeEditDialog();
                return;
            }

            const data = markedDistricts.get(regionKey);
            const entryId = DOM.editingEntryId.value; // This is the ID if we are editing an existing entry // OPTIMIERT: DOM-Referenz nutzen
            const newColor = DOM.selectedColor.value || CONFIG.colors.default; // OPTIMIERT: DOM-Referenz nutzen

            // Get the form data, remove spaces for internal storage
            const formData = {
                salesGroup: DOM.salesGroupInput.value.trim() || "", // Removed regex check // OPTIMIERT: DOM-Referenz nutzen
                salesDistrict: DOM.salesDistrictInput.value.trim() || "", // Removed regex check // OPTIMIERT: DOM-Referenz nutzen
                revenue: DOM.revenueInput.value ? parseInt(DOM.revenueInput.value) : 0, // OPTIMIERT: DOM-Referenz nutzen
                color: newColor
            };

            let entryUpdated = false;

            // If we are editing an existing entry (entryId is present)
            if (entryId) {
                const entryIndex = data.salesEntries.findIndex(e => e.id === entryId);
                if (entryIndex >= 0) {
                    data.salesEntries[entryIndex] = {
                        ...data.salesEntries[entryIndex], // Keep original ID
                        ...formData
                    };
                    entryUpdated = true;
                }
            }

            // If we are adding a new entry (entryId is NOT present)
            else {
                if (!data.salesEntries) data.salesEntries = [];

                // Check if an entry with the same salesDistrict already exists for this region
                const existingEntryIndex = data.salesEntries.findIndex(e => e.salesDistrict === formData.salesDistrict);

                if (existingEntryIndex >= 0) {
                    // Overwrite the existing entry with the same salesDistrict
                    data.salesEntries[existingEntryIndex] = {
                        ...data.salesEntries[existingEntryIndex], // Keep original ID
                        ...formData
                    };
                    entryUpdated = true;
                } else {
                    // Add a new entry with a unique ID
                    data.salesEntries.push({
                        id: generateUniqueId(),
                        ...formData
                    });
                    entryUpdated = true;
                }
            }

            // Die Warnung, wenn nichts ver√§ndert wurde, kommt aktuell nicht,
            // weil 'entryUpdated' fast immer auf 'true' gesetzt wird, sobald das Formular bearbeitet wird.
            // Wenn Sie m√∂chten, dass der Dialog nur bei tats√§chlicher √Ñnderung geschlossen wird,
            // m√ºsste die Logik hier komplexer sein (Vergleich der alten und neuen Daten).
            // F√ºrs Erste lassen wir es so, damit der Dialog immer schlie√üt.
            if (!entryUpdated) {
                console.warn("Entry was neither updated nor added. Check logic.");
                closeEditDialog();
                return;
            }

            // Aktualisiere die Anzeigefarbe als Mischung aller Eintragsfarben
            const colors = data.salesEntries.map(entry => entry.color);
            data.displayColor = mixColors(colors);

            // Aktualisiere die Kartenanzeige (wird von updateAllDisplays √ºbernommen)
            // data.layer.setStyle({
            //     fillColor: data.displayColor,
            //     color: data.displayColor,
            //     fillOpacity: 0.7,
            //     weight: 3,
            //     dashArray: '3, 3'
            // });
            data.layer.bringToFront();

            if (data.layer._path) {
                // KORREKTUR: 'layer' zu 'data.layer' ge√§ndert
                data.layer._path.setAttribute('aria-checked', 'true'); // Sicherstellen, dass es als markiert gilt
                data.layer._path.setAttribute('aria-description',
                    `${data.regionName} (${data.regionType}) markiert mit gemischter Farbe ${getColorNameFromHex(data.displayColor)}`);
            }

            // Aktualisiere die Anzeigen
            updateAllDisplays();

            // Diese Zeilen sind jetzt auskommentiert, da der gesamte Dialog geschlossen wird
            // DOM.addEntryForm.classList.add('hidden');
            // DOM.salesEntriesList.classList.remove('hidden');
            // openEditDialog(regionKey);

            // Hier wird der gesamte "Region bearbeiten"-Dialog geschlossen
            closeEditDialog();

        });

        /* NEU: Funktion zum L√∂schen eines Vertriebseintrags */
        function deleteEntry(entryId) {
            if (!confirm("M√∂chten Sie diesen Vertriebsbezirk wirklich l√∂schen?")) return;

            const regionKey = DOM.editingRegionKey.value; // OPTIMIERT: DOM-Referenz nutzen
            const data = markedDistricts.get(regionKey);
            if (!data || !data.salesEntries) return;

            // Entferne den Eintrag aus dem Array
            const entryIndex = data.salesEntries.findIndex(e => e.id === entryId);
            if (entryIndex >= 0) {
                data.salesEntries.splice(entryIndex, 1);

                // Wenn keine Eintr√§ge mehr vorhanden sind, entferne die Markierung
                if (data.salesEntries.length === 0) {
                    geojsonLayer.resetStyle(data.layer);
                    markedDistricts.delete(regionKey);

                    // Schlie√üe den Dialog
                    closeEditDialog();
                }

                // Sonst aktualisiere die Anzeigefarbe
                else {
                    const colors = data.salesEntries.map(entry => entry.color);
                    data.displayColor = mixColors(colors);

                    // Stil wird durch applyRegionColoring gesetzt
                    // data.layer.setStyle({
                    //     fillColor: data.displayColor,
                    //     color: data.displayColor,
                    //     fillOpacity: 0.7,
                    //     weight: 3,
                    //     dashArray: '3, 3'
                    // });

                    // Aktualisiere die Liste der Eintr√§ge
                    openEditDialog(regionKey);
                }

                // Aktualisiere die Anzeigen
                updateAllDisplays();
            }
        }

        /* OPTIMIERT: Verbesserte Event-Listener f√ºr Regionen mit ARIA-Support */
        function onEachFeature(feature, layer) {
            try {
                if (feature.properties) {
                    const props = feature.properties;

                    if (props.gen && typeof props.gen === 'string' && props.gen.trim().length > 0) {
                        const genName = props.gen.trim();
                        const bezType = props.bez || "Unbekannt";
                        // KORREKTUR: objid ist direkt in props, nicht props.properties
                        const objid = props.objid;

                        // 1. Erzeuge einen kombinierten Schl√ºssel aus Name und Typ
                        const combinedKey = `${genName}__${bezType}__${objid}`; // objid in Key f√ºr Eindeutigkeit

                        // 2. Speichere Layer-Info mit dem kombinierten Schl√ºssel
                        districtData[combinedKey] = {
                            layer: layer,
                            feature: feature,
                            properties: props,
                            regionName: genName,
                            regionType: bezType,
                            objid: objid
                        };

                        // 3. F√ºge zum Namensindex hinzu f√ºr schnellere Suche
                        if (!nameToKeysMap.has(genName)) {
                            nameToKeysMap.set(genName, []);
                        }
                        nameToKeysMap.get(genName).push(combinedKey);

                        // 4. Speichere Layer-Referenz nach objid
                        if (objid) {
                            objIdToLayerMap.set(objid, layer);
                        }
                    }
                }

                // Event-listener hinzuf√ºgen
                layer.on({
                    mouseover: (e) => highlightFeatureMulti(e),
                    mouseout: (e) => resetHighlightMulti(e),
                    click: (e) => toggleDistrictMarking(e)
                });

                // ARIA-Attribute f√ºr bessere Zug√§nglichkeit
                if (layer._path && feature.properties && feature.properties.gen) {
                    const regionType = feature.properties.bez || "Unbekannt";
                    layer._path.setAttribute('role', 'button');
                    layer._path.setAttribute('aria-label', `${regionType} ${feature.properties.gen}`);
                    layer._path.setAttribute('aria-checked', 'false');
                    layer._path.setAttribute('tabindex', '0');

                    // Tastatur-Interaktion
                    layer._path.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter' || e.key === ' ') {
                            toggleDistrictMarking({ target: layer });
                            e.preventDefault();
                        }
                    });
                }
            } catch (error) {
                console.error(`Fehler bei Feature-Registrierung: ${error.message}`);
            }
        }

        /* Sendet vordefinierten Prompt */
        function sendPrompt(promptText) {
            if (!promptText) return;

            DOM.questionInput.value = promptText;
            sendMessage();
        }

        /* F√ºgt Nachricht zum Chat-Verlauf hinzu */
        function appendMessageToChatLog(text, sender, action = null) {
            try {
                if (!text || !sender) return;

                const bubble = document.createElement('div');
                bubble.classList.add('bubble', sender);

                const senderLabel = sender === 'user' ? 'Sie' : 'KI-Assistent';
                let content = `<strong>${senderLabel}:</strong><br>${text}`;

                if (action) {
                    content += `<div class="assistant-action-buttons">`;
                    if (action.type === 'confirm') {
                        content += `<button onclick="${action.onConfirm}" aria-label="Best√§tigen">Ja, ausf√ºhren</button>`;
                        content += `<button onclick="${action.onCancel || ''}" aria-label="Abbrechen">Abbrechen</button>`;
                    }
                    content += `</div>`;
                }

                bubble.innerHTML = content;

                if (sender === 'assistant') {
                    bubble.setAttribute('role', 'region');
                    bubble.setAttribute('aria-label', 'Antwort des KI-Assistenten');
                } else {
                    bubble.setAttribute('aria-label', 'Ihre Nachricht');
                }

                DOM.chatlog.appendChild(bubble); // OPTIMIERT: DOM-Referenz nutzen
                DOM.chatlog.scrollTop = DOM.chatlog.scrollHeight; // OPTIMIERT: DOM-Referenz nutzen

                if (sender === 'assistant') {
                    const announcement = document.createElement('div');
                    announcement.setAttribute('role', 'status');
                    announcement.setAttribute('aria-live', 'polite');
                    announcement.className = 'sr-only';
                    announcement.textContent = 'Neue Antwort erhalten';
                    document.body.appendChild(announcement);

                    setTimeout(() => {
                        if (document.body.contains(announcement)) {
                            document.body.removeChild(announcement);
                        }
                    }, 3000);
                }
            } catch (error) {
                console.error(`Fehler beim Hinzuf√ºgen zum Chat: ${error.message}`);
            }
        }

        /* Zeigt Tipp-Indikator an */
        function showTypingIndicator() {
            removeTypingIndicator();

            const bubble = document.createElement('div');
            bubble.classList.add('bubble', 'assistant', 'typing-indicator');
            bubble.setAttribute('aria-label', 'KI denkt nach');
            bubble.setAttribute('role', 'status');

            bubble.innerHTML = `<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>`;
            DOM.chatlog.appendChild(bubble); // OPTIMIERT: DOM-Referenz nutzen
            DOM.chatlog.scrollTop = DOM.chatlog.scrollHeight; // OPTIMIERT: DOM-Referenz nutzen
        }

        /* Entfernt Tipp-Indikator */
        function removeTypingIndicator() {
            const indicator = document.querySelector('.typing-indicator');
            if (indicator) indicator.remove();
        }

        /* Mobile-Responsive Funktionen */
        function setupMobileResponsive() {
            function checkMobileLayout() {
                if (window.innerWidth <= 1024) {
                    DOM.mobileSidebarToggle.style.display = 'flex'; // Ensure it's visible
                    // WICHTIGE √ÑNDERUNG: Die 'active'-Klasse sollte NICHT hier entfernt werden.
                    // Sie sollte nur durch die explizite Aktion des Benutzers (Klick auf den Toggle-Button) umgeschaltet werden.
                    // Wenn die Sidebar bereits aktiv ist, soll sie aktiv bleiben.
                    // Wenn sie nicht aktiv ist, sorgt ihr Standard-CSS (transform: translateX(100%)) daf√ºr, dass sie ausgeblendet bleibt.
                } else {
                    DOM.mobileSidebarToggle.style.display = 'none'; // Hide on larger screens
                    // Auf gr√∂√üeren Bildschirmen stellen Sie sicher, dass die 'active'-Klasse entfernt wird,
                    // damit die Sidebar zu ihrer standardm√§√üigen Desktop-Positionierung (die sichtbar ist) zur√ºckkehrt.
                    DOM.sidebar.classList.remove('active'); // OPTIMIERT: CSS-Klasse verwenden
                }
            }

            // OPTIMIERT: Event-Listener direkt registrieren
            DOM.mobileSidebarToggle.addEventListener('click', function() {
                DOM.sidebar.classList.toggle('active'); // OPTIMIERT: CSS-Klasse verwenden

                const isOpen = DOM.sidebar.classList.contains('active'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.mobileSidebarToggle.setAttribute('aria-label',
                    isOpen ? 'Schlie√üe Steuerung' : '√ñffne Steuerung');
                DOM.mobileSidebarToggle.innerHTML = isOpen ?
                    '<span aria-hidden="true">√ó</span>' :
                    '<span aria-hidden="true">‚â°</span>';
            });

            // Initial call to set up the correct state
            checkMobileLayout();
            // Add event listener for window resize
            window.addEventListener('resize', checkMobileLayout);
        }

        /* √úBERARBEITET: Speichern und Laden von Markierungen als Dateien mit Vertriebsdaten und Farben */
        function saveMarkings() {
            try {
                if (markedDistricts.size === 0 && selectedSalesDistricts.size === 0 && !isFilterActive) {
                    appendMessageToChatLog("‚ùå Es gibt keine Daten zum Speichern.", 'assistant');
                    return;
                }

                // Konvertiere die Map in ein serialisierbares Format
                const markingsToSave = [];

                markedDistricts.forEach((data, key) => {
                    markingsToSave.push({
                        key: key,
                        regionName: data.regionName,
                        regionType: data.regionType,
                        objid: data.objid,
                        displayColor: data.displayColor,
                        salesEntries: data.salesEntries || []
                    });
                });

                // Erstelle ein Exportobjekt mit Metadaten
                const exportData = {
                    version: "2.2", // Version aktualisiert f√ºr isFilterActive
                    timestamp: Date.now(),
                    colorIndex: colorIndex,
                    markings: markingsToSave,
                    selectedSalesDistricts: Array.from(selectedSalesDistricts), // NEU: Speichere ausgew√§hlte Vertriebsbezirke
                    isFilterActive: isFilterActive // NEU: Speichere den Filterzustand
                };

                // Konvertiere in JSON
                const jsonData = JSON.stringify(exportData, null, 2);

                // Erstelle eine tempor√§re URL f√ºr den Download
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Erstelle einen Download-Link und klicke darauf
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = `multi-landkreis-markierungen-${new Date().toISOString().slice(0,10)}.json`;
                downloadLink.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                document.body.appendChild(downloadLink);
                downloadLink.click();

                // Bereinige
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                    document.body.removeChild(downloadLink);
                }, 100);

                appendMessageToChatLog(
                    `üíæ ${markingsToSave.length} Datens√§tze wurden als Datei gespeichert!`,
                    'assistant'
                );
            } catch (error) {
                console.error(`Fehler beim Speichern der Daten: ${error.message}`);
                appendMessageToChatLog(`‚ùå Fehler beim Speichern: ${error.message}`, 'assistant');
            }
        }

        /* OPTIMIERT: Laden von Markierungen mit Vertriebsdaten und Farben */
        function loadMarkings() {
            try {
                // Erstelle einen unsichtbaren Datei-Input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                fileInput.setAttribute('aria-label', 'Datei zum Laden von Markierungen ausw√§hlen');
                document.body.appendChild(fileInput);

                // Wenn eine Datei ausgew√§hlt wurde
                fileInput.onchange = function(e) {
                    const file = e.target.files[0];
                    if (!file) {
                        document.body.removeChild(fileInput);
                        return;
                    }

                    const reader = new FileReader();

                    reader.onload = function(event) {
                        try {
                            const content = event.target.result;
                            const importData = JSON.parse(content);

                            // Pr√ºfe auf g√ºltiges Format
                            if (!importData.markings || !Array.isArray(importData.markings)) {
                                throw new Error("Die Datei enth√§lt keine g√ºltigen Markierungsdaten");
                            }

                            // L√∂sche vorhandene Markierungen (setzt auch selectedSalesDistricts und isFilterActive zur√ºck)
                            clearAllMarkings();

                            // Wende gespeicherte Markierungen an
                            let loadedCount = 0;
                            let failedCount = 0;

                            importData.markings.forEach(marking => {
                                // Finde die entsprechende Region
                                if (marking.objid) {
                                    const layer = objIdToLayerMap.get(marking.objid);

                                    if (layer) {
                                        // √úberpr√ºfen auf das neue Format mit salesEntries
                                        const salesEntries = marking.salesEntries || [
                                            {
                                                id: generateUniqueId(),
                                                color: marking.color || CONFIG.colors.default,
                                                salesGroup: marking.salesGroup || "",
                                                salesDistrict: marking.salesDistrict || "",
                                                revenue: marking.revenue || 0
                                            }
                                        ];

                                        // Stelle sicher, dass jeder Eintrag eine ID hat
                                        salesEntries.forEach(entry => {
                                            if (!entry.id) entry.id = generateUniqueId();
                                        });

                                        // Stil setzen mit der gespeicherten Anzeigefarbe oder berechneten Mischfarbe
                                        const displayColor = marking.displayColor || mixColors(salesEntries.map(e => e.color));

                                        // layer.setStyle({
                                        //     fillColor: displayColor,
                                        //     fillOpacity: 0.7,
                                        //     color: displayColor,
                                        //     weight: 3,
                                        //     dashArray: '3, 3'
                                        // });
                                        layer.bringToFront();

                                        // Markierung speichern
                                        markedDistricts.set(marking.key, {
                                            layer: layer,
                                            regionName: marking.regionName,
                                            regionType: marking.regionType,
                                            timestamp: Date.now(),
                                            objid: marking.objid,
                                            salesEntries: salesEntries,
                                            displayColor: displayColor
                                        });

                                        if (layer._path) {
                                            layer._path.setAttribute('aria-checked', 'true');
                                            layer._path.setAttribute('aria-description',
                                                `${marking.regionName} (${marking.regionType}) markiert`);
                                        }

                                        loadedCount++;
                                    } else {
                                        failedCount++;
                                    }
                                } else {
                                    failedCount++;
                                }
                            });

                            // Setze Farbindex zur√ºck, falls vorhanden
                            if (importData.colorIndex !== undefined) {
                                colorIndex = importData.colorIndex;
                            }

                            // NEU: Lade ausgew√§hlte Vertriebsbezirke und Filterzustand
                            if (importData.selectedSalesDistricts && Array.isArray(importData.selectedSalesDistricts)) {
                                selectedSalesDistricts = new Set(importData.selectedSalesDistricts);
                            } else {
                                selectedSalesDistricts.clear(); // Falls nicht vorhanden oder ung√ºltig, leeren
                            }
                            // isFilterActive sollte nur auf true gesetzt werden, wenn es explizit im Import ist,
                            // oder wenn selectedSalesDistricts nach dem Laden nicht leer ist (f√ºr √§ltere Versionen).
                            // Wenn importData.isFilterActive existiert, verwenden wir es. Ansonsten leiten wir es ab.
                            if (typeof importData.isFilterActive === 'boolean') {
                                isFilterActive = importData.isFilterActive;
                            } else {
                                // F√ºr √§ltere Versionen ohne isFilterActive: Wenn selectedSalesDistricts nach dem Laden nicht leer ist,
                                // bedeutet das, dass der Filter aktiv war.
                                isFilterActive = selectedSalesDistricts.size > 0;
                            }

                            // Aktualisiere Anzeige
                            updateAllDisplays(); // Ruft applyRegionColoring auf

                            appendMessageToChatLog(
                                `üìÇ ${loadedCount} Datens√§tze wurden aus der Datei geladen!` +
                                (failedCount > 0 ? `\n‚ùì ${failedCount} Datens√§tze konnten nicht wiederhergestellt werden.` : ''),
                                'assistant'
                            );
                        } catch (error) {
                            console.error(`Fehler beim Verarbeiten der geladenen Datei: ${error.message}`);
                            appendMessageToChatLog(`‚ùå Fehler beim Laden der Datei: ${error.message}`, 'assistant');
                        } finally {
                            document.body.removeChild(fileInput);
                        }
                    };

                    reader.onerror = function() {
                        appendMessageToChatLog("‚ùå Die Datei konnte nicht gelesen werden.", 'assistant');
                        document.body.removeChild(fileInput);
                    };

                    reader.readAsText(file);
                };

                // √ñffne den Datei-Dialog
                fileInput.click();

            } catch (error) {
                console.error(`Fehler beim Laden der Daten: ${error.message}`);
                appendMessageToChatLog(`‚ùå Fehler beim Laden: ${error.message}`, 'assistant');
            }
        }

        /* OPTIMIERT: Funktion zum Aggregieren der Umsatzdaten nach Vertriebsbezirk (administrative Sicht) */
        function aggregateSalesDistrictData() {
            try {
                const salesDistrictData = {};

                markedDistricts.forEach((data) => {
                    if (!data.salesEntries || data.salesEntries.length === 0) return;

                    const regionName = data.regionName;
                    const regionType = data.regionType;
                    const regionObjid = data.objid;

                    data.salesEntries.forEach(entry => {
                        if (!entry.salesDistrict) return;

                        const district = entry.salesDistrict;

                        if (!salesDistrictData[district]) {
                            salesDistrictData[district] = {
                                salesDistrict: district,
                                salesGroup: '',
                                conceptualRegions: new Map(), // Map zum Speichern konzeptioneller Regionen (Name__Typ -> {Daten})
                                totalRevenue: 0, // Gesamtumsatz f√ºr diesen Vertriebsbezirk (Summe der administrativen Einheiten)
                                center: null,
                                entryCount: 0, // Gesamtzahl der Sales Entries f√ºr diesen Vertriebsbezirk
                                layerCount: 0 // F√ºr die Mittelpunktberechnung
                            };
                        }

                        salesDistrictData[district].entryCount++; // Z√§hlt weiterhin die Anzahl der Sales Entries

                        const conceptualRegionKey = `${regionName}__${regionType}`;
                        let conceptualRegion = salesDistrictData[district].conceptualRegions.get(conceptualRegionKey);

                        if (!conceptualRegion) {
                            conceptualRegion = {
                                name: regionName,
                                type: regionType,
                                objids: new Set(), // Set zum Verfolgen eindeutiger objids, die zu dieser konzeptionellen Region geh√∂ren
                                totalRevenue: 0, // Umsatz f√ºr diese konzeptionelle Region (der administrative Gesamtumsatz)
                                entryCount: 0 // Anzahl der Sales Entries f√ºr diese konzeptionelle Region
                            };
                            salesDistrictData[district].conceptualRegions.set(conceptualRegionKey, conceptualRegion);
                        }

                        // F√ºge die objid hinzu, um die geografischen Teile zu verfolgen
                        conceptualRegion.objids.add(regionObjid);
                        conceptualRegion.entryCount++;

                        // WICHTIGE LOGIK√ÑNDERUNG:
                        // Der Umsatz der administrativen Einheit (entry.revenue) wird nur einmal zur conceptualRegion.totalRevenue
                        // und zum salesDistrictData[district].totalRevenue addiert, wenn es sich um den ersten geografischen Teil
                        // dieser spezifischen administrativen Einheit (definiert durch Name, Typ und objid) handelt,
                        // der zu diesem Vertriebsbezirk beitr√§gt.
                        // Die Bedingung `conceptualRegion.objids.size === 1` stellt sicher, dass dies nur beim ersten
                        // geografischen Teil dieser konzeptionellen Region geschieht, um Doppelz√§hlungen zu vermeiden.
                        // Der `entry.revenue` enth√§lt den vollen administrativen Umsatz, der f√ºr alle geografischen Teile derselben
                        // administrativen Einheit gleich sein sollte.
                        if (conceptualRegion.objids.size === 1) {
                            conceptualRegion.totalRevenue = entry.revenue || 0; // Setze den administrativen Gesamtumsatz f√ºr die konzeptionelle Region
                            salesDistrictData[district].totalRevenue += (entry.revenue || 0); // Addiere zum Gesamtumsatz des Vertriebsbezirks
                        }

                        // Setze die Vertriebsgruppe (nehme die erste gefundene)
                        if (!salesDistrictData[district].salesGroup && entry.salesGroup) {
                            salesDistrictData[district].salesGroup = entry.salesGroup;
                        }

                        // Berechne den Mittelpunkt (gewichteter Durchschnitt) - basiert weiterhin auf tats√§chlichen objids
                        const layer = objIdToLayerMap.get(regionObjid);
                        if (layer && layer.getCenter) {
                            const center = layer.getCenter();
                            const currentCount = salesDistrictData[district].layerCount;
                            const currentCenter = salesDistrictData[district].center;

                            if (!currentCenter) {
                                salesDistrictData[district].center = center;
                            } else {
                                const lat = (currentCenter.lat * currentCount + center.lat) / (currentCount + 1);
                                const lng = (currentCenter.lng * currentCount + center.lng) / (currentCount + 1);
                                salesDistrictData[district].center = L.latLng(lat, lng);
                            }
                            salesDistrictData[district].layerCount++;
                        }
                    });
                });

                // Konvertiere die conceptualRegions Map in ein Array f√ºr die einfachere Iteration in der UI
                for (const districtKey in salesDistrictData) {
                    salesDistrictData[districtKey].regions = Array.from(salesDistrictData[districtKey].conceptualRegions.values());
                    // Sortiere konzeptionelle Regionen nach Namen f√ºr eine konsistente Anzeige
                    salesDistrictData[districtKey].regions.sort((a, b) => a.name.localeCompare(b.name));
                }

                return salesDistrictData;
            } catch (error) {
                console.error(`Fehler beim Aggregieren der Vertriebsdaten: ${error.message}`);
                return {};
            }
        }

        /* GE√ÑNDERT: Aktualisiert die Infoboxen f√ºr Vertriebsbezirke mit Kollisionsvermeidung */
        function updateSalesDistrictInfoboxes() {
            try {
                // Entferne alle vorhandenen Infoboxen
                for (const district in salesDistrictInfoboxes) {
                    if (salesDistrictInfoboxes[district].parentNode) {
                        salesDistrictInfoboxes[district].parentNode.removeChild(salesDistrictInfoboxes[district]);
                    }
                }
                salesDistrictInfoboxes = {};

                // NEU: Nur erstellen, wenn Infoboxen angezeigt werden sollen UND Zoom-Level passt
                if (!showSalesDistrictInfoboxes || leafletMap.getZoom() < MIN_ZOOM_FOR_INFOBOXES) {
                    return;
                }

                // Aggregiere Vertriebsdaten
                const salesDistrictData = aggregateSalesDistrictData();

                // NEU: Array zum Speichern der Infobox-Informationen f√ºr die Positionierung
                const infoboxesToProcess = [];

                // Erstelle neue Infoboxen und speichere ihre Referenzen und initialen Positionen
                for (const district in salesDistrictData) {
                    const data = salesDistrictData[district];

                    // NEU: Filtern nach ausgew√§hlten Vertriebsbezirken
                    // Zeige Infobox nur, wenn Filter nicht aktiv ist ODER der Bezirk explizit ausgew√§hlt ist.
                    if (isFilterActive && !selectedSalesDistricts.has(district)) {
                        continue; // √úberspringe diesen Bezirk, wenn er nicht ausgew√§hlt ist und der Filter aktiv ist
                    }

                    // Nur Infoboxen f√ºr Bezirke mit Zentrum erstellen
                    if (data.center) {
                        const infobox = document.createElement('div');
                        infobox.className = 'sales-district-infobox';
                        infobox.setAttribute('role', 'button'); /* Rolle f√ºr Klickbarkeit */
                        infobox.setAttribute('aria-label', `Vertriebsbezirk ${data.salesDistrict} Details anzeigen`);
                        infobox.setAttribute('data-district-name', data.salesDistrict); /* Speichert den Namen f√ºr den Klick-Handler */

                        // Setze den Inhalt nur auf den Vertriebsbezirksnamen
                        infobox.innerHTML = `<div class="sales-district-infobox-title">${escapeHtml(data.salesDistrict)}</div>`;

                        // F√ºge Klick-Handler hinzu
                        infobox.addEventListener('click', () => openSalesDistrictDetailPopup(data.salesDistrict)); // OPTIMIERT: Event-Listener registrieren

                        // F√ºge Infobox zum Dokument hinzu (tempor√§r, um Breite/H√∂he zu erhalten)
                        document.body.appendChild(infobox);

                        // Berechne die initiale Bildschirmposition
                        const point = leafletMap.latLngToContainerPoint(data.center);

                        infoboxesToProcess.push({
                            element: infobox,
                            districtName: data.salesDistrict,
                            originalLatLng: data.center, // Store original LatLng for map move
                            originalX: point.x,
                            originalY: point.y,
                            currentX: point.x, // These will be adjusted
                            currentY: point.y, // These will be adjusted
                            width: infobox.offsetWidth,
                            height: infobox.offsetHeight
                        });

                        // Speichere Referenz (f√ºr sp√§tere Entfernung)
                        salesDistrictInfoboxes[district] = infobox;
                    }
                }

                // NEU: Kollisionserkennung und Repositionierung
                // Sortiere die Boxen nach ihrer Y-Koordinate, um von oben nach unten zu verarbeiten
                infoboxesToProcess.sort((a, b) => a.originalY - b.originalY);

                const verticalPadding = 5; // Vertikaler Abstand zwischen gestapelten Boxen

                // Einfacher Algorithmus zur Kollisionsvermeidung (vertikale Stapelung)
                // Iteriere √ºber alle Boxen und verschiebe sie, wenn sie mit vorherigen Boxen √ºberlappen
                for (let i = 0; i < infoboxesToProcess.length; i++) {
                    const currentBox = infoboxesToProcess[i];

                    // Initialisiere die aktuelle Position mit der urspr√ºnglichen
                    currentBox.currentX = currentBox.originalX;
                    currentBox.currentY = currentBox.originalY;

                    for (let j = 0; j < i; j++) {
                        const previousBox = infoboxesToProcess[j];

                        // √úberpr√ºfe auf √úberlappung (Bounding Box Collision)
                        // Pr√ºfe, ob sich die X-Bereiche √ºberlappen UND die Y-Bereiche √ºberlappen
                        if (currentBox.currentX < previousBox.currentX + previousBox.width &&
                            currentBox.currentX + currentBox.width > previousBox.currentX &&
                            currentBox.currentY < previousBox.currentY + previousBox.height &&
                            currentBox.currentY + currentBox.height > previousBox.currentY) {

                            // √úberlappung erkannt: Verschiebe die aktuelle Box nach unten
                            currentBox.currentY = previousBox.currentY + previousBox.height + verticalPadding;
                        }
                    }
                }

                // Wende die angepassten Positionen auf die DOM-Elemente an
                infoboxesToProcess.forEach(box => {
                    box.element.style.left = (box.currentX - box.width / 2) + 'px';
                    box.element.style.top = (box.currentY - box.height / 2) + 'px';
                    box.element.style.opacity = '1'; // Make visible with fade-in
                });

            } catch (error) {
                console.error(`Fehler beim Aktualisieren der Vertriebsbezirk-Infoboxes: ${error.message}`);
            }
        }

        /* NEU: Funktion zum √ñffnen des Detail-Popups f√ºr Vertriebsbezirke */
        function openSalesDistrictDetailPopup(districtName) {
            const salesDistrictData = aggregateSalesDistrictData();
            const data = salesDistrictData[districtName];

            if (!data) {
                console.warn(`Keine Daten f√ºr Vertriebsbezirk ${districtName} gefunden.`);
                return;
            }

            // F√ºlle das Popup mit Daten
            DOM.detailDistrict.textContent = data.salesDistrict;
            DOM.detailGroup.textContent = data.salesGroup || 'N/A';
            DOM.detailRevenue.textContent = `${new Intl.NumberFormat('de-DE').format(data.totalRevenue)} ‚Ç¨`;
            // Jetzt wird die Anzahl der konzeptionellen Regionen angezeigt
            DOM.detailRegionCount.textContent = data.regions.length;
            DOM.detailEntryCount.textContent = data.entryCount;

            // Liste der Regionen
            DOM.detailRegionList.innerHTML = '';
            if (data.regions.length > 0) {
                // Iteriere √ºber die konzeptionellen Regionen
                data.regions.forEach(conceptualRegion => {
                    const listItem = document.createElement('li');
                    listItem.className = 'detail-list-item';
                    let regionText = `${escapeHtml(conceptualRegion.name)} (${escapeHtml(conceptualRegion.type)})`;

                    // F√ºge die Anzahl der zugrunde liegenden objids hinzu, wenn mehr als eine
                    if (conceptualRegion.objids.size > 1) {
                        regionText += ` (${conceptualRegion.objids.size} Teile)`;
                    }

                    // F√ºge den Gesamtumsatz f√ºr diese konzeptionelle Region hinzu
                    if (conceptualRegion.totalRevenue > 0) {
                        regionText += ` - ${new Intl.NumberFormat('de-DE').format(conceptualRegion.totalRevenue)} ‚Ç¨`;
                    }
                    listItem.textContent = regionText;
                    DOM.detailRegionList.appendChild(listItem);
                });
            } else {
                const listItem = document.createElement('li');
                listItem.textContent = 'Keine zugeordneten Regionen.';
                DOM.detailRegionList.appendChild(listItem);
            }

// Setzt die Kartenansicht auf die urspr√ºngliche Zoom-Ebene und Position zur√ºck
            leafletMap.setView([51.16, 10.45], 7);

            // Zeige das Popup und das Overlay
            DOM.salesDistrictDetailPopup.classList.remove('hidden');
            DOM.dialogOverlay.classList.remove('hidden');
        }

        /* NEU: Funktion zum Schlie√üen des Detail-Popups f√ºr Vertriebsbezirke */
        function closeSalesDistrictDetailPopup() {
            DOM.salesDistrictDetailPopup.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            // ENTFERNT: Die Zeile DOM.dialogOverlay.classList.add('hidden'); wurde hier entfernt.
        }

        /* NEU: Eine generische Funktion zum Schlie√üen aller offenen Dialoge, die das Overlay verwenden */
        function closeAnyOpenDialogs() {
            let dialogClosed = false;
            // Pr√ºfe, ob der Bearbeitungsdialog ge√∂ffnet ist und schlie√üe ihn
            if (!DOM.editSalesDialog.classList.contains('hidden')) {
                closeEditDialog(); // Diese Funktion schlie√üt auch das Overlay
                dialogClosed = true;
            }
            // Pr√ºfe, ob der Vertriebsbezirks-Detaildialog ge√∂ffnet ist und schlie√üe ihn
            if (!DOM.salesDistrictDetailPopup.classList.contains('hidden')) {
                // Hier rufen wir die spezifische Schlie√üfunktion auf,
                // die sich nun nur um das Ausblenden des Popups selbst k√ºmmert.
                DOM.salesDistrictDetailPopup.classList.add('hidden');
                dialogClosed = true;
            }
            // Wenn kein spezifischer Dialog geschlossen wurde, aber das Overlay sichtbar ist,
            // dann schlie√üe das Overlay explizit (dies sollte nur passieren, wenn alle Dialoge schon zu sind).
            if (!dialogClosed && !DOM.dialogOverlay.classList.contains('hidden')) {
                DOM.dialogOverlay.classList.add('hidden');
            }

 // Unabh√§ngig davon, welcher Dialog geschlossen wurde (oder ob keiner spezifisch geschlossen wurde,
            // aber das Overlay sichtbar ist), stellen wir sicher, dass das Overlay ausgeblendet wird.
            DOM.dialogOverlay.classList.add('hidden');
        }


        /* NEU: Toggle f√ºr Vertriebsbezirk-Infoboxen */
        DOM.salesDistrictToggle.addEventListener('change', function() { // OPTIMIERT: Event-Listener direkt registrieren
            showSalesDistrictInfoboxes = this.checked;
            updateSalesDistrictInfoboxes(); // Ruft die Funktion auf, die auch den Zoom-Level pr√ºft
        });

        /* NEU: Toggle f√ºr Umsatzvolumen-F√§rbung */
        DOM.revenueColoringToggle.addEventListener('change', function() { // OPTIMIERT: Event-Listener direkt registrieren
            showRevenueBasedColoring = this.checked;
            applyRegionColoring(); // Farben neu anwenden
        });

        /* NEU: Aktualisiere Infoboxen bei Karten-Move */
        function updateInfoboxPositionsOnMapMove() {
            // Nur aktualisieren, wenn Infoboxen angezeigt werden sollen
            if (!showSalesDistrictInfoboxes) return;

            // F√ºhre die gesamte Update-Logik erneut aus, um die Positionen einschlie√ülich der Kollisionsvermeidung neu zu berechnen
            updateSalesDistrictInfoboxes();
        }

        /* NEU: Funktion zum Bef√ºllen des Vertriebsgruppen-Filter-Dropdowns */
        function populateSalesGroupFilter() {
            const currentSelectedValue = DOM.salesGroupFilter.value; // OPTIMIERT: DOM-Referenz nutzen
            DOM.salesGroupFilter.innerHTML = '<option value="">Alle Gruppen</option>'; // Standardoption // OPTIMIERT: DOM-Referenz nutzen

            const uniqueSalesGroups = new Set();
            markedDistricts.forEach(data => {
                data.salesEntries.forEach(entry => {
                    // Ber√ºcksichtige nur Vertriebsbezirke, die im salesDistrictFilter ausgew√§hlt sind
                    // UND die den aktuellen Vertriebsbezirksfiltern entsprechen
                    const passesDistrictFilter = !isFilterActive || selectedSalesDistricts.has(entry.salesDistrict);

                    if (entry.salesGroup && passesDistrictFilter) {
                        uniqueSalesGroups.add(entry.salesGroup);
                    }
                });
            });

            const sortedGroups = Array.from(uniqueSalesGroups).sort();
            sortedGroups.forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                option.textContent = group;
                DOM.salesGroupFilter.appendChild(option); // OPTIMIERT: DOM-Referenz nutzen
            });

            // Setze den vorherigen Wert wieder, falls er noch g√ºltig ist
            if (currentSelectedValue && uniqueSalesGroups.has(currentSelectedValue)) {
                DOM.salesGroupFilter.value = currentSelectedValue; // OPTIMIERT: DOM-Referenz nutzen
            } else {
                DOM.salesGroupFilter.value = ""; // Setze auf "Alle Gruppen", wenn der vorherige Wert nicht mehr existiert // OPTIMIERT: DOM-Referenz nutzen
            }
        }

        /* NEU: Funktion zum Bef√ºllen der Vertriebsbezirks-Checkboxen */
        function populateSalesDistrictCheckboxes() {
            DOM.salesDistrictCheckboxes.innerHTML = ''; // Clear existing checkboxes // OPTIMIERT: DOM-Referenz nutzen
            allSalesDistricts.clear(); // Clear the set before re-populating

            markedDistricts.forEach(data => {
                data.salesEntries.forEach(entry => {
                    if (entry.salesDistrict) {
                        allSalesDistricts.add(entry.salesDistrict);
                    }
                });
            });

            const sortedDistricts = Array.from(allSalesDistricts).sort();
            const searchTerm = DOM.salesDistrictFilterSearch.value.toLowerCase().trim(); // OPTIMIERT: DOM-Referenz nutzen

            sortedDistricts.forEach(district => {
                if (searchTerm && !district.toLowerCase().includes(searchTerm)) {
                    return; // Skip if search term doesn't match
                }

                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'sales-district-checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `district-${district}`;
                checkbox.value = district;

                // Bestimme den checked-Status basierend auf isFilterActive und selectedSalesDistricts
                const isChecked = !isFilterActive || selectedSalesDistricts.has(district);
                checkbox.checked = isChecked;
                checkbox.setAttribute('aria-checked', isChecked);

                const label = document.createElement('label');
                label.htmlFor = `district-${district}`;
                label.textContent = district;

                checkbox.addEventListener('change', (event) => {
                    // Wenn der Filter vorher nicht aktiv war (alle waren implizit ausgew√§hlt)
                    if (!isFilterActive) {
                        isFilterActive = true; // Jetzt ist der Filter aktiv
                        // F√ºlle selectedSalesDistricts mit allen aktuell angezeigten Bezirken
                        // (d.h. denen, die im Suchfilter passieren)
                        selectedSalesDistricts.clear();
                        sortedDistricts.forEach(d => {
                            if (d.toLowerCase().includes(searchTerm)) { // Nur die, die im Suchfeld sichtbar sind
                                selectedSalesDistricts.add(d);
                            }
                        });
                        // Entferne den gerade abgew√§hlten Bezirk
                        selectedSalesDistricts.delete(district);
                    } else {
                        // Wenn der Filter bereits aktiv war, einfach hinzuf√ºgen/entfernen
                        if (event.target.checked) {
                            selectedSalesDistricts.add(district);
                        } else {
                            selectedSalesDistricts.delete(district);
                        }
                    }

                    // √úberpr√ºfe, ob alle sichtbaren Bezirke ausgew√§hlt sind, um zum "alle anzeigen"-Modus zur√ºckzukehren
                    const currentlyVisibleDistricts = sortedDistricts.filter(d => d.toLowerCase().includes(searchTerm));
                    if (selectedSalesDistricts.size === currentlyVisibleDistricts.length && isFilterActive) {
                        isFilterActive = false;
                        selectedSalesDistricts.clear(); // Set leeren f√ºr Effizienz
                    } else if (selectedSalesDistricts.size === 0 && isFilterActive && currentlyVisibleDistricts.length > 0) {
                        // Wenn alle sichtbar waren und jetzt alle abgew√§hlt wurden, bleiben wir im isFilterActive = true Zustand
                        // Das bedeutet "nichts anzeigen"
                    }

                    updateAllDisplays(); // Filter neu anwenden und Infoboxen aktualisieren
                });

                checkboxContainer.appendChild(checkbox);
                checkboxContainer.appendChild(label);
                DOM.salesDistrictCheckboxes.appendChild(checkboxContainer); // OPTIMIERT: DOM-Referenz nutzen
            });

            // Blende den Filterbereich aus/ein, wenn keine Bezirke markiert sind
            if (allSalesDistricts.size === 0) {
                DOM.salesDistrictSelectionContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            } else {
                DOM.salesDistrictSelectionContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            }
        }

        /* NEUE HILFSFUNKTIONEN F√úR KI-ANALYSE */

        // Helper to get all sales entries from marked districts
        function getAllSalesEntries() {
            const allEntries = [];
            markedDistricts.forEach(data => {
                if (data.salesEntries) {
                    data.salesEntries.forEach(entry => {
                        allEntries.push({
                            regionName: data.regionName,
                            regionType: data.regionType,
                            objid: data.objid,
                            ...entry // id, color, salesGroup, salesDistrict, revenue
                        });
                    });
                }
            });
            return allEntries;
        }

        // Analyze Revenue (sum/average)
        function analyzeRevenue(type, filter) {
            const allSalesEntries = getAllSalesEntries();
            let revenuesToSum = [];

            if (filter) {
                if (filter.salesDistrict) {
                    const filteredByDistrict = allSalesEntries.filter(e => e.salesDistrict === filter.salesDistrict);
                    revenuesToSum = filteredByDistrict.map(e => e.revenue || 0);
                } else if (filter.salesGroup) {
                    // NEW LOGIC: Sum aggregated revenues of sales districts within this group
                    const aggregatedDistrictData = aggregateSalesDistrictData();
                    const districtsInGroup = Object.values(aggregatedDistrictData).filter(
                        district => district.salesGroup === filter.salesGroup
                    );
                    revenuesToSum = districtsInGroup.map(district => district.totalRevenue);
                } else {
                    revenuesToSum = allSalesEntries.map(e => e.revenue || 0);
                }
            } else {
                revenuesToSum = allSalesEntries.map(e => e.revenue || 0);
            }

            if (revenuesToSum.length === 0) {
                return "Es wurden keine Ums√§tze f√ºr die angegebenen Kriterien gefunden.";
            }

            const totalRevenue = revenuesToSum.reduce((sum, revenue) => sum + revenue, 0);

            let message = "";
            const filterDescription = filter ? (filter.salesDistrict ? `Vertriebsbezirk "${filter.salesDistrict}"` : `Vertriebsgruppe "${filter.salesGroup}"`) : "alle markierten Daten";

            if (type === "sum") {
                message = `Der Gesamtumsatz f√ºr ${filterDescription} betr√§gt: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(totalRevenue)}.`;
            } else if (type === "average") {
                const averageRevenue = totalRevenue / revenuesToSum.length;
                message = `Der Durchschnittsumsatz pro ${filter.salesGroup ? 'Vertriebsbezirk' : 'Eintrag'} f√ºr ${filterDescription} betr√§gt: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(averageRevenue)}.`;
            }
            return message;
        }

        // Get Top N Regions/Districts by Revenue
        function getTopList(listType, limit) {
            const allSalesEntries = getAllSalesEntries();
            if (allSalesEntries.length === 0) {
                return "Es sind keine Umsatzdaten vorhanden, um eine Top-Liste zu erstellen.";
            }

            const regionMaxRevenues = new Map(); // Map to store max revenue for each region
            allSalesEntries.forEach(entry => {
                const regionKey = `${entry.regionName}__${entry.regionType}`; // Unique key for the region
                const currentMax = regionMaxRevenues.get(regionKey) || 0;
                if ((entry.revenue || 0) > currentMax) {
                    regionMaxRevenues.set(regionKey, (entry.revenue || 0));
                }
            });

            // Convert map to array of objects for sorting
            const regionsWithRevenue = Array.from(regionMaxRevenues.entries()).map(([key, revenue]) => {
                const [name, type] = key.split('__');
                return { name, type, totalRevenue: revenue };
            });

            const sorted = regionsWithRevenue.sort((a, b) => b.totalRevenue - a.totalRevenue);
            const topItems = sorted.slice(0, limit);

            if (topItems.length === 0) {
                return `Keine ${listType} Daten gefunden.`;
            }

            let message = `Top ${topItems.length} Regionen nach Umsatz:\n`;
            topItems.forEach((item, index) => {
                message += `${index + 1}. ${item.name} (${item.type}): ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(item.totalRevenue)}\n`;
            });
            return message;
        }

        function analyzeDistrict(filter) {
            // allSalesEntries wird hier nicht mehr direkt f√ºr die Summation verwendet,
            // da wir auf die korrekt aggregierten Daten aus aggregateSalesDistrictData zugreifen.
            // const allSalesEntries = getAllSalesEntries();

            let filterTarget = "";
            let totalRevenue = 0;
            let uniqueRegionsInFilter = new Set();
            let totalEntriesCount = 0;

            const aggregatedDistrictData = aggregateSalesDistrictData(); // Aggregierte Daten einmal holen

            if (filter.salesDistrict) {
                filterTarget = `Vertriebsbezirk: ${filter.salesDistrict}`;
                const districtData = aggregatedDistrictData[filter.salesDistrict]; // Daten f√ºr den spezifischen Bezirk holen

                if (districtData) {
                    totalRevenue = districtData.totalRevenue; // Den bereits korrekt aggregierten Umsatz nutzen
                    districtData.regions.forEach(region => uniqueRegionsInFilter.add(region.name));
                    totalEntriesCount = districtData.entryCount; // Anzahl der Sales Entries f√ºr diesen Bezirk
                } else {
                    return `Keine Daten f√ºr ${filterTarget} gefunden.`;
                }

            } else if (filter.salesGroup) {
                filterTarget = `Vertriebsgruppe: ${filter.salesGroup}`;
                const districtsInGroup = Object.values(aggregatedDistrictData).filter(
                    district => district.salesGroup === filter.salesGroup
                );

                if (districtsInGroup.length === 0) {
                    return `Keine Daten f√ºr ${filterTarget} gefunden.`;
                }

                totalRevenue = districtsInGroup.reduce((sum, district) => sum + district.totalRevenue, 0);
                districtsInGroup.forEach(district => {
                    district.regions.forEach(region => uniqueRegionsInFilter.add(region.name));
                    totalEntriesCount += district.entryCount;
                });
            } else {
                return "Bitte geben Sie einen Vertriebsbezirk oder eine Vertriebsgruppe f√ºr die Analyse an.";
            }

            // ... Rest der Funktion bleibt gleich
            const averageRevenuePerEntry = totalEntriesCount > 0 ? totalRevenue / totalEntriesCount : 0;

            let message = `üìä Analyse ${filterTarget}\n`;
            message += `üí∞ Gesamtumsatz: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(totalRevenue)}\n`;
            message += `üìà Durchschnittsumsatz pro Eintrag: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(averageRevenuePerEntry)}\n`;
            message += `üèõÔ∏è Anzahl Regionen: ${uniqueRegionsInFilter.size}\n`;
            message += `üìç Regionen: ${Array.from(uniqueRegionsInFilter).join(', ')}`;
            return message;
        }

        // Compare sales districts
        function compareDistricts(districts) {
            if (!Array.isArray(districts) || districts.length !== 2) {
                return "Bitte geben Sie genau zwei Vertriebsbezirke zum Vergleichen an.";
            }

            const data1 = aggregateSalesDataForDistrict(districts[0]); // This calls the helper
            const data2 = aggregateSalesDataForDistrict(districts[1]); // This calls the helper

            let message = `Vergleich von ${districts[0]} und ${districts[1]}:\n\n`;

            message += `--- ${districts[0]} ---\n`;
            message += `Gesamtumsatz: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data1.totalRevenue)}\n`;
            message += `Anzahl Regionen: ${data1.regions.length}\n`; // Use data1.regions.length as it's now unique regions
            message += `Durchschnitt pro Eintrag: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data1.totalRevenue / data1.entryCount)}\n\n`; // Recalculate average based on new totalRevenue and entryCount

            message += `--- ${districts[1]} ---\n`;
            message += `Gesamtumsatz: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data2.totalRevenue)}\n`;
            message += `Anzahl Regionen: ${data2.regions.length}\n`; // Use data2.regions.length
            message += `Durchschnitt pro Eintrag: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data2.totalRevenue / data2.entryCount)}\n\n`; // Recalculate average

            if (data1.totalRevenue > data2.totalRevenue) {
                message += `${districts[0]} hat einen h√∂heren Gesamtumsatz.`;
            } else if (data2.totalRevenue > data1.totalRevenue) {
                message += `${districts[1]} hat einen h√∂heren Gesamtumsatz.`;
            } else {
                message += `Beide Bezirke haben den gleichen Gesamtumsatz.`;
            }
            return message;
        }

        // Helper for compareDistricts and other aggregations
        function aggregateSalesDataForDistrict(districtName) {
            const districtData = aggregateSalesDistrictData(); // Get all aggregated district data
            return districtData[districtName] || { // Return data for specific district or empty object if not found
                salesDistrict: districtName,
                salesGroup: '',
                regions: [],
                totalRevenue: 0,
                center: null,
                entryCount: 0,
                layerCount: 0
            };
        }

        // Get region with highest revenue (single entry)
        function getRegionWithHighestRevenue() {
            const entries = getAllSalesEntries();
            if (entries.length === 0) {
                return "Es sind keine Umsatzdaten vorhanden, um die Region mit dem h√∂chsten Umsatz zu finden.";
            }

            let highestRevenueEntry = null;
            entries.forEach(entry => {
                if (!highestRevenueEntry || (entry.revenue || 0) > (highestRevenueEntry.revenue || 0)) {
                    highestRevenueEntry = entry;
                }
            });

            if (highestRevenueEntry) {
                return `Die Region mit dem h√∂chsten Einzelumsatz ist ${highestRevenueEntry.regionName} (${highestRevenueEntry.regionType}) mit einem Umsatz von ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(highestRevenueEntry.revenue || 0)} im Vertriebsbezirk ${highestRevenueEntry.salesDistrict || 'N/A'}.`;
            }
            return "Keine Region mit Umsatzdaten gefunden.";
        }

        // Count regions in a sales group
        function countRegionsInSalesGroup(salesGroup) {
            const entries = getAllSalesEntries().filter(e => e.salesGroup === salesGroup);
            const uniqueRegions = new Set(entries.map(e => e.regionName));
            if (uniqueRegions.size === 0) {
                return `Es wurden keine Regionen in der Vertriebsgruppe "${salesGroup}" gefunden.`;
            }
            return `In der Vertriebsgruppe "${salesGroup}" gibt es ${uniqueRegions.size} Regionen: ${Array.from(uniqueRegions).join(', ')}.`;
        }

        /* NEU: Funktion zum Generieren des dynamischen System-Prompts */
        function generateDynamicSystemPrompt() {
            let dynamicPrompt = baseSystemPrompt;

            // --- START DES NEUEN ABSCHNITTS: Zusammenfassung der markierten Daten ---
            const allEntries = getAllSalesEntries(); // Nutzt Ihre bestehende Hilfsfunktion
            const uniqueDistricts = new Set();
            const uniqueGroups = new Set();
            const totalMarkedRegions = markedDistricts.size;

            allEntries.forEach(entry => {
                if (entry.salesDistrict) uniqueDistricts.add(entry.salesDistrict);
                if (entry.salesGroup) uniqueGroups.add(entry.salesGroup);
            });

            dynamicPrompt += "\n\n√úBERSICHT DER MARKIERUNGEN:\n";
            dynamicPrompt += `- Es sind aktuell ${totalMarkedRegions} Regionen markiert.\n`;
            dynamicPrompt += `- Diese umfassen ${uniqueDistricts.size} eindeutige Vertriebsbezirke und ${uniqueGroups.size} eindeutige Vertriebsgruppen.\n`;

            // Optional: Liste eine kleine Anzahl der h√§ufigsten/ersten Vertriebsbezirke/Gruppen auf
            if (uniqueDistricts.size > 0) {
                const districtCounts = {};
                allEntries.forEach(entry => {
                    if (entry.salesDistrict) {
                        districtCounts[entry.salesDistrict] = (districtCounts[entry.salesDistrict] || 0) + 1;
                    }
                });
                const sortedDistricts = Object.keys(districtCounts).sort((a, b) => districtCounts[b] - districtCounts[a]);
                dynamicPrompt += `- Einige Vertriebsbezirke: ${sortedDistricts.slice(0, Math.min(sortedDistricts.length, 5)).join(', ')}${sortedDistricts.length > 5 ? '...' : ''}\n`;
            }

            if (uniqueGroups.size > 0) {
                const groupCounts = {};
                allEntries.forEach(entry => {
                    if (entry.salesGroup) {
                        groupCounts[entry.salesGroup] = (groupCounts[entry.salesGroup] || 0) + 1;
                    }
                });
                const sortedGroups = Object.keys(groupCounts).sort((a, b) => groupCounts[b] - groupCounts[a]);
                dynamicPrompt += `- Einige Vertriebsgruppen: ${sortedGroups.slice(0, Math.min(sortedGroups.length, 5)).join(', ')}${sortedGroups.length > 5 ? '...' : ''}\n`;
            }
            // --- ENDE DES NEUEN ABSCHNITTS ---

            dynamicPrompt += "\n\nNEUE VERF√úGBARE BEFEHLE (immer als JSON zur√ºckgeben):\n";
            dynamicPrompt += `
1. Umsatzanalyse: {"action": "analyze_revenue", "type": "sum|average", "filter": {"salesDistrict": "Bezirk", "salesGroup": "Gruppe"}}
   - Berechnet die Summe oder den Durchschnitt des Umsatzes basierend auf dem Filter.
   - Beispiel: "Summe der Ums√§tze von H30L" -> {"action": "analyze_revenue", "type": "sum", "filter": {"salesDistrict": "H30L"}}
   - Beispiel: "Durchschnittsumsatz in Vertriebsgruppe ISL3" -> {"action": "analyze_revenue", "type": "average", "filter": {"salesGroup": "ISL3"}}
2. Top-Liste: {"action": "top_list", "type": "revenue", "limit": 5}
   - Zeigt die Top N Regionen/Bezirke nach Umsatz an.
   - Beispiel: "Top 5 Regionen nach Umsatz" -> {"action": "top_list", "type": "revenue", "limit": 5}
3. Vergleich von Vertriebsbezirken: {"action": "compare", "type": "districts", "items": ["Bezirk1", "Bezirk2"]}
   - Vergleicht die angegebenen Vertriebsbezirke.
   - Beispiel: "Vergleiche Vertriebsbezirke H30L und H10A" -> {"action": "compare", "type": "districts", "items": ["H30L", "H10A"]}
4. Detailanalyse eines Vertriebsbezirks oder einer Vertriebsgruppe: {"action": "analyze_district", "salesDistrict": "Bezirk"} ODER {"action": "analyze_district", "salesGroup": "Gruppe"}
   - Gibt detaillierte Informationen zu einem Vertriebsbezirk oder einer Vertriebsgruppe aus.
   - Beispiel: "Analyse Vertriebsbezirk H30L" -> {"action": "analyze_district", "salesDistrict": "H30L"}
   - Beispiel: "Analyse Vertriebsgruppe ISL3" -> {"action": "analyze_district", "salesGroup": "ISL3"}
`;
            // Add list of all available regions to the prompt
            dynamicPrompt += "\n\nLISTE ALLER VERF√úGBARER REGIONEN (Name (Typ)):\n";
            const allRegionNames = [];
            regionsTable.forEach(region => {
                allRegionNames.push(`${region.name} (${region.type})`);
            });
            dynamicPrompt += allRegionNames.slice(0, 200).join(', ') + (allRegionNames.length > 200 ? '...' : ''); // Limit to avoid prompt overflow

            return dynamicPrompt;
        }

        /* Karten-Initialisierung */
        async function initializeMultiMap() {
            try {
                leafletMap = L.map('map', {
                    attributionControl: false,
                    keyboard: true,
                    tap: true,
                    maxBoundsViscosity: 1.0,
                    zoomSnap: 0.5, // Feinere Zoom-Schritte
                    zoomControl: false // Disable default zoom control
                }).setView([51.16, 10.45], 6);

                // Add custom zoom control to topleft (position will be overridden by CSS)
                L.control.zoom({ position: 'topleft' }).addTo(leafletMap);

                const germanBounds = [
                    [47.0, 5.0],
                    [55.5, 16.0]
                ];
                leafletMap.setMaxBounds(germanBounds);

                L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                    maxZoom: 19,
                    minZoom: 5,
                    attribution: '&copy; OpenStreetMap & CARTO',
                    crossOrigin: true
                }).addTo(leafletMap);

                const loader = document.getElementById('loader');
                loader.setAttribute('role', 'status');
                loader.setAttribute('aria-live', 'assertive');

                const wfsUrl = 'https://sgx.geodatenzentrum.de/wfs_vg250';
                const params = new URLSearchParams({
                    SERVICE: 'WFS',
                    VERSION: '2.0.0',
                    REQUEST: 'GetFeature',
                    TYPENAMES: 'vg250:vg250_krs',
                    OUTPUTFORMAT: 'application/json',
                    SRSNAME: 'urn:ogc:def:crs:EPSG::4326'
                });

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);

                const response = await fetch(`${wfsUrl}?${params.toString()}`, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                loader.style.display = 'none';
                allFeaturesData = data.features;

                // Wichtig: Erst Tabelle initialisieren
                initializeRegionsTable(allFeaturesData);

                // Dann GeoJSON-Layer erstellen
                geojsonLayer = L.geoJSON(data, {
                    style: CONFIG.mapStyles.default,
                    onEachFeature: onEachFeature
                }).addTo(leafletMap);

                // Dann explizit die Layer mit objIDs verkn√ºpfen
                // Dieser Block ist nicht mehr notwendig, da objIdToLayerMap bereits in onEachFeature gef√ºllt wird
                // for (const key in districtData) {
                //     if (key === 'nameIndex') continue;

                //     const entry = districtData[key];
                //     if (entry.objid && entry.layer) {
                //         objIdToLayerMap.set(entry.objid, entry.layer);
                //     }
                // }

                // NEU: Hover-Info-Popup initialisieren
                initializeHoverInfoPopup();

                // Farbpicker initialisieren
                initializeColorPicker();

                // NEU: Event-Handler f√ºr Karten-Bewegung hinzuf√ºgen
                leafletMap.on('moveend zoomend', updateInfoboxPositionsOnMapMove);

                const allDistrictNames = nameToKeysMap.size;
                currentSystemPrompt = baseSystemPrompt;

                setupMobileResponsive();

                // Initialisiere die Vertriebsbezirks-Checkboxen (leer, da noch nichts markiert)
                populateSalesDistrictCheckboxes();

                // NEU: Initial die Regionen einf√§rben, nachdem alles geladen ist
                applyRegionColoring();

                // OPTIMIERT: Screenreader-Announcement f√ºr erfolgreiche Kartenladung
                announceForScreenReader("Karte erfolgreich geladen. Sie k√∂nnen jetzt mit den Regionen interagieren.");

            } catch (error) {
                console.error(`Initialisierungsfehler: ${error.message}`);
                const loader = document.getElementById('loader');
                if (loader) {
                    loader.innerHTML = `<div class="loader-content">
                        <div style="color: #ef4444; font-weight: bold;">‚ùå Fehler beim Laden der Geodaten</div>
                        <div style="font-size: 0.8em;">${error.name === 'AbortError' ? 'Zeit√ºberschreitung bei der Anfrage.' : error.message}</div>
                        <button onclick="window.location.reload()" style="padding: 8px 16px; margin-top: 10px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">Neu laden</button>
                    </div>`;
                }
            }
        }

        /* Initialisierung der Regionstabelle */
        function initializeRegionsTable(features) {
            // Leere die vorhandenen Datenstrukturen
            regionsTable = [];
            objIdToLayerMap.clear();
            nameToRegionsMap.clear();
            normalizedNameMap.clear();

            try {
                features.forEach(feature => {
                    if (feature.properties && feature.properties.gen) {
                        const regionName = feature.properties.gen.trim();
                        const bezType = feature.properties.bez || "Unbekannt";
                        const objid = feature.properties.objid; // Hier ist es korrekt

                        // Erstelle Regionseintrag
                        const regionEntry = {
                            objid: objid,
                            name: regionName,
                            type: bezType, // Korrigiert: bezType verwenden
                            properties: feature.properties
                        };

                        // In Tabelle speichern
                        regionsTable.push(regionEntry);

                        // Nach Namen indizieren f√ºr schnelle Suche
                        if (!nameToRegionsMap.has(regionName)) {
                            nameToRegionsMap.set(regionName, []);
                        }
                        nameToRegionsMap.get(regionName).push(regionEntry);

                        // Normalisierter Namensindex f√ºr verbesserte Suche
                        const normalizedName = normalizeRegionName(regionName);
                        if (!normalizedNameMap.has(normalizedName)) {
                            normalizedNameMap.set(normalizedName, []);
                        }
                        normalizedNameMap.get(normalizedName).push(regionEntry);
                    }
                });
            } catch (error) {
                console.error(`Fehler bei der Initialisierung der Regionstabelle: ${error.message}`);
            }
        }

        /* Event Listeners Setup */
        // OPTIMIERT: Event-Listener direkt registrieren
        DOM.questionInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });

        document.addEventListener('keydown', (event) => {
            // Angepasst f√ºr Tablet-Querformat
            if (event.key === 'Escape' && window.innerWidth <= 1024) {
                if (DOM.sidebar.classList.contains('active')) { // OPTIMIERT: CSS-Klasse verwenden
                    DOM.sidebar.classList.remove('active'); // OPTIMIERT: CSS-Klasse verwenden
                    DOM.mobileSidebarToggle.innerHTML = '<span aria-hidden="true">‚â°</span>'; // Change to 'x' // OPTIMIERT: DOM-Referenz nutzen
                    DOM.mobileSidebarToggle.setAttribute('aria-label', '√ñffne Steuerung'); // OPTIMIERT: DOM-Referenz nutzen
                }
            }
        });

        // OPTIMIERT: Event-Listener f√ºr Prompt-Buttons (Event-Delegation)
        DOM.promptButtons.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const promptText = event.target.dataset.prompt;
                if (promptText) {
                    sendPrompt(promptText);
                }
            }
        });

        // OPTIMIERT: Event-Listener f√ºr Haupt-Aktionsbuttons
        DOM.sendButton.addEventListener('click', sendMessage);
        DOM.clearButton.addEventListener('click', clearAllMarkings);

        // OPTIMIERT: Event-Listener f√ºr Storage-Buttons
        DOM.saveDataButton.addEventListener('click', saveMarkings);
        DOM.loadDataButton.addEventListener('click', loadMarkings);

        // OPTIMIERT: Event-Listener f√ºr Edit-Dialog Buttons
        DOM.addEntryButton.addEventListener('click', showAddEntryForm);
        DOM.closeEditDialogButton.addEventListener('click', closeEditDialog);
        DOM.cancelAddEntryButton.addEventListener('click', cancelAddEntry);

        // WICHTIGE √ÑNDERUNGEN HIER:
        // 1. Der Event-Listener f√ºr das Overlay ruft nun die generische Funktion auf.
        DOM.dialogOverlay.addEventListener('click', closeAnyOpenDialogs);
         // 2. Der "Schlie√üen"-Button des Vertriebsbezirks-Detail-Popups ruft ebenfalls die generische Funktion auf.
        DOM.closeSalesDistrictDetailPopupButton.addEventListener('click', closeAnyOpenDialogs);

        // NEU: Event-listener f√ºr die Liste der Vertriebseintr√§ge (Event-Delegation)
        // OPTIMIERT: Behebung des Fehlers beim L√∂schen/Bearbeiten von Eintr√§gen
        DOM.salesEntriesList.addEventListener('click', (event) => {
            const target = event.target;
            const entryId = target.dataset.entryId;

            if (entryId) {
                if (target.classList.contains('btn-edit-entry')) {
                    editEntry(entryId);
                } else if (target.classList.contains('btn-delete-entry')) {
                    deleteEntry(entryId);
                }
            }
        });


        /* Event-Listener f√ºr Modellauswahl-√Ñnderungen */
        DOM.modelSelector.addEventListener('change', (e) => { // OPTIMIERT: Event-Listener direkt registrieren
            const selectedModel = document.querySelector('input[name="model"]:checked').value;
            if (selectedModel === 'openai') {
                DOM.openaiKeyContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.geminiKeyContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            } else {
                DOM.openaiKeyContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.geminiKeyContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            }
        });

        // NEU: Event-listener f√ºr Vertriebsgruppen-Filter
        DOM.salesGroupFilter.addEventListener('change', function() { // OPTIMIERT: Event-Listener direkt registrieren
            applyRegionColoring(); // Wende die Farben basierend auf dem neuen Filter an
        });

        // NEU: Event-listener f√ºr Vertriebsbezirks-Filter-Suche
        DOM.salesDistrictFilterSearch.addEventListener('input', populateSalesDistrictCheckboxes); // OPTIMIERT: Event-Listener direkt registrieren

        // NEU: Event-listener f√ºr "Alle ausw√§hlen" Button
        DOM.selectAllDistrictsButton.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
            selectedSalesDistricts.clear(); // Explizite Auswahl l√∂schen
            isFilterActive = false; // Zur√ºck zum impliziten "alle anzeigen" Modus
            updateAllDisplays();
        });

        // NEU: Event-listener f√ºr "Alle abw√§hlen" Button
        DOM.deselectAllDistrictsButton.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
            selectedSalesDistricts.clear(); // Explizite Auswahl l√∂schen
            isFilterActive = true; // Filter aktivieren, aber nichts ist ausgew√§hlt, also nichts anzeigen
            updateAllDisplays();
        });

        // NEW: Event listener for welcome message truncation
        if (DOM.welcomeMessageContainer && DOM.readMoreBtn) {
            DOM.readMoreBtn.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
                DOM.welcomeMessageContainer.classList.toggle('expanded');
                if (DOM.welcomeMessageContainer.classList.contains('expanded')) {
                    DOM.readMoreBtn.textContent = 'Weniger anzeigen';
                } else {
                    DOM.readMoreBtn.textContent = 'Weiter lesen';
                }
            });
        }

        // NEW: Event listener for contact info toggle and DSGVO truncation
        if (DOM.toggleContactBtn && DOM.contactInfoContainer && DOM.dsgvoContentContainer && DOM.readMoreDsgvoBtn) {
            // Split the DSGVO text
            const markerIndex = FULL_DSGVO_TEXT_RAW.indexOf(DSGVO_TRUNCATION_MARKER);
            if (markerIndex !== -1) {
                // MODIFIED: Adjust substring logic to hide the marker and everything after it initially
                truncatedDsgvoContent = FULL_DSGVO_TEXT_RAW.substring(0, markerIndex).trim();
                expandedDsgvoContent = FULL_DSGVO_TEXT_RAW.substring(markerIndex).trim();
            } else {
                truncatedDsgvoContent = FULL_DSGVO_TEXT_RAW;
                expandedDsgvoContent = ''; // No expansion possible if marker not found
            }

            // Convert newlines to <br> for HTML display
            truncatedDsgvoContent = truncatedDsgvoContent.trim().replace(/\n/g, '<br>');
            expandedDsgvoContent = expandedDsgvoContent.trim().replace(/\n/g, '<br>');

            // Initial setup for DSGVO content (hidden by default with contact container)
            DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent;
            if (expandedDsgvoContent) {
                DOM.readMoreDsgvoBtn.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.readMoreDsgvoBtn.textContent = 'Weiter lesen';
            } else {
                DOM.readMoreDsgvoBtn.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            }

            // Event listener for DSGVO read more button
            DOM.readMoreDsgvoBtn.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
                DOM.dsgvoContentContainer.classList.toggle('expanded');
                if (DOM.dsgvoContentContainer.classList.contains('expanded')) {
                    DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent + expandedDsgvoContent;
                    DOM.readMoreDsgvoBtn.textContent = 'Weniger anzeigen';
                } else {
                    DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent;
                    DOM.readMoreDsgvoBtn.textContent = 'Weiter lesen';
                }
            });

            // Event listener for main contact toggle button
            DOM.toggleContactBtn.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
                if (DOM.contactInfoContainer.classList.contains('hidden')) { // OPTIMIERT: CSS-Klasse verwenden
                    DOM.contactInfoContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                    DOM.toggleContactBtn.textContent = 'DSGVO ausblenden'; // <-- ANPASSUNG: 'DSGVO'
                    // Ensure DSGVO content is initially truncated when container is shown
                    DOM.dsgvoContentContainer.classList.remove('expanded');
                    DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent;
                    if (expandedDsgvoContent) {
                        DOM.readMoreDsgvoBtn.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                        DOM.readMoreDsgvoBtn.textContent = 'Weiter lesen';
                    }
                } else {
                    DOM.contactInfoContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                    DOM.toggleContactBtn.textContent = 'DSGVO'; // <-- ANPASSUNG: 'DSGVO'
                }
            });
        }

        /* Hauptinitialisierung */
        window.addEventListener('load', async () => { // OPTIMIERT: Event-Listener direkt registrieren
            try {
                // Karte initialisieren
                await initializeMultiMap();

                // API-Key und Chat-Interface pr√ºfen
                const selectedModel = sessionStorage.getItem('selected_model');
                if (selectedModel) {
                     const apiKey = sessionStorage.getItem(selectedModel === 'openai' ? 'openai_api_key' : 'gemini_api_key');
                     if(apiKey) {
                        DOM.apiKeySection.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                        DOM.chatInterface.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                        initializeChatInterface();
                     }
                }
            } catch (error) {
                console.error(`Fehler bei der Hauptinitialisierung: ${error.message}`);
                appendErrorMessage("Es ist ein Fehler bei der Initialisierung aufgetreten. Bitte laden Sie die Seite neu.");
            }
        });
        })(); // Ende des IIFE
    </script>
</body>
</html>