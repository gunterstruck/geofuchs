<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Multi-Landkreis KI-Assistent für Deutschland">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://unpkg.com; img-src 'self' data: https://*.basemaps.cartocdn.com https://unpkg.com; connect-src 'self' https://api.openai.com https://generativelanguage.googleapis.com https://sgx.geodatenzentrum.de;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <!-- OPTIMIERT: Zusätzliche Sicherheits-Meta-Tags hinzugefügt -->
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <title>Multi-Landkreis KI-Assistent</title>

    <!-- Leaflet CSS-Bibliothek für interaktive Karten -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        /* Grundlegende Layout-Definitionen */
        html, body {
            margin: 0; padding: 0; height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #020617; /* Removed overflow: hidden; */ color: #e2e8f0;
            font-size: 16px;
            line-height: 1.5;
        }

        :root {
            --color-primary: #0d9488;
            --color-primary-dark: #047857;
            --color-primary-light: #14b8a6;
            --color-secondary: #f59e0b;
            --color-background: #020617;
            --color-background-light: #1e293b;
            --color-background-lighter: #2d3748;
            --color-text: #e2e8f0;
            --color-text-light: #94a3b8;
            --color-text-dark: #333;
            --color-border: #334155;
            --color-error: #ef4444;
            --color-success: #10b981;
            --color-info: #3b82f6;
            --color-warning: #f59e0b;
            --shadow-default: 0 4px 15px rgba(0,0,0,0.3);
            --radius-small: 6px;
            --radius-medium: 8px;
            --radius-large: 12px;
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
        }

        /* Hauptbereich: Karte nimmt gesamten Platz ein, abzüglich Sidebar-Breite */
        .main { height: 100%; margin-right: 420px; }

        /* Karten-Komponenten Styling */
        #map {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            position: relative; /* Wichtig für die Positionierung der Attribution */
        }

/* NEU: Karten-Attribution Styling */
#map-attribution {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 900; /* Unterhalb der Sidebar und anderer Controls, aber über der Karte */
    background: rgba(0, 0, 0, 0.6);
    color: rgba(255, 255, 255, 0.8);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.7em;
    pointer-events: auto; /* Links sind klickbar */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

#map-attribution a {
    color: rgba(255, 255, 255, 0.9);
    text-decoration: none;
}

#map-attribution a:hover {
    text-decoration: underline;
}


        /* Ladeanzeige */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;
            background: rgba(255,255,255,0.95); padding: 30px; border-radius: var(--radius-medium);
            font-size: 1.2em; box-shadow: var(--shadow-default);
            text-align: center; color: var(--color-text-dark);
            border: 2px solid var(--color-primary);
        }

        .loader-content { display: flex; flex-direction: column; align-items: center; gap: 15px; }

        .loader-spinner {
            width: 40px; height: 40px; border: 4px solid #e5e7eb;
            border-top: 4px solid var(--color-primary); border-radius: 50%;
            animation: spin 1s linear infinite;
        }

@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Sidebar Layout */
        .sidebar {
            position: fixed; top: 0; right: 0; width: 420px; height: 100%;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            box-shadow: -4px 0 15px rgba(0, 0, 0, 0.5);
            display: flex; flex-direction: column; padding: 1.5em; box-sizing: border-box;
            z-index: 1001; border-left: 3px solid var(--color-primary);
            overflow-y: auto;
            overflow-x: hidden; /* OPTIMIERT: overflow-x bleibt, da es für die Sidebar-Breite wichtig ist */
        }

        /* API-Schlüssel Sektion */
        #api-key-section {
            background: var(--color-background-light);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 1.5em; margin-bottom: 1em; text-align: center;
        }

        #api-key-section h3 { color: var(--color-primary); margin-top: 0; }

        #api-key-section p { font-size: 0.9em; color: var(--color-text-light); margin: 0.5em 0; }

        #model-selector {
            display: flex; justify-content: center; gap: 15px; margin-bottom: 1em;
        }
        #model-selector label {
            cursor: pointer; padding: 8px 12px; border-radius: var(--radius-small);
            border: 2px solid var(--color-border); transition: all 0.2s;
        }
        #model-selector input[type="radio"] { display: none; }
        #model-selector input[type="radio"]:checked + label {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary-light);
        }

        #model-selector input[type="radio"]:focus-visible + label {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .api-key-input-container { margin: 1em 0; }

        .api-key-input {
            width: 100%; box-sizing: border-box; padding: 10px; border-radius: var(--radius-small);
            border: 2px solid var(--color-border); background: var(--color-background);
            color: var(--color-text); font-size: 0.95em;
        }

        .api-key-input:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        textarea::placeholder { color: #64748b; }

        #saveApiKeyButton {
            width: 100%; padding: 10px;
            background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light));
            color: white; border: none; border-radius: var(--radius-small); cursor: pointer;
            font-weight: bold; transition: all 0.3s ease;
        }

        #saveApiKeyButton:hover { transform: translateY(-1px); box-shadow: 0 4px 15px rgba(13, 148, 136, 0.3); }

        #saveApiKeyButton:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        /* Chat-Interface Styling */
        #chat-interface { display: flex; flex-direction: column; flex-grow: 1; min-height: 0; } /* OPTIMIERT: Initial hidden via JS */

        .success-banner {
            background: linear-gradient(135deg, var(--color-success) 0%, #059669 100%);
            color: white; padding: 0.8em; border-radius: var(--radius-medium); margin-bottom: 1em;
            text-align: center; font-weight: bold; border: 2px solid var(--color-primary-dark);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3); font-size: 0.9em;
        }

        /* ENTFERNT: multi-status-panel Styling */

        .marked-district {
            display: flex; align-items: center; margin: 3px 0; font-size: 0.8em;
            padding: 3px 6px; border-radius: 4px; background: rgba(16, 185, 129, 0.1);
        }

        .marked-district-color {
            width: 10px; height: 10px; border-radius: 50%; margin-right: 6px;
            border: 1px solid #333;
        }

        #title { color: #ffffff; margin-bottom: 0.5em; font-size: 1.2em; }

        #subtitle { color: var(--color-text-light); margin-top: -5px; font-size: 0.85em; }

        /* Prompt-Buttons */
        .prompt-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .prompt-buttons button {
            background: linear-gradient(135deg, #334155, #475569);
            color: #cbd5e1; border: 2px solid #475569; border-radius: var(--radius-small);
            padding: 6px 8px; cursor: pointer; text-align: center; font-size: 0.75em;
            transition: all 0.3s ease; font-weight: 500;
        }

        .prompt-buttons button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .prompt-buttons button:hover {
            background: linear-gradient(135deg, #475569, #64748b);
            border-color: var(--color-primary); transform: translateY(-1px);
        }

        /* Chat-Log und Messaging */
        #chatlog {
            flex: 1; background: linear-gradient(180deg, var(--color-background-light), var(--color-background-lighter));
            border: 2px solid var(--color-border); padding: 8px; overflow-y: auto;
            margin-bottom: 12px; border-radius: var(--radius-small); display: flex; flex-direction: column;
            min-height: 180px;
            scrollbar-width: thin;
            scrollbar-color: var(--color-border) transparent;
        }

        #chatlog::-webkit-scrollbar {
            width: 8px;
        }

        #chatlog::-webkit-scrollbar-track {
            background: transparent;
        }

        #chatlog::-webkit-scrollbar-thumb {
            background-color: var(--color-border);
            border-radius: 4px;
        }

        textarea {
            width: 100%; margin-bottom: 8px; font-size: 0.85em; border-radius: var(--radius-small);
            border: 2px solid var(--color-border); padding: 8px; box-sizing: border-box;
            font-family: inherit;
            background: linear-gradient(135deg, var(--color-background-light), var(--color-background-lighter));
            color: var(--color-text);
            height: 100px; resize: vertical; transition: all 0.3s ease;
        }

        textarea:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        textarea::placeholder { color: #64748b; }

        /* Nachrichtensprechblasen */
        .bubble {
            padding: 6px 10px; margin: 3px 0; border-radius: var(--radius-large); max-width: 94%;
            white-space: pre-wrap; line-height: 1.3; word-break: break-word;
            opacity: 0; transform: translateY(6px); animation: fadeInBubble 0.4s ease forwards;
            font-size: 0.8em;
        }

@keyframes fadeInBubble { to { opacity: 1; transform: translateY(0); } }

        .user {
            background: linear-gradient(135deg, #475569, #64748b);
            color: #ffffff; align-self: flex-end; border-bottom-right-radius: 4px;
        }

        .assistant {
            background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light));
            color: #ffffff; align-self: flex-start; border-bottom-left-radius: 4px;
        }
        /* Styling for content within assistant bubble */
        .assistant h4 {
            color: #ffffff; /* Ensure title is white */
            margin-top: 0;
            margin-bottom: 0.5em;
            font-size: 1em;
        }
        .assistant code {
            background: rgba(0,0,0,0.2); /* Darker background for code */
            border-radius: 3px;
            padding: 2px 4px;
            font-family: monospace;
            color: #ffffff; /* White text for code */
            white-space: nowrap;
        }
        .assistant ul {
            margin: 0.5em 0 0 1em;
            padding: 0;
            list-style-type: disc;
        }
        .assistant li {
            margin-bottom: 0.3em;
        }


        /* Aktions-Buttons */
        .action-buttons-container { display: flex; gap: 6px; margin-bottom: 8px; }

        .action-buttons-container button {
            color: white; border: none; padding: 8px; border-radius: var(--radius-small);
            cursor: pointer; transition: all 0.3s ease; font-weight: bold; font-size: 0.85em;
        }

        .action-buttons-container button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .action-buttons-container button:hover { transform: translateY(-1px); }

        .action-buttons-container button#sendButton {
            flex-grow: 1; background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light));
        }

        .action-buttons-container button#clearButton {
            flex-basis: 70px; background: linear-gradient(135deg, var(--color-error), #dc2626);
        }

        /* Storage-Buttons Container - NEUE POSITION UNTEN RECHTS */
        .storage-buttons-container {
            position: fixed;
            bottom: 40px;
            right: 430px;
            z-index: 1002;
            display: flex;
            gap: 6px;
            width: 280px; /* Added fixed width to ensure enough space */
        }

        .storage-buttons-container button {
            flex: 1;
            color: white;
            border: none;
            padding: 8px;
            border-radius: var(--radius-small);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.85em;
            white-space: nowrap; /* Ensure text stays on one line */
        }

        .storage-buttons-container button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .storage-buttons-container button:hover {
            transform: translateY(-1px);
        }

        .storage-buttons-container button#saveDataButton {
            background: linear-gradient(135deg, var(--color-info), #2563eb);
        }

        .storage-buttons-container button#loadDataButton {
            background: linear-gradient(135deg, var(--color-warning), #d97706);
        }

        /* Footer und Disclaimer */
        #disclaimer {
            color: var(--color-text-light); font-size: 0.65em; text-align: center;
            margin-top: auto; padding-top: 0.8em; line-height: 1.2;
        }

        /* Tipp-Indikator Animation */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding-left: 10px;
        }

        .typing-dot {
            height: 5px; width: 5px; background-color: #ffffff; border-radius: 50%;
            display: inline-block; margin: 0 1px;
            animation: typing-bounce 1.4s infinite ease-in-out both;
        }

        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing-bounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1.2); opacity: 1; }
        }

        /* Assistent Aktions-Buttons */
        .assistant-action-buttons { margin-top: 8px; }

        .assistant-action-buttons button {
            background: rgba(255,255,255,0.2); color: #ffffff; border: 1px solid rgba(255,255,255,0.3);
            padding: 4px 12px; margin-right: 6px; border-radius: 15px; cursor: pointer;
            font-size: 0.75em; transition: all 0.2s ease;
        }

        .assistant-action-buttons button:hover { background: rgba(255,255,255,0.3); }

        .assistant-action-buttons button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border-left: 4px solid var(--color-error);
            color: white;
            padding: 8px 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .info-message {
            background: rgba(59, 130, 246, 0.2);
            border-left: 4px solid var(--color-info);
            color: white;
            padding: 8px 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Responsive Design für kleinere Bildschirme */
        @media screen and (max-width: 1024px) {
            .main {
                margin-right: 0; /* Karte nimmt volle Breite ein */
            }
            .sidebar {
                width: 100%; /* Sidebar nimmt volle Breite ein */
                transform: translateX(100%); /* Standardmäßig ausgeblendet */
                transition: transform 0.3s ease;
            }
            .sidebar.active {
                transform: translateX(0); /* Eingeblendet */
            }

            /* Mobile toggle button for all screens up to 1024px */
            .mobile-toggle {
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 1002;
                background: var(--color-primary);
                color: white;
                border: none;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex; /* OPTIMIERT: Removed !important */
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

            .storage-buttons-container {
                right: 10px;
                width: calc(100% - 20px); /* Adjust width for mobile */
            }
        }

        /* OPTIMIERT: Styling für die Vertriebsdaten-Anzeige */
        .sales-data {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px dotted rgba(255, 255, 255, 0.2);
            font-size: 0.85em;
        }

        .sales-data-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .sales-data-label {
            color: var(--color-text-light);
        }

        .sales-data-value {
            font-weight: bold;
        }

        /* Dialog zum Bearbeiten der Vertriebsdaten - ERWEITERT FÜR MEHRERE EINTRÄGE */
        .edit-sales-dialog {
            position: fixed;
            top: 5%;
            left: 3%;
            transform: translate(0%, 0%);
            background: var(--color-background-light);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 16px;
            box-shadow: var(--shadow-default);
            z-index: 2000;
            width: 350px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .edit-sales-dialog h3 {
            color: var(--color-primary);
            margin-top: 0;
            margin-bottom: 12px;
            text-align: center;
        }

        .edit-sales-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 0.85em;
            color: var(--color-text-light);
        }

        .form-group input {
            padding: 8px;
            border-radius: var(--radius-small);
            border: 1px solid var(--color-border);
            background: var(--color-background);
            color: var(--color-text);
        }

        .dialog-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 16px;
        }

        .dialog-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .btn-save {
            background: var(--color-primary);
            color: white;
        }

        .btn-cancel {
            background: var(--color-background-lighter);
            color: var(--color-text-light);
            border: 1px solid var(--color-border) !important;
        }

        .btn-save:hover, .btn-cancel:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .edit-button {
            background: rgba(59, 130, 246, 0.2);
            color: white;
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 4px;
            padding: 2px 6px;
            margin-left: 6px;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-button:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
        }

        /* NEU: Hover-Info-Popup Styling */
        .hover-info-popup {
            position: absolute;
            background: white;
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 10px;
            box-shadow: var(--shadow-default);
            z-index: 1500;
            max-width: 300px; /* GEÄNDERT: Breiter für mehr Inhalt */
            pointer-events: none;
            color: var(--color-text-dark);
            font-size: 11px;
            opacity: 0;
            transform: translateY(-5px);
            transition: opacity 0.2s, transform 0.2s;
        }

        .hover-info-popup.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .hover-info-title {
            font-weight: bold;
            color: var(--color-primary);
            margin-bottom: 5px;
            border-bottom: 1px solid var(--color-primary);
            padding-bottom: 3px;
        }

        .hover-info-content {
            margin-top: 5px;
            max-height: 200px; /* HINZUGEFÜGT: Maximale Höhe mit Scrollbar */
            overflow-y: auto;
        }

        .hover-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }

        .hover-info-label {
            color: var(--color-text-dark); /* GEÄNDERT: Opacity entfernt */
            /* opacity: 0.7; */ /* ENTFERNT */
            font-size: 10px;
        }

        .hover-info-value {
            font-weight: bold;
            font-size: 10px;
        }

        /* HINZUGEFÜGT: Styling für die Liste der Vertriebsbezirke */
        .sales-districts-list {
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px dotted #ccc;
            font-size: 10px;
        }

        .sales-district-item {
            padding: 3px 5px;
            margin-bottom: 2px;
            border-radius: 3px;
            background-color: rgba(13, 148, 136, 0.1);
        }

        .hover-info-footer {
            font-size: 9px;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px dotted #ccc;
            color: var(--color-info);
            text-align: center;
        }

        /* OPTIMIERT: Farb-Auswahl für den Bearbeitungsdialog */
        .color-picker-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 5px;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 0 2px var(--color-primary);
        }

        /* GEÄNDERT: Styling für Vertriebsbezirk Infoboxen (Kompakte Ansicht) */
        .sales-district-infobox {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 2px 4px; /* GEÄNDERT: Padding noch weiter reduziert */
            box-shadow: var(--shadow-default);
            width: fit-content;
            white-space: nowrap;
            color: var(--color-text-dark);
            font-size: 11px;
            z-index: 999;
            text-align: center;
            pointer-events: auto;
            cursor: pointer; /* HINZUGEFÜGT: Zeigt an, dass die Box klickbar ist */
            opacity: 0; /* Initial hidden for fade-in */
            transition: all 0.3s ease; /* Fade-in transition */
        }

        /* GEÄNDERT: Keine Hover-Expansion mehr für die kompakte Box */
        .sales-district-infobox:hover {
            transform: scale(1.05); /* Leichter Skalierungseffekt beim Hover */
            border-color: var(--color-primary-light);
        }

        .sales-district-infobox-title {
            font-weight: bold;
            color: var(--color-primary);
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        /* ENTFERNT: Details-Box ist jetzt ein separates Popup, nicht mehr Teil der kompakten Infobox */
        .sales-district-infobox-details {
            display: none; /* WIRD NICHT MEHR VERWENDET, ABER ZUR SICHERHEIT AUSGEBLENDET */
        }

        /* NEU: Styling für das Detail-Popup der Vertriebsbezirke */
        #salesDistrictDetailPopup {
            position: fixed;
            top: 5%;
            left:3%;
            transform: translate(0%, 0%);
            background: var(--color-background-light); /* Dunkler Hintergrund für besseren Kontrast */
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-medium);
            padding: 16px;
            box-shadow: var(--shadow-default);
            z-index: 2000; /* Höher als andere Elemente */
            width: 300px;
            max-width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            color: var(--color-text); /* Heller Text auf dunklem Hintergrund */
            /* display: none; */ /* OPTIMIERT: Initial hidden via JS */
        }

        #salesDistrictDetailPopup h3 {
            color: var(--color-primary);
            margin-top: 0;
            margin-bottom: 12px;
            text-align: center;
        }

        #salesDistrictDetailPopup .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        #salesDistrictDetailPopup .detail-label {
            color: var(--color-text-light); /* Helleres Grau für Labels */
        }

        #salesDistrictDetailPopup .detail-value {
            font-weight: bold;
        }

        #salesDistrictDetailPopup .detail-list {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dotted var(--color-border);
            max-height: 150px;
            overflow-y: auto;
        }

        #salesDistrictDetailPopup .detail-list-item {
            padding: 3px 0;
            font-size: 0.85em;
        }

        #salesDistrictDetailPopup .close-button {
            background: var(--color-error);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            padding: 8px 12px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 15px;
            width: 100%;
            transition: background-color 0.2s;
        }

        #salesDistrictDetailPopup .close-button:hover {
            background: #dc2626;
        }


        /* MODIFIZIERT: Buttons untereinander anordnen */
        .control-buttons-container {
            position: fixed;
            top: 10px; /* Oben Links */
            left: 10px; /* Oben Links */
            right: unset;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: var(--radius-medium);
            justify-content: flex-start;
            /* flex-wrap: Removed as it's a column layout */
        }

        /* Adjust for mobile to prevent overlap with mobile-toggle */
        @media screen and (max-width: 1024px) { /* Angepasst für Tablet-Querformat */
            .control-buttons-container {
                left: 10px;
                top: 10px; /* Unterhalb des mobile-toggle Buttons */
            }
        }

        /* NEU: Leaflet Zoom Control Position (Mitte Links) */
        .leaflet-control-zoom {
            position: fixed !important; /* Überschreibt Leaflet's Standardpositionierung */
            left: 10px !important; /* Abstand vom linken Rand */
            top: 50% !important; /* Vertikal zentriert */
            transform: translateY(-50%) !important; /* Korrektur für exakte Zentrierung */
            z-index: 1000;
        }

        /* NEU: Farblöschung Option für den Bearbeitungsdialog */
        .color-remove-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent; /* Changed from var(--color-border) */
            transition: transform 0.2s, border-color 0.2s;
            background: white;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-remove-option::before,
        .color-remove-option::after {
            content: "";
            position: absolute;
            width: 16px;
            height: 2px;
            background-color: var(--color-error);
        }

        .color-remove-option::before {
            transform: rotate(45deg);
        }

        .color-remove-option::after {
            transform: rotate(-45deg);
        }

        .color-remove-option:hover {
            transform: scale(1.1);
            border-color: var(--color-error);
        }

        .color-remove-option.selected {
            border-color: var(--color-error);
            box-shadow: 0 0 0 2px var(--color-error);
        }

        /* NEU: Styling für die Liste der Vertriebseinträge */
        .sales-entries-list {
            margin-bottom: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .sales-entry-item {
            background: var(--color-background-lighter);
            border-radius: var(--radius-small);
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--color-primary);
        }

        .sales-entry-header {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

.entry-color-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .entry-title {
            flex-grow: 1;
            font-weight: bold;
        }

        .entry-actions {
            display: flex;
            gap: 5px;
        }

        .btn-edit-entry, .btn-delete-entry {
            background: none;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: var(--radius-small);
            padding: 2px 6px;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-edit-entry {
            color: var(--color-info);
        }

        .btn-delete-entry {
            color: var(--color-error);
        }

        .btn-edit-entry:hover, .btn-delete-entry:hover {
            background: rgba(255,255,255,0.1);
        }

        .sales-entry-details {
            font-size: 0.85em;
            color: var(--color-text-light);
            padding-left: 22px;
        }

        .no-entries-message {
            color: var(--color-text-light);
            font-style: italic;
            padding: 10px;
            text-align: center;
        }

        .btn-add-entry {
            background: var(--color-info);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .btn-add-entry:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        /* NEU: Hinzugefügt für Basic Modus */
        .basic-mode-info {
            margin-top: 10px;
            font-size: 0.8em;
            color: var(--color-text-light);
            text-align: center;
            padding: 5px;
        }

        /* NEU: Styling für das Dropdown-Menü */
        .sales-group-filter-container {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--color-background-light);
            padding: 5px 10px;
            border-radius: var(--radius-small);
            border: 1px solid var(--color-border);
        }

        .sales-group-filter-container label {
            color: var(--color-text);
            font-size: 0.85em;
            white-space: nowrap;
        }

        .sales-group-filter-container select {
            background: var(--color-background);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-small);
            padding: 5px 8px;
            font-size: 0.85em;
            cursor: pointer;
            flex-grow: 1;
            min-width: 120px;
        }

        .sales-group-filter-container select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        /* NEU: Styling für Vertriebsbezirksauswahl-Container */
        .sales-district-selection-container {
            background: var(--color-background-light);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-medium);
            padding: 10px;
            margin-top: 10px;
            /* display: none; */ /* OPTIMIERT: Initial hidden via JS */
            flex-direction: column;
            gap: 8px;
        }

        .sales-district-selection-container label {
            color: var(--color-text);
            font-size: 0.9em;
            font-weight: bold;
        }

        .sales-district-selection-container input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            padding: 8px;
            border-radius: var(--radius-small);
            border: 1px solid var(--color-border);
            background: var(--color-background);
            color: var(--color-text);
            font-size: 0.85em;
        }

        .sales-district-selection-container input[type="text"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.3);
        }

        .sales-district-checkboxes {
            max-height: 75px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-small);
            padding: 5px;
            background: var(--color-background);
        }

        .sales-district-checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .sales-district-checkbox-item:last-child {
            margin-bottom: 0;
        }

        .sales-district-checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .sales-district-checkbox-item label {
            font-size: 0.85em;
            color: var(--color-text);
            flex-grow: 1;
            cursor: pointer;
        }

        .sales-district-buttons {
            display: flex;
            gap: 8px;
        }

        .sales-district-buttons button {
            flex-grow: 1;
            padding: 8px;
            border: none;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.2s;
            background: var(--color-primary);
            color: white;
        }

        .sales-district-buttons button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .sales-district-buttons button#deselectAllDistricts {
            background: var(--color-background-lighter);
            color: var(--color-text-light);
            border: 1px solid var(--color-border);
        }
        .sales-district-buttons button#deselectAllDistricts:hover {
            background: #334155;
        }

        /* Custom Toggle Switch Styling */
        .sales-district-toggle {
            position: relative;
            display: inline-block;
            width: 40px; /* Width of the toggle */
            height: 24px; /* Height of the toggle */
            vertical-align: middle; /* Align with text */
            /* margin-left: 10px; Removed, handled by flex container */
        }

        .sales-district-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .sales-district-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--color-border); /* Off state background */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 24px; /* Rounded corners for slider track */
        }

        .sales-district-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px; /* Height of the knob */
            width: 16px; /* Width of the knob */
            left: 4px;
            bottom: 4px;
            background-color: white; /* Knob color */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%; /* Make knob round */
        }

        .sales-district-toggle input:checked + .sales-district-toggle-slider {
            background-color: var(--color-primary); /* On state background */
        }

        .sales-district-toggle input:focus + .sales-district-toggle-slider {
            box-shadow: 0 0 1px var(--color-primary);
        }

        .sales-district-toggle input:checked + .sales-district-toggle-slider:before {
            -webkit-transform: translateX(16px); /* Move knob to the right */
            -ms-transform: translateX(16px);
            transform: translateX(16px);
        }

        /* Adjust the container for the toggles */
        .sales-district-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between; /* To push the toggle to the right */
            width: 100%; /* Ensure it takes full width of its parent */
        }

        /* Custom styles for welcome message truncation */
        .truncated-welcome-message {
            max-height: 4.5em; /* Approximately 3 lines for 1.5em line-height */
            overflow: hidden;
            position: relative;
            transition: max-height 0.5s ease-out;
            margin-bottom: 0.5em; /* Adjust spacing */
            text-align: center; /* Ensure text aligns center */
        }
        .truncated-welcome-message.expanded {
            max-height: 500px; /* Sufficiently large to show full content */
            overflow: visible;
        }
        .read-more-button {
            background: none;
            border: none;
            color: var(--color-primary-light);
            cursor: pointer;
            font-size: 0.9em;
            padding: 5px 0;
            text-align: center;
            width: 100%;
            display: block;
            margin-top: 5px;
            transition: color 0.2s ease;
        }
        .read-more-button:hover {
            color: var(--color-primary);
        }
        .read-more-button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        /* Custom styles for contact button */
        .toggle-contact-button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, var(--color-info), #2563eb);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin-top: 1em; /* Space above button */
        }
        .toggle-contact-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        .toggle-contact-button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        /* NEW: Custom styles for DSGVO truncation */
        .truncated-dsgvo-message {
            max-height: 20em; /* ADJUSTED: Increased to fit more content initially */
            overflow: hidden;
            position: relative;
            transition: max-height 0.5s ease-out;
            margin-top: 1em; /* Space from contact info */
            font-size: 0.8em;
            color: var(--color-text-light);
            text-align: left;
            margin-bottom: 0; /* HINZUGEFÜGT: Entfernt zusätzlichen Abstand nach unten */
        }
        .truncated-dsgvo-message.expanded {
            max-height: none; /* Sufficiently large to show full content */
            overflow: visible;
        }
        /* ... andere Stile ... */
        #readMoreDsgvoBtn {
            margin-top: 10px; /* ADJUSTED: Changed from negative to positive margin */
        }

        /* OPTIMIERT: Hidden utility class */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- HTML-Struktur: Hauptcontainer -->
    <main class="main" id="mainContent">
        <button class="mobile-toggle" id="mobileSidebarToggle" aria-label="Öffne Steuerung" style="display: none;">
            <span aria-hidden="true">≡</span>
        </button>

        <div id="map" aria-label="Interaktive Deutschlandkarte" role="application">
            <!-- Ladeanzeige während Karteninitialisierung -->
            <div id="loader" role="status" aria-live="polite">
                <div class="loader-content">
                    <div class="loader-spinner" aria-label="Lade Daten"></div>
                    <div>Multi-Landkreis KI-System wird geladen...</div>
                    <div style="font-size: 0.8em; color: #666;">Intelligente Mehrfachmarkierung von Regionen</div>
                </div>
            </div>
<!-- NEU: Karten-Attribution -->
<div id="map-attribution">
  Daten © <a href="https://www.openstreetmap.org/copyright"
             target="_blank" rel="noopener">OpenStreetMap-Mitwirkende</a> •
  Tiles © <a href="https://carto.com/attribution"
             target="_blank" rel="noopener">CARTO</a>
</div>
        </div>

        <!-- OPTIMIERT: Verbesserte Strukturierung mit zusätzlichen ARIA-Attributen -->
        <div class="control-buttons-container" role="region" aria-label="Kartensteuerung">
            <div class="sales-district-toggle-container">
                <span id="vertriebsinfo-label" style="color: white;">Vertriebsbezirke</span>
                <!-- OPTIMIERT: Explicit label mit aria-labelledby für bessere Zugänglichkeit -->
                <label class="sales-district-toggle" title="Schaltet die Anzeige von Vertriebsbezirks-Infoboxen auf der Karte ein/aus. (Sichtbar ab Zoom-Stufe 8)">
                    <input type="checkbox" id="salesDistrictToggle" aria-labelledby="vertriebsinfo-label">
                    <span class="sales-district-toggle-slider"></span>
                </label>
            </div>
            <!-- NEUER TOGGLE HIER EINGEFÜGT -->
            <div class="sales-district-toggle-container">
                <span id="revenue-coloring-label" style="color: white;">Färbung: Höchster Umsatz</span>
                <label class="sales-district-toggle" title="Zeigt die Farbe des umsatzstärksten Vertriebsbezirkes in dieser Region an.">
                    <input type="checkbox" id="revenueColoringToggle" aria-labelledby="revenue-coloring-label">
                    <span class="sales-district-toggle-slider"></span>
                </label>
            </div>
            <!-- NEU: Dropdown für Vertriebsgruppen-Filter -->
            <div class="sales-group-filter-container">
                <label for="salesGroupFilter">Gruppe:</label>
                <select id="salesGroupFilter" aria-label="Filter nach Vertriebsgruppe">
                    <option value="">Alle Gruppen</option>
                    <!-- Optionen werden dynamisch hinzugefügt -->
                </select>
            </div>
        </div>

        <!-- OPTIMIERT: Verbesserte Beschreibungen und ARIA-Attributen -->
        <div class="storage-buttons-container" role="region" aria-label="Datenverwaltung">
            <button id="saveDataButton" aria-label="Aktuelle Markierungen und Daten speichern">
                💾 Daten speichern
            </button>
            <button id="loadDataButton" aria-label="Gespeicherte Markierungen und Daten laden">
                📂 Daten laden
            </button>
        </div>

        <!-- OPTIMIERT: Hover-Info-Popup mit besserer Semantik -->
        <div id="hoverInfoPopup" class="hover-info-popup" role="tooltip">
            <div class="hover-info-title">Regionsinformation</div>
            <div class="hover-info-content" id="hoverInfoContent"></div>
            <div class="hover-info-footer">Klick zum Bearbeiten</div>
        </div>

        <!-- NEU: Detail-Popup für Vertriebsbezirke -->
        <div id="salesDistrictDetailPopup" class="hidden" role="dialog" aria-modal="true" aria-labelledby="sales-detail-title">
            <h3 id="sales-detail-title">Vertriebsbezirk Details</h3>
            <div class="detail-row">
                <span class="detail-label">Vertriebsbezirk:</span>
                <span class="detail-value" id="detailDistrict"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Vertriebsgruppe:</span>
                <span class="detail-value" id="detailGroup"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Gesamtumsatz:</span>
                <span class="detail-value" id="detailRevenue"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Anzahl Regionen:</span>
                <span class="detail-value" id="detailRegionCount"></span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Anzahl Einträge:</span>
                <span class="detail-value" id="detailEntryCount"></span>
            </div>
            <div class="detail-list">
                <h4>zugeordnete Regionen:</h4>
                <ul id="detailRegionList">
                    <!-- Regionen werden hier dynamisch eingefügt -->
                </ul>
            </div>
            <button class="close-button" id="closeSalesDistrictDetailPopupButton">Schließen</button>
        </div>
    </main>

    <!-- OPTIMIERT: Sidebar mit verbesserter Semantik und Accessibility -->
    <aside class="sidebar" id="sidebar" role="complementary" aria-label="KI-Assistent Steuerung">
        <!-- API-Schlüssel und Modellauswahl Sektion -->
        <section id="api-key-section" aria-labelledby="api-key-title">
            <h2 id="app-title" style="color: var(--color-primary); margin-top: 0; margin-bottom: 0.2em; font-size: 1.5em;">
                🌍 GeoFuchs 🦊
            </h2>
            <p style="font-size: 0.7em; color: var(--color-text-light); margin-top: 0; margin-bottom: 1em;">V1.5 2025</p>
            <h3 id="api-key-title" style="font-size: 1.2em;">🔐 KI-Modell & API-Schlüssel</h3>

            <!-- Truncated welcome message -->
            <p id="welcomeMessageContainer" class="truncated-welcome-message">
                Willkommen bei **GeoFuchs**, Ihrem intelligenten Multi-Landkreis KI-Assistenten für interaktive Karten.
                Diese Anwendung ermöglicht es Ihnen, Regionen in Deutschland basierend auf Ihren Anfragen zu markieren,
                zu analysieren und mit Vertriebsdaten zu verwalten. Nutzen Sie die KI-Funktionen, um komplexe
                geografische Analysen durchzuführen oder verwalten Sie Ihre Daten im Basic-Modus.
                Bitte geben Sie Ihren API-Schlüssel ein, um die volle Funktionalität der KI-Modelle zu nutzen.
            </p>
            <button id="readMoreBtn" class="read-more-button">Weiter lesen</button>
            <!-- End truncated welcome message -->

            <!-- OPTIMIERT: Radio-Button Auswahl mit verbesserten ARIA-Attributen -->
            <div id="model-selector" role="radiogroup" aria-label="KI-Modell Auswahl">
                <input type="radio" id="model-openai" name="model" value="openai" checked>
                <label for="model-openai">OpenAI GPT-4.1</label>

                <input type="radio" id="model-gemini" name="model" value="gemini">
                <label for="model-gemini">Google Gemini 2.5 Pro</label>
            </div>

            <!-- OPTIMIERT: API-Schlüssel Eingabefelder mit verbesserten Validierungsattributen -->
            <div id="openai-key-container" class="api-key-input-container">
                 <!-- OPTIMIERT: Hinzugefügtes pattern für HTML5-Formvalidierung -->
                 <input type="password" id="openaiApiKeyInput" class="api-key-input"
                        placeholder="OpenAI Key (sk-...)"
                        aria-label="OpenAI API Schlüssel"
                        autocomplete="off"
                        pattern="sk-[a-zA-Z0-9]{32,}"
                        title="Der OpenAI Schlüssel muss mit 'sk-' beginnen, gefolgt von mindestens 32 Zeichen">
                 <!-- Validierungsnachricht -->
                 <p class="input-validation-message" id="openai-validation-message" aria-live="polite"></p>
            </div>
            <div id="gemini-key-container" class="api-key-input-container hidden">
                 <!-- OPTIMIERT: Hinzugefügtes minlength für HTML5-Formvalidierung -->
                 <input type="password" id="geminiApiKeyInput" class="api-key-input"
                        placeholder="Google AI Studio Key..."
                        aria-label="Google Gemini API Schlüssel"
                        autocomplete="off"
                        minlength="20"
                        title="Der Google Gemini Schlüssel sollte mindestens 20 Zeichen lang sein">
                 <!-- Validierungsnachricht -->
                 <p class="input-validation-message" id="gemini-validation-message" aria-live="polite"></p>
            </div>

            <!-- OPTIMIERT: Button mit ergänzter ARIA-Beschreibung -->
            <button id="saveApiKeyButton" aria-description="Speichert den eingegebenen API-Schlüssel und aktiviert den KI-Assistenten">
                Schlüssel speichern & starten
            </button>
            <p style="font-size: 0.75em; margin-top: 1em;">Der Schlüssel wird nur in dieser Sitzung gespeichert.</p>
            <!-- Hinzugefügte Zeile -->
            <p style="font-size: 0.75em; color: var(--color-warning); margin-top: 0.5em; font-weight: bold;">
                Achtung: Nur Daten die den Status "CO - Frei verwendbar" haben sind erlaubt.
            </p>

            <!-- NEU: Hinweis für Basic-Modus -->
            <div class="basic-mode-info">
               ℹ️ Sie können auch ohne API-Schlüssel Regionen bearbeiten und Daten speichern/laden.
            </div>

            <!-- Optimaler Eingabehinweis wurde hier entfernt und wird nun dynamisch im Chatlog angezeigt -->

            <!-- Contact info -->
            <button id="toggleContactBtn" class="toggle-contact-button">DSGVO</button>
            <div id="contactInfoContainer" class="hidden" style="margin-top: 1.5em;">
<p style="font-size: 0.8em; color: var(--color-text-light); text-align: left; margin-top: 0;">
  Günter Struck<br>
 Lönsberg 8<br>
  45136 Essen, Deutschland<br>
  E-Mail: <a href="mailto:geofuchs@online.de" style="color: var(--color-primary); text-decoration: none;">geofuchs@online.de</a>
</p>

<p style="font-size: 0.8em; color: var(--color-text-light); text-align: left;">
🔗 Website: 
  <a href="https://gunterstruck.github.io/geofuchs/" target="_blank" rel="noopener" style="color: var(--color-primary);">gunterstruck.github.io/geofuchs</a><br>
💻 Code & Issues: 
  <a href="https://github.com/gunterstruck/geofuchs" target="_blank" rel="noopener" style="color: var(--color-primary);">GitHub-Repository</a><br>
📜 Datenschutzerklärung:
<a href="https://gunterstruck.github.io/geofuchs/datenschutz.html" target="_blank" rel="noopener" style="color: var(--color-primary);">ansehen</a><br>
🪪 Lizenz:
<a href="https://gunterstruck.github.io/geofuchs/license.html" target="_blank" rel="noopener" style="color: var(--color-primary);">MIT-Lizenz</a>
</p>



<p style="font-size: 0.75em; color:#94a3b8; text-align:left;">
  <em>Projektstatus:</em> privates, nicht-kommerzielles MVP. Keine Gewähr; Nutzung auf eigene Verantwortung.
</p>


                </p>
                <!-- NEW DSGVO Content below -->
                <div id="dsgvoContentContainer" class="truncated-dsgvo-message">
                    <!-- DSGVO content will be injected here by JS -->
                </div>
                <button id="readMoreDsgvoBtn" class="read-more-button hidden">Weiter lesen</button>
            </div>
            <!-- End contact info -->
        </section>

        <!-- NEU: Vertriebsbezirksauswahl-Container -->
        <div class="sales-district-selection-container hidden" id="salesDistrictSelectionContainer">
            <label for="salesDistrictFilterSearch">Vertriebsbezirke filtern:</label>
            <input type="text" id="salesDistrictFilterSearch" placeholder="Bezirk suchen..." aria-label="Vertriebsbezirk suchen">
            <div id="salesDistrictCheckboxes" class="sales-district-checkboxes" role="group" aria-label="Vertriebsbezirke auswählen">
                <!-- Checkboxen werden hier dynamisch hinzugefügt -->
            </div>
            <div class="sales-district-buttons">
                <button id="selectAllDistricts" aria-label="Alle Vertriebsbezirke auswählen">Alle auswählen</button>
                <button id="deselectAllDistricts" aria-label="Alle Vertriebsbezirke abwählen">Alle abwählen</button>
            </div>
        </div>

        <!-- OPTIMIERT: Chat-interface mit verbesserten ARIA-Attributen -->
        <div id="chat-interface" class="hidden" role="region" aria-labelledby="title">
            <!-- Erfolgsbanner -->
            <div class="success-banner" id="successBanner" role="status" aria-live="polite"></div>

            <!-- Titel und Beschreibung -->
            <header>
                <h2 id="title">🗺️ Multi-Landkreis KI-Assistent</h2>
                <p id="subtitle">Intelligente Mehrfachmarkierung von Regionen</p>
            </header>

            <!-- OPTIMIERT: Vordefinierte Prompt-Buttons mit verbesserten ARIA-Attributen -->
            <div class="prompt-buttons" id="promptButtons" aria-label="Vordefinierte Anfragen">
                <button data-prompt="Markiere Berlin rot" aria-label="Berlin in rot markieren">
                    🎯 Berlin mit Rot markieren
                </button>
                <!-- NEUE PROMPT BUTTONS -->
                <button data-prompt="Analysiere H30L" aria-label="H30L analysieren">
                    💰 Vertriebsbezirk (Beispiel:) H30L analysieren
                </button>
                <button data-prompt="Top 5 Regionen nach Umsatz" aria-label="Top Regionen anzeigen">
                    🏆 Top Regionen zeigen
                </button>
                <button data-prompt="Analyse Vertriebsgruppe [Vertriebsgruppe: z.B. ISL3]" aria-label="Vertriebsgruppe ISL3 analysieren">
                    📊 Infos Vertriebsgruppe ISL3
                <!-- HIER IST DER NEUE BUTTON, DER DIE KI ANWEIST, DAS BENUTZERFREUNDLICHE FORMAT ZU ERKLÄREN -->
                <button data-prompt="Erkläre dem Nutzer, wie er Daten direkt im KI-Chatfenster eingeben kann, um Markierungen vorzunehmen. Zeige ein Beispiel in Tabellenform mit den Spalten 'action', 'region', 'regionType', 'color', 'salesGroup', 'salesDistrict', und 'revenue'. Beschreibe die Bedeutung jedes Feldes. Betone, dass die KI diese strukturierten Eingaben direkt verarbeiten und die entsprechenden Aktionen ausführen wird. Vermeide jegliche Erwähnung von JSON, Skripten, Importprozessen oder anderen technischen Backend-Details." aria-label="Optimales Format für Info-Eingabe im Chat erklären">
                    📝 Zeige mir das optimale Format um Daten einzufügen
                </button>
                <button data-prompt="Lösche alle Markierungen" aria-label="Alle Markierungen löschen">
                    🗑️ Alles löschen
                </button>
            </div>

            <!-- OPTIMIERT: Chat-Verlauf Container mit verbesserten ARIA-Attributen -->
            <div id="chatlog" role="log" aria-live="polite" aria-label="Chat-Verlauf"></div>

            <!-- OPTIMIERT: Texteingabefeld mit explizitem Label -->
            <label for="question" class="sr-only">Ihre Anfrage an den KI-Assistenten</label>
            <textarea id="question"
                      placeholder="Fragen Sie mich: 'Markiere Baden-Württemberg rot', 'Markiere Frankfurt am Main blau'..."
                      aria-label="Ihre Anfrage an den KI-Assistenten"></textarea>

            <!-- OPTIMIERT: Haupt-Aktionsbuttons mit verbesserten ARIA-Attributen -->
            <div class="action-buttons-container">
                <button id="sendButton" aria-label="Nachricht senden">Senden</button>
                <button id="clearButton" aria-label="Alle Markierungen löschen">🔄 Löschen</button>
            </div>

            <!-- Disclaimer-Text -->
<footer id="disclaimer">
  🤖 KI-gesteuerte Mehrfachmarkierung • Der Assistent kann Fehler machen<br>
  <a href="https://gunterstruck.github.io/geofuchs/" target="_blank" style="color: var(--color-text-light); text-decoration: underline;">Homepage</a>
  &nbsp;•&nbsp;
  <a href="https://gunterstruck.github.io/geofuchs/datenschutz" target="_blank" style="color: var(--color-text-light); text-decoration: underline;">Datenschutzerklärung</a>
  &nbsp;•&nbsp;
  <a href="https://gunterstruck.github.io/geofuchs/LICENSE" target="_blank" style="color: var(--color-text-light); text-decoration: underline;">MIT-Lizenz</a>
  &nbsp;•&nbsp;
  <a href="https://github.com/gunterstruck/geofuchs.github.io" target="_blank" rel="noopener" style="color: var(--color-text-light); text-decoration: underline;">GitHub</a>
</footer>
        </div>
    </aside>

    <!-- OPTIMIERT: Dialog zum Bearbeiten mit verbesserten ARIA-Attributen -->
    <div id="editSalesDialog" class="edit-sales-dialog hidden" role="dialog" aria-labelledby="edit-dialog-title" aria-modal="true">
        <h3 id="edit-dialog-title">Region bearbeiten</h3>

        <!-- OPTIMIERT: Liste mit besserer Semantik -->
        <div id="salesEntriesList" class="sales-entries-list" role="list" aria-label="Vorhandene Vertriebsbezirke">
            <!-- Hier werden die vorhandenen Einträge dynamisch eingefügt -->
        </div>

        <div class="dialog-buttons">
            <button type="button" class="btn-add-entry" id="addEntryButton" aria-label="Neuen Vertriebsbezirk hinzufügen">
                Vertriebsbezirk hinzufügen
            </button>
            <button type="button" class="btn-cancel" id="closeEditDialogButton" aria-label="Dialog schließen">
                Schließen
            </button>
        </div>

        <!-- OPTIMIERT: Formular mit verbesserten Labels und Validierungsattributen -->
        <form id="addEntryForm" class="edit-sales-form hidden">
            <div class="form-group">
                <label for="colorPicker">Farbe:</label>
                <div class="color-picker-container" id="colorPicker" role="radiogroup" aria-labelledby="color-picker-label">
                    <span id="color-picker-label" class="sr-only">Farbauswahl</span>
                    <div class="color-remove-option" id="removeColorOption" title="Farbe löschen" role="radio" aria-label="Farbe löschen"></div>
                    <!-- Farben werden hier dynamisch eingefügt -->
                </div>
            </div>
            <div class="form-group">
                <label for="salesGroupInput">Vertriebsgruppe:</label>
                <input type="text" id="salesGroupInput" placeholder="z.B. Nord oder ISL1"
                       title="Beliebiger Text für die Vertriebsgruppe" aria-describedby="salesGroupHint">
                <span id="salesGroupHint" class="sr-only">Beliebiger Text für die Vertriebsgruppe</span>
            </div>
            <div class="form-group">
                <label for="salesDistrictInput">Vertriebsbezirk:</label>
                <input type="text" id="salesDistrictInput" placeholder="z.B. A1 oder H10A"
                       title="Beliebiger Text für den Vertriebsbezirk" aria-describedby="salesDistrictHint">
                <span id="salesDistrictHint" class="sr-only">Beliebiger Text für den Vertriebsbezirk</span>
            </div>
            <div class="form-group">
                <label for="revenueInput">Umsatz:</label>
                <input type="number" id="revenueInput" placeholder="z.B. 250000" min="0" aria-describedby="revenueHint">
                <span id="revenueHint" class="sr-only">Numerischer Wert ohne Währungszeichen, zum Beispiel 250000</span>
            </div>
            <input type="hidden" id="editingRegionKey">
            <input type="hidden" id="editingEntryId">
            <input type="hidden" id="selectedColor">
            <div class="dialog-buttons">
                <button type="button" class="btn-cancel" id="cancelAddEntryButton" aria-label="Eingabe abbrechen">
                    Abbrechen
                </button>
                <button type="submit" class="btn-save" id="saveEntryButton" aria-label="Vertriebsdaten speichern">
                    Speichern
                </button>
            </div>
        </form>
    </div>
    <div id="dialogOverlay" class="overlay hidden"></div>

    <!-- Externe Bibliotheken -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin="" defer></script>
    <!-- OPTIMIERT: defer-Attribut hinzugefügt -->
    <script defer>
        // OPTIMIERT: Kapselung des gesamten Skripts in ein IIFE
        (function() {
        /* Globale Konfiguration */
        const CONFIG = {
            // Verfügbare Farben für Regionsmarkierungen
            colors: {
                'rot': '#ef4444', 'red': '#ef4444',
                'grün': '#10b981', 'green': '#10b981',
                'blau': '#3b82f6', 'blue': '#3b82f6',
                'gelb': '#f59e0b', 'yellow': '#f59e0b',
                'orange': '#f97316', 'lila': '#8b5cf6', 'purple': '#8b5cf6',
                'türkis': '#0d9488', 'teal': '#0d9488',
                'rosa': '#ec4899', 'pink': '#ec4899',
                'grau': '#6b7280', 'gray': '#6b7280',
                'braun': '#92400e', 'brown': '#92400e',
                'hellblau': '#60a5fa', 'lightblue': '#60a5fa',
                'dunkelgrün': '#166534', 'darkgreen': '#166534',
                'hellgrün': '#86efac', 'lightgreen': '#86efac',
                'default': '#0d9488'
            },

            // Standard-Farbpalette für automatische Zuweisungen
            defaultColors: ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#f97316', '#ec4899', '#0d9488'],

            // Karten-Styling Definitionen
            mapStyles: {
                default: {
                    fillColor: '#e5e7eb',
                    weight: 1,
                    opacity: 1,
                    color: '#6b7280',
                    fillOpacity: 0.6
                }
            }
        };

        /* Globale Variablen */
        let leafletMap, geojsonLayer;
        let allFeaturesData = [];
        let districtData = {};
        // Namensindex für schnellen Zugriff auf Regionen nach Namen
        let nameToKeysMap = new Map();
        let markedDistricts = new Map();
        let colorIndex = 0;
        let currentSystemPrompt = "";
        let conversationHistory = []; // <-- ANPASSUNG: 'let' hinzugefügt

        // NEU: Flagge, um zu verfolgen, ob die Willkommensnachricht bereits angezeigt wurde
        let hasWelcomeMessageBeenShown = false; // <-- Diese Zeile hinzufügen

        // Neue Tabellen-Datenstrukturen
        let regionsTable = [];
        let objIdToLayerMap = new Map();
        let nameToRegionsMap = new Map();

        // Normalisierter Namensindex für verbesserte Suche
        let normalizedNameMap = new Map();

        // NEU: Hover-Info-Popup-Referenzen
        let hoverInfoPopup;
        let currentHoveredLayer = null;

        // NEU: Vertriebsbezirk-Infoboxes
        let salesDistrictInfoboxes = {};
        let showSalesDistrictInfoboxes = false;
        // NEU: Toggle für Umsatzvolumen-Färbung
        let showRevenueBasedColoring = false;
        // NEU: Set für ausgewählte Vertriebsbezirke
        let selectedSalesDistricts = new Set();
        // NEU: Flag, ob der Filter aktiv ist (true wenn explizit ausgewählt/abgewählt)
        let isFilterActive = false;
        // NEU: Set aller verfügbaren Vertriebsbezirke
        let allSalesDistricts = new Set();

        // NEU: Mindest-Zoom-Level für Infoboxen
        const MIN_ZOOM_FOR_INFOBOXES = 7;


        /* DOM-Elemente Referenzen */
        // OPTIMIERT: Caching aller DOM-Elemente
        const DOM = {
            apiKeySection: document.getElementById('api-key-section'),
            openaiApiKeyInput: document.getElementById('openaiApiKeyInput'),
            geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
            saveApiKeyButton: document.getElementById('saveApiKeyButton'),
            chatInterface: document.getElementById('chat-interface'),
            chatlog: document.getElementById('chatlog'),
            questionInput: document.getElementById('question'),
            promptButtons: document.getElementById('promptButtons'),
            successBanner: document.getElementById('successBanner'),
            modelSelector: document.getElementById('model-selector'),
            openaiKeyContainer: document.getElementById('openai-key-container'),
            geminiKeyContainer: document.getElementById('gemini-key-container'),
            openaiValidationMessage: document.getElementById('openai-validation-message'),
            geminiValidationMessage: document.getElementById('gemini-validation-message'),
            mobileSidebarToggle: document.getElementById('mobileSidebarToggle'),
            sidebar: document.getElementById('sidebar'),
            editSalesDialog: document.getElementById('editSalesDialog'),
            dialogOverlay: document.getElementById('dialogOverlay'),
            addEntryForm: document.getElementById('addEntryForm'),
            salesGroupInput: document.getElementById('salesGroupInput'),
            salesDistrictInput: document.getElementById('salesDistrictInput'),
            revenueInput: document.getElementById('revenueInput'),
            editingRegionKey: document.getElementById('editingRegionKey'),
            editingEntryId: document.getElementById('editingEntryId'),
            selectedColor: document.getElementById('selectedColor'),
            colorPicker: document.getElementById('colorPicker'),
            salesDistrictToggle: document.getElementById('salesDistrictToggle'),
            revenueColoringToggle: document.getElementById('revenueColoringToggle'),
            salesDistrictDetailPopup: document.getElementById('salesDistrictDetailPopup'),
            detailDistrict: document.getElementById('detailDistrict'),
            detailGroup: document.getElementById('detailGroup'),
            detailRevenue: document.getElementById('detailRevenue'),
            detailRegionCount: document.getElementById('detailRegionCount'),
            detailEntryCount: document.getElementById('detailEntryCount'),
            detailRegionList: document.getElementById('detailRegionList'),
            salesGroupFilter: document.getElementById('salesGroupFilter'),
            salesDistrictSelectionContainer: document.getElementById('salesDistrictSelectionContainer'),
            salesDistrictFilterSearch: document.getElementById('salesDistrictFilterSearch'),
            salesDistrictCheckboxes: document.getElementById('salesDistrictCheckboxes'),
            selectAllDistrictsButton: document.getElementById('selectAllDistricts'),
            deselectAllDistrictsButton: document.getElementById('deselectAllDistricts'),
            welcomeMessageContainer: document.getElementById('welcomeMessageContainer'),
            readMoreBtn: document.getElementById('readMoreBtn'),
            toggleContactBtn: document.getElementById('toggleContactBtn'),
            contactInfoContainer: document.getElementById('contactInfoContainer'),
            dsgvoContentContainer: document.getElementById('dsgvoContentContainer'),
            readMoreDsgvoBtn: document.getElementById('readMoreDsgvoBtn'),
            saveDataButton: document.getElementById('saveDataButton'),
            loadDataButton: document.getElementById('loadDataButton'),
            sendButton: document.getElementById('sendButton'),
            clearButton: document.getElementById('clearButton'),
            addEntryButton: document.getElementById('addEntryButton'),
            closeEditDialogButton: document.getElementById('closeEditDialogButton'),
            cancelAddEntryButton: document.getElementById('cancelAddEntryButton'),
            salesEntriesList: document.getElementById('salesEntriesList'),
            closeSalesDistrictDetailPopupButton: document.getElementById('closeSalesDistrictDetailPopupButton'),
            editDialogTitle: document.getElementById('edit-dialog-title')
        };


        /* KI-System Prompt Definition */
        const baseSystemPrompt = `Du bist ein Multi-Landkreis-Markierungsassistent für eine interaktive Deutschlandkarte.

DEINE HAUPTaufGaben:
1. Interpretiere natürlichsprachliche Befehle zur Markierung von Landkreisen/Städten
2. Erstelle strukturierte JSON-Befehle für das Markierungssystem
3. Beantworte Fragen zu deutschen Landkreisen und deren Eigenschaften sowie zu den aktuellen Vertriebsdaten.

WICHTIG: Bei Regionen wie "Rostock" gibt es sowohl die kreisfreie Stadt als auch den Landkreis.
Achte auf Hinweise wie "Landkreis Rostock" oder "Stadt Rostock" um die richtige Region zu identifizieren.

VERFÜGBARE BEFEHLE (immer als JSON zurückgeben):
1. Einzelne Markierung: {"action": "mark", "region": "Regionname", "regionType": "Landkreis|Kreisfreie Stadt|Region", "color": "Farbe", "salesGroup": "Vertriebsgruppe", "salesDistrict": "Vertriebsbezirk", "revenue": 100000}
2. Mehrfachmarkierung: {"action": "multi_mark", "marks": [{"region": "Region1", "regionType": "Landkreis", "color": "rot", "salesGroup": "Vertriebsgruppe1", "salesDistrict": "Vertriebsbezirk1", "revenue": 100000}, {"region": "Region2", "regionType": "Kreisfreie Stadt", "color": "blau", "salesGroup": "Vertriebsgruppe2", "salesDistrict": "Vertriebsbezirk2", "revenue": 200000}]}
3. Alle löschen: {"action": "clear_all"}
4. Einzelne löschen: {"action": "remove", "region": "Regionname", "regionType": "Landkreis|Kreisfreie Stadt|Region"}
5. Info anzeigen: {"action": "info", "message": "Erklärungstext"}
6. Optimalen Eingabehinweis anzeigen: {"action": "show_optimal_input_hint"}

NEU: Du kannst nun auch Vertriebsinformationen zu den Regionen hinzufügen. Die Felder salesGroup und salesDistrict können beliebige Texte enthalten:
- salesGroup: Vertriebsgruppe (z.B. "Nord", "ISL1", "Gruppe A")
- salesDistrict: Vertriebsbezirk (z.B. "Gebiet 1", "H10A", "Bezirk XY")
- revenue: Umsatz (numerischer Wert ohne Währungszeichen)

VERFÜGBARE FARBEN: rot, grün, blau, gelb, orange, lila, türkis, rosa, grau, braun, hellblau, dunkelgrün, hellgrün

BEISPIELE:
User: "Markiere München rot mit Vertriebsgruppe Süd, Bezirk B2 und Umsatz 500000"
Assistant: {"action": "mark", "region": "München", "regionType": "Kreisfreie Stadt", "color": "rot", "salesGroup": "Süd", "salesDistrict": "B2", "revenue": 500000}

User: "Markiere Landkreis Rostock gelb mit Vertriebsgruppe Ost, Bezirk Z9 und Umsatz 150000"
Assistant: {"action": "mark", "region": "Rostock", "regionType": "Landkreis", "color": "gelb", "salesGroup": "Ost", "salesDistrict": "Z9", "revenue": 150000}

User: "Zeige alle Landkreise in Bayern"
Assistant: {"action": "info", "message": "Hier sind alle Landkreise in Bayern: Aichach-Friedberg, Altötting, Amberg-Sulzbach, ..."}

User: "Zeige mir das Format für optimale Dateneingabe"
Assistant: {"action": "show_optimal_input_hint"}

`; // This will be appended by the dynamic prompt generation

        /* NEU: Inhalt für den optimalen Eingabehinweis */
        const OPTIMAL_INPUT_HINT_CONTENT = `Sie können Regionen markieren und Vertriebsdaten zuweisen:<br><ul><li><strong>Einzelne Zeile (KI-gesteuert):</strong><br><code>Markiere [Region] [Farbe] mit Vertriebsgruppe [Gruppe], Bezirk [Bezirk] und Umsatz [Zahl]</code><br><small>Beispiel: <code>Markiere Berlin rot mit Vertriebsgruppe Nord, Bezirk A1 und Umsatz 500000</code></small></li><li><strong>Mehrere Zeilen (Tabellarisch, ohne KI):</strong><br><code>[Typ] [Region] [Gruppe] [Bezirk] [Farbe] [Umsatz]</code><br><small>Beispiel:<br><code>Landkreis Rostock Nord A1 gelb 300000</code><br><code>Kreisfreie Stadt München Süd B2 rot 750000</code></small></li></ul><small>Die Felder für Vertriebsgruppe und Bezirk können beliebige Texte enthalten.</small>`;

        /* NEU: DSGVO-Text */
        const FULL_DSGVO_TEXT_RAW = `
📜 Datenschutzerklärung
(Deutsch, DSGVO-konform, Stand: 2025)
GeoFuchs – Interaktive KI-Kartenanwendung

Verantwortlich: Günter Struck
E-Mail: geofuchs@online.de

1. Allgemeines
Diese App dient der interaktiven Visualisierung und Analyse deutscher Landkreise und nutzt dazu KI-Dienste sowie öffentlich zugängliche Kartendaten. Die Nutzung erfolgt ohne Registrierung und ohne Werbetracking.

2. Verarbeitung personenbezogener Daten
Die App verarbeitet keine personenbezogenen Daten im Sinne der DSGVO dauerhaft.

Temporäre Eingaben (z. B. über das Chatfeld) können bei Nutzung der KI-Funktion an folgende Anbieter übermittelt werden:

OpenAI (api.openai.com)

Google AI Studio (Gemini) (generativelanguage.googleapis.com)

Diese Daten werden ausschließlich zum Zweck der KI-Verarbeitung verwendet. Die Verarbeitung erfolgt nach den Datenschutzrichtlinien der jeweiligen Anbieter. Es erfolgt keine dauerhafte Speicherung durch den App-Entwickler.

3. Kartendaten & Standort
Die Kartenansicht basiert auf OpenStreetMap-Kacheln, bereitgestellt durch:

basemaps.cartocdn.com (CARTO)

Leaflet.js

Diese Dienste können beim Laden der Karte technische Informationen wie die IP-Adresse übertragen bekommen. Eine personenbezogene Auswertung findet seitens des App-Anbieters nicht statt.

4. Lokale Speicherung
Vom Nutzer erzeugte Daten (z. B. Markierungen, Umsätze, Gruppenzuordnungen) können lokal im Gerät oder temporär im Browsercache gespeichert werden, sofern dies vom Nutzer ausgelöst wird („💾 Daten speichern“).

Es erfolgt keine automatische Übertragung oder externe Speicherung dieser Inhalte durch den Anbieter.

5. Keine Haftung
Diese App wird als MVP (Minimum Viable Product) ohne Gewähr bereitgestellt. Trotz sorgfältiger Umsetzung wird keine Haftung für die Richtigkeit, Vollständigkeit oder Verfügbarkeit der bereitgestellten Funktionen oder Daten übernommen.

Die Nutzung erfolgt auf eigene Verantwortung.

6. Rechte gemäß DSGVO
Als Nutzer:in haben Sie das Recht auf:

Auskunft über verarbeitete Daten

Berichtigung oder Löschung

Einschränkung der Verarbeitung

Widerspruch gegen die Verarbeitung

Da keine personenbezogenen Daten dauerhaft gespeichert werden, ist die Ausübung dieser Rechte aktuell nicht notwendig.

7. Kontakt
Bei Fragen zum Datenschutz wenden Sie sich bitte an:
Günter Struck
E-Mail: geofuchs@online.de
`;
        // MODIFIED: Changed the truncation marker to hide "GeoFuchs – Interaktive KI-Kartenanwendung" and everything after it initially
        const DSGVO_TRUNCATION_MARKER = "GeoFuchs – Interaktive KI-Kartenanwendung";
        let truncatedDsgvoContent = '';
        let expandedDsgvoContent = '';

        /* Live-Validierung für API-Keys */
        // OPTIMIERT: Event-Listener direkt registrieren
        DOM.openaiApiKeyInput.addEventListener('input', validateOpenAIKey);
        DOM.geminiApiKeyInput.addEventListener('input', validateGeminiKey);

        function validateOpenAIKey() {
            const key = DOM.openaiApiKeyInput.value.trim();
            if (!key) {
                DOM.openaiValidationMessage.textContent = "";
                return false;
            }

            if (!key.startsWith('sk-')) {
                DOM.openaiValidationMessage.textContent = "OpenAI-Schlüssel sollten mit 'sk-' beginnen";
                DOM.openaiValidationMessage.className = "error-message";
                return false;
            }

            if (key.length < 20) {
                DOM.openaiValidationMessage.textContent = "Schlüssel scheint zu kurz zu sein";
                DOM.openaiValidationMessage.className = "info-message";
                return false;
            }

            DOM.openaiValidationMessage.textContent = "✓ Format gültig";
            DOM.openaiValidationMessage.className = "info-message";
            return true;
        }

        function validateGeminiKey() {
            const key = DOM.geminiApiKeyInput.value.trim();
            if (!key) {
                DOM.geminiValidationMessage.textContent = "";
                return false;
            }

            if (key.length < 20) {
                DOM.geminiValidationMessage.textContent = "Schlüssel scheint zu kurz zu sein";
                DOM.geminiValidationMessage.className = "info-message";
                return false;
            }

            DOM.geminiValidationMessage.textContent = "✓ Format gültig";
            DOM.geminiValidationMessage.className = "info-message";
            return true;
        }

        /* Funktion zum Speichern des API-Schlüssels und Aktivieren des Systems */
        // OPTIMIERT: Event-Listener direkt registrieren
        DOM.saveApiKeyButton.addEventListener('click', () => {
            const selectedModel = document.querySelector('input[name="model"]:checked').value;
            let key = '';
            let isValid = false;

            if (selectedModel === 'openai') {
                key = DOM.openaiApiKeyInput.value.trim();
                isValid = validateOpenAIKey();
                sessionStorage.setItem('openai_api_key', key);
            } else {
                key = DOM.geminiApiKeyInput.value.trim();
                isValid = validateGeminiKey();
                sessionStorage.setItem('gemini_api_key', key);
            }

            if (key && isValid) {
                sessionStorage.setItem('selected_model', selectedModel);
                DOM.apiKeySection.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.chatInterface.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                initializeChatInterface();

                setTimeout(() => DOM.questionInput.focus(), 100);
            } else {
                const errorMessage = key ? "Der eingegebene API-Schlüssel scheint ungültig zu sein."
                                     : "Bitte geben Sie einen API-Schlüssel ein.";
                appendErrorMessage(errorMessage);
            }
        });

        /* Funktion zum Anzeigen von Fehlermeldungen */
        function appendErrorMessage(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            errorDiv.setAttribute('role', 'alert');

            // OPTIMIERT: Prüfen, ob API-Key-Sektion sichtbar ist
            if (!DOM.apiKeySection.classList.contains('hidden')) {
                DOM.apiKeySection.appendChild(errorDiv);

                setTimeout(() => {
                    if (errorDiv.parentElement === DOM.apiKeySection) {
                        DOM.apiKeySection.removeChild(errorDiv);
                    }
                }, 5000);
            } else {
                appendMessageToChatLog('❌ ' + message, 'assistant');
            }
        }

        /* Chat-Interface Initialisierung */
        function initializeChatInterface() {
            // Prüfen, ob die Willkommensnachricht in dieser Sitzung bereits angezeigt wurde
            if (hasWelcomeMessageBeenShown) {
                return; // Wenn ja, beende die Funktion, um eine doppelte Anzeige zu verhindern
            }
            const selectedModel = sessionStorage.getItem('selected_model');
            let modelName = '';

            if (selectedModel === 'openai') {
                modelName = 'OpenAI GPT-4.1';
            } else {
               modelName = 'Google Gemini 2.5 Pro';
            }

            DOM.successBanner.textContent = `🎯 KI-SYSTEM AKTIV (${modelName}!`;

            appendMessageToChatLog(
                `Willkommen! 🎉\nIch bin Ihr KI-Assistent für Landkreismarkierungen\n\n` +
                "Was kann ich tun:\n" +
                "• 'Markiere Berlin rot'\n" +
                "• 'Markiere Landkreis Rostock gelb mit Vertriebsgruppe Nord, Vertriebsbezirk A1 und Umsatz 300000'\n" +
                "Sie können mehrere Vertriebsbezirke pro Region hinzufügen und die Daten später durch Klicken auf 'Bearbeiten' verwalten.\n" +
                "Fragen Sie mich nach der optimalen Dateneingabe (Tabelle), ich zeige Ihnen gerne das Format.\n\n" +
                "Wie kann ich Ihnen helfen? Eine Basis-Schulung?",
                'assistant'
            );

            DOM.questionInput.focus();
hasWelcomeMessageBeenShown = true; // Setze die Flagge auf true, nachdem die Nachricht angezeigt wurde
        }

        /* NEU: Verbesserte Funktion zum Parsen von tabellarischen Daten */
        function parseTableData(input) {
            if (!input || typeof input !== 'string') return { success: false, message: "Keine Eingabe vorhanden." };

            const lines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
            if (lines.length === 0) return { success: false, message: "Keine Daten zum Verarbeiten gefunden." };

            const results = {
                success: false,
                processed: 0,
                failed: 0,
                entries: [],
                failedLines: []
            };

            // Regex for a full line with flexible spaces and ANY salesGroup/salesDistrict
            // GEÄNDERT: Region Name ist jetzt nicht-gierig (mit '?') und SalesGroup/SalesDistrict sind \S+
            const fullPattern = /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\wäöüÄÖÜß\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)(?:\s*(\d+))?$/i;

            lines.forEach((line, index) => {
                try {
                    const match = line.trim().match(fullPattern);

                    if (match) {
                        const regionType = match[1];
                        const regionName = match[2].trim();
                        const salesGroup = match[3].trim();
                        const salesDistrict = match[4].trim();
                        const color = match[5].toLowerCase();
                        const revenue = match[6] ? parseInt(match[6]) : 0;

                        // Basic validation after extraction and cleaning
                        if (!regionType || !regionType.match(/^(Landkreis|Kreisfreie Stadt|Stadt|Region)$/i)) {
                            throw new Error("Ungültiger Regionstyp");
                        }
                        if (!regionName || regionName.trim().length === 0) {
                            throw new Error("Ungültiger Regionsname");
                        }
                        // Removed specific salesGroup/salesDistrict format validation
                        if (!color || !CONFIG.colors[color]) {
                            throw new Error("Ungültige Farbe");
                        }
                        if (isNaN(revenue)) {
                            throw new Error("Umsatz muss eine Zahl sein");
                        }

                        const entry = {
                            action: "mark",
                            region: regionName,
                            regionType: regionType,
                            color: color,
                            salesGroup: salesGroup,
                            salesDistrict: salesDistrict,
                            revenue: revenue
                        };

                        results.entries.push(entry);
                        results.processed++;
                    } else {
                        throw new Error("Ungültiges Format der Zeile");
                    }
                } catch (error) {
                    results.failed++;
                    results.failedLines.push({
                        lineNumber: index + 1,
                        content: line,
                        error: error.message
                    });
                }
            });

            if (results.processed > 0) {
                results.success = true;
                results.message = `${results.processed} von ${results.processed + results.failed} Zeilen erfolgreich verarbeitet.`;
            } else {
                results.message = "Keine Daten konnten erfolgreich verarbeitet werden.";
            }

            return results;
        }

        /* NEU: Funktion zum Verarbeiten tabellarischer Daten und Ausführen der Markierungen */
        function processTableData(input) {
            try {
                const parseResult = parseTableData(input);

                if (!parseResult.success) {
                    appendMessageToChatLog(`❌ ${parseResult.message}`, 'assistant');
                    return false;
                }

                // Erfolgreich verarbeitete Einträge
                if (parseResult.entries && parseResult.entries.length > 0) {
                    // Erstelle ein multi_mark Kommando für alle Einträge
                    const multiMarkCommand = {
                        action: "multi_mark",
                        marks: parseResult.entries
                    };

                    // Führe das Kommando aus
                    executeCommand(multiMarkCommand);

                    // Erfolgsstatistik anzeigen
                    let successMessage = `✅ ${parseResult.processed} von ${parseResult.processed + parseResult.failed} Zeilen erfolgreich verarbeitet.`;

                    if (parseResult.failed > 0) {
                        successMessage += `\n❌ ${parseResult.failed} Zeilen konnten nicht verarbeitet werden.`;
                    }

                    appendMessageToChatLog(successMessage, 'assistant');
                    return true;
                } else {
                    appendMessageToChatLog("❌ Keine Daten konnten verarbeitet werden.", 'assistant');
                    return false;
                }
            } catch (error) {
                appendMessageToChatLog(`❌ Fehler bei der Verarbeitung: ${error.message}`, 'assistant');
                return false;
            }
        }

        /* OPTIMIERT: Erkennung von tabellarischen Daten in mehrzeiligen Eingaben */
        function isTableData(input) {
            if (!input || typeof input !== 'string') return false;

            // Teile die Eingabe in Zeilen auf
            const lines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
            if (lines.length <= 1) return false; // Nicht mehrzeilig

            // Überprüfe, ob die erste Zeile dem Tabellenformat entspricht
            const firstLine = lines[0].trim();

            // Prüfe auf verschiedene Tabellenmuster (gelockerte Vertriebsdaten-Muster)
            // GEÄNDERT: Region Name ist jetzt nicht-gierig (mit '?') und SalesGroup/SalesDistrict sind \S+
            const tablePattern = /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\wäöüÄÖÜß\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)(?:\s*(\d+))?$/i;

            // Wenn die erste Zeile dem Muster entspricht, handelt es sich wahrscheinlich um Tabellendaten
            return tablePattern.test(firstLine);
        }

        /* ÜBERARBEITET: Verarbeitung mehrzeiliger Eingaben mit verbesserter Tabellenunterstützung */
        function processMultiLineInput(input) {
            if (!input || typeof input !== 'string') return false;

            // Teile die Eingabe in Zeilen auf
            const lines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
            if (lines.length <= 1) return false; // Nicht mehrzeilig

            // NEU: Prüfe zuerst auf tabellarische Daten
            if (isTableData(input)) {
                processTableData(input);
                return true; // Beenden, wenn Tabellendaten verarbeitet wurden
            }

            // Sonst verarbeite jede Zeile einzeln wie zuvor
            let processedLines = 0;
            let failedLines = [];

            // Verarbeite jede Zeile
            lines.forEach((line, index) => {
                const success = processLineCommand(line.trim());
                if (success) {
                    processedLines++;
                } else {
                    failedLines.push(line);
                }
            });

            // Erfolgsmeldung
            if (processedLines > 0) {
                appendMessageToChatLog(
                    `✅ ${processedLines} von ${lines.length} Zeilen wurden erfolgreich verarbeitet!` +
                    (failedLines.length > 0 ? `\n❌ Folgende Zeilen konnten nicht verarbeitet werden:\n${failedLines.join('\n')}` : ''),
                    'assistant'
                );
            }
            else {
                appendMessageToChatLog(`❌ Keine der Zeilen konnte verarbeitet werden.`, 'assistant');
                return false;
            }

            return true;
        }

        /* OPTIMIERT: Verarbeitet eine einzelne Befehlszeile mit verbesserter Farb-/Umsatzerkennung */
        function processLineCommand(line) {
            if (!line) return false;

            // 1. Prüfe auf JSON-Format
            if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                try {
                    const command = JSON.parse(line);
                    if (command && command.action) { // Nur ausführen, wenn es ein gültiger Befehl ist
                        executeCommand(command);
                        return true;
                    }
                } catch (error) {
                    // Fehler beim JSON-Parsen, ignoriere und versuche andere Formate
                }
            }

            // 2. Prüfe auf direktes Format: "Landkreis Verden Blau"
            const directRegionColorPattern = /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\wäöüÄÖÜß\s\-.,()]+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)$/i;
            const directMatch = line.match(directRegionColorPattern);

            if (directMatch) {
                const regionType = directMatch[1];
                const regionName = directMatch[2].trim();
                const color = directMatch[3].toLowerCase();

                const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                const success = markAllMatchingRegions(regionName, regionType, colorHex, true);
                return success.success || success === true;
            }

            // 3. Prüfe auf "Markiere XYZ Farbe"-Format
            const markRegionPattern = /^Markiere\s+(Landkreis|Kreisfreie Stadt|Stadt|Region)?\s*([\wäöüÄÖÜß\s\-.,()]+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)$/i;
            const markMatch = line.match(markRegionPattern);

            if (markMatch) {
                const regionType = markMatch[1] || null;
                const regionName = markMatch[2].trim();
                const color = markMatch[3].toLowerCase();

                const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                const success = markAllMatchingRegions(regionName, regionType, colorHex, true);
                return success.success || success === true;
            }

            // 4. OPTIMIERT: Prüfe auf tabellarisches Format mit flexiblen Trennzeichen und Farb-/Umsatzformaten
            const tablePatterns = [
                // Muster 1: "Landkreis Name Gruppe Bezirk rot 123456" - with spaces, any group/district
                // GEÄNDERT: Region Name ist jetzt nicht-gierig (mit '?') und SalesGroup/SalesDistrict sind \S+
                /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\wäöüÄÖÜß\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)\s+(\d+)$/i,

                // Muster 2: "Landkreis Name Gruppe Bezirk rot123456" - with spaces, combined color/revenue
                // GEÄNDERT: Region Name ist jetzt nicht-gierig (with '?') and SalesGroup/salesDistrict are \S+
                /^(Landkreis|Kreisfreie Stadt|Stadt|Region)\s+([\wäöüÄÖÜß\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)(\d+)$/i
            ];

            // Prüfe jedes Muster
            for (const pattern of tablePatterns) {
                const match = line.match(pattern);
                if (match) {
                    const regionType = match[1];
                    const regionName = match[2].trim();
                    const salesGroup = match[3].trim();
                    const salesDistrict = match[4].trim();
                    const color = match[5].toLowerCase();
                    const revenue = parseInt(match[6]);

                    const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                    const success = markAllMatchingRegions(regionName, regionType, colorHex, true, salesGroup, salesDistrict, revenue);
                    return success.success || success === true;
                }
            }

            // 5. OPTIMIERT: Prüfe auf "Markiere"-Präfix mit Vertriebsdaten und flexiblen Formaten
            const markWithSalesPatterns = [
                // Muster 1: "Markiere Landkreis Name Gruppe Bezirk rot 123456" - with spaces
                // GEÄNDERT: Region Name ist jetzt nicht-gierig (with '?') and SalesGroup/SalesDistrict are \S+
                /^Markiere\s+(Landkreis|Kreisfreie Stadt|Stadt|Region)?\s*([\wäöüÄÖÜß\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)\s+(\d+)$/i,

                // Muster 2: "Markiere Landkreis Name Gruppe Bezirk rot123456" - with spaces, combined color/revenue
                // GEÄNDERT: Region Name ist jetzt nicht-gierig (with '?') and SalesGroup/SalesDistrict are \S+
                /^Markiere\s+(Landkreis|Kreisfreie Stadt|Stadt|Region)?\s*([\wäöüÄÖÜß\s\-.,()]+?)\s+(\S+)\s+(\S+)\s+(rot|grün|blau|gelb|orange|lila|türkis|rosa|grau|braun|hellblau|dunkelgrün|hellgrün)(\d+)$/i
            ];

            // Prüfe jedes Muster
            for (const pattern of markWithSalesPatterns) {
                const match = line.match(pattern);
                if (match) {
                    const regionType = match[1] || null;
                    const regionName = match[2].trim();
                    const salesGroup = match[3].trim();
                    const salesDistrict = match[4].trim();
                    const color = match[5].toLowerCase();
                    const revenue = parseInt(match[6]);

                    const colorHex = CONFIG.colors[color] || CONFIG.colors.default;
                    const success = markAllMatchingRegions(regionName, regionType, colorHex, true, salesGroup, salesDistrict, revenue);
                    return success.success || success === true;
                }
            }

            // 6. Wenn nichts passt, kann die Zeile nicht direkt verarbeitet werden
            return false;
        }

        /* MODIFIZIERTE FUNKTION: KI-Kommunikation mit verbesserter Tabellenunterstützung */
        async function sendMessage() {
            const selectedModel = sessionStorage.getItem('selected_model');
            const apiKey = sessionStorage.getItem(selectedModel === 'openai' ? 'openai_api_key' : 'gemini_api_key');

            if (!apiKey) {
                appendMessageToChatLog("Sie sind im Basic-Modus. Für KI-Funktionen benötigen Sie einen API-Schlüssel.", 'assistant');
                return;
            }

            const question = DOM.questionInput.value.trim();
            if (!question) return;

            // Zeige die Anfrage im Chat-Log an
            appendMessageToChatLog(escapeHtml(question), 'user');
            DOM.questionInput.value = "";
            DOM.promptButtons.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden

            // NEU: Prüfe zuerst auf tabellarische Daten
            if (isTableData(question)) {
                processTableData(question);
                return; // Beenden, wenn Tabellendaten verarbeitet wurden
            }

            // Prüfe auf mehrzeilige Eingabe
            if (processMultiLineInput(question)) {
                return; // Beenden, wenn mehrere Zeilen erfolgreich verarbeitet wurden
            }

            // Versuche, einzelne Zeile direkt zu verarbeiten
            if (processLineCommand(question)) {
                return; // Beenden, wenn die Zeile erfolgreich verarbeitet wurde
            }

            // Falls keine direkte Verarbeitung möglich war, frage die KI
            // Dynamisch den System-Prompt generieren
            currentSystemPrompt = generateDynamicSystemPrompt();

            showTypingIndicator();
            conversationHistory.push({ role: "user", content: question });

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);

                let reply = '';

                if (selectedModel === 'openai') {
                    reply = await callOpenAI(apiKey, controller.signal);
                } else {
                    reply = await callGemini(apiKey, controller.signal);
                }

                clearTimeout(timeoutId);

                conversationHistory.push({ role: "assistant", content: reply });
                processAssistantReply(reply);

            } catch (error) {
                console.error("API-Fehler:", error);
                let errorMessage;

                if (error.name === 'AbortError') {
                    errorMessage = "Die Anfrage hat zu lange gedauert und wurde abgebrochen.";
                } else if (error.message.includes('429')) {
                    errorMessage = "API-Limit überschritten. Bitte warten Sie einen Moment und versuchen Sie es erneut.";
                } else {
                    errorMessage = `Ein Fehler ist aufgetreten: ${error.message}`;
                }

                appendMessageToChatLog(`❌ ${errorMessage}`, 'assistant');
            } finally {
                removeTypingIndicator();
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /* OpenAI API-Aufruf */
        async function callOpenAI(apiKey, signal) {
            const messages = [
                { role: "system", content: currentSystemPrompt },
                ...conversationHistory.slice(-10)
            ];

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                signal: signal,
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    model: "gpt-4",
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 500
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`OpenAI API Fehler: ${response.status} - ${errorData.error?.message || 'Unbekannter Fehler'}`);
            }

            const data = await response.json();
            return data.choices?.[0]?.message?.content || "Keine Antwort von OpenAI erhalten.";
        }

        /* Google Gemini API-Aufruf */
        async function callGemini(apiKey, signal) {
            const geminiHistory = conversationHistory.slice(-10).map(msg => ({
                role: msg.role === 'assistant' ? 'model' : 'user',
                parts: [{ text: msg.content }]
            }));

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${apiKey}`;

            const response = await fetch(url, {
                method: "POST",
                signal: signal,
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ contents: geminiHistory, system_instruction: { parts: [{ text: currentSystemPrompt }] } })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(`Google Gemini API Fehler: ${response.status} - ${errorData.error?.message || 'Unbekannter Fehler'}`);
            }

            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "Keine Antwort von Gemini erhalten.";
        }

        /* KI-Antwort Verarbeitung */
        function processAssistantReply(reply) {
            if (!reply) {
                appendMessageToChatLog("Keine Antwort erhalten.", 'assistant');
                return;
            }

            try {
                const jsonMatch = reply.match(/(\{[\s\S]*?\})(?!\s*[,:])/);

                if (jsonMatch) {
                    try {
                        const command = JSON.parse(jsonMatch[0]);
                        executeCommand(command);

                        const additionalText = reply.replace(jsonMatch[0], '').trim();
                        if (additionalText) {
                            appendMessageToChatLog(escapeHtml(additionalText), 'assistant');
                        }
                    } catch (jsonError) {
                        console.error("JSON Parse Fehler:", jsonError);
                        appendMessageToChatLog(escapeHtml(reply), 'assistant');
                    }
                } else {
                    appendMessageToChatLog(escapeHtml(reply), 'assistant');
                }
            } catch (error) {
                console.error("Fehler bei der Antwortverarbeitung:", error);
                appendMessageToChatLog(escapeHtml(reply), 'assistant');
            }
        }

        /* Befehlsausführung */
        function executeCommand(command) {
            if (!command || typeof command !== 'object') {
                appendMessageToChatLog("⚠️ Ungültiger Befehl erhalten", 'assistant');
                return;
            }

            switch(command.action) {
                case 'mark':
                    if (command.region) {
                        const color = CONFIG.colors[command.color] || CONFIG.colors.default;
                        const regionType = command.regionType || null;

                        // Verwende die neue Mehrfachmarkierungsfunktion statt highlightDistrictMulti
                        const success = markAllMatchingRegions(
                            command.region,
                            regionType,
                            color,
                            false,
                            command.salesGroup,
                            command.salesDistrict,
                            command.revenue
                        );

                        if (success) {
                            // Die Erfolgsmeldung wird bereits in markAllMatchingRegions erzeugt
                        } else {
                            appendMessageToChatLog(
                                `❌ Die Region "${escapeHtml(command.region)}"${regionType ? ` (${regionType})` : ''} konnte nicht gefunden werden.`,
                                'assistant'
                            );
                        }
                    }
                    break;

                case 'multi_mark':
                    if (command.marks && Array.isArray(command.marks)) {
                        let successCount = 0;
                        let totalMarked = 0;
                        let failedRegions = [];

                        command.marks.forEach(mark => {
                            if (mark && mark.region) {
                                const color = CONFIG.colors[mark.color] || CONFIG.colors.default;
                                const regionType = mark.regionType || null;

                                // Verwende die neue Mehrfachmarkierungsfunktion
                                const result = markAllMatchingRegions(
                                    mark.region,
                                    regionType,
                                    color,
                                    true,
                                    mark.salesGroup,
                                    mark.salesDistrict,
                                    mark.revenue
                                );

                                if (result.success) {
                                    successCount++;
                                    totalMarked += result.count;
                                } else {
                                    failedRegions.push(`${mark.region}${regionType ? ` (${regionType})` : ''}`);
                                }
                            }
                        });

                        let message = `✅ ${successCount} von ${command.marks.length} Regionstypen erfolgreich markiert! (Insgesamt ${totalMarked} Regionen)`;
                        if (failedRegions.length > 0) {
                            message += `\n❌ Nicht gefunden: ${escapeHtml(failedRegions.join(', '))}`;
                        }

                        appendMessageToChatLog(message, 'assistant');
                    }
                    break;

                case 'clear_all':
                    clearAllMarkings();
                    break;

                case 'remove':
                    if (command.region) {
                        removeMarking(command.region, command.regionType);
                    }
                    break;

                case 'info':
                    if (command.message) {
                        appendMessageToChatLog(escapeHtml(command.message), 'assistant');
                    }
                    break;

                case 'show_optimal_input_hint': // NEU: Fall für optimalen Eingabehinweis
                    // Hier wird der HTML-Inhalt direkt übergeben, um die Formatierung zu erhalten
                    appendMessageToChatLog(OPTIMAL_INPUT_HINT_CONTENT, 'assistant');
                    break;

                // NEUE KI-BEFEHLE
                case 'analyze_revenue':
                    if (command.type) {
                        const message = analyzeRevenue(command.type, command.filter);
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("⚠️ Fehlender 'type' für analyze_revenue Befehl.", 'assistant');
                    }
                    break;
                case 'top_list':
                    if (command.type && command.limit) {
                        const message = getTopList(command.type, command.limit);
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("⚠️ Fehlende 'type' oder 'limit' für top_list Befehl.", 'assistant');
                    }
                    break;
                case 'analyze_district':
                    if (command.salesDistrict || command.salesGroup) {
                        const message = analyzeDistrict(command); // Pass the whole command as filter
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("⚠️ Fehlender 'salesDistrict' oder 'salesGroup' für analyze_district Befehl.", 'assistant');
                    }
                    break;
                case 'compare':
                    if (command.type === 'districts' && command.items && Array.isArray(command.items) && command.items.length === 2) {
                        const message = compareDistricts(command.items);
                        appendMessageToChatLog(message, 'assistant');
                    } else {
                        appendMessageToChatLog("⚠️ Ungültige Parameter für compare Befehl.", 'assistant');
                    }
                    break;

                default:
                    appendMessageToChatLog("⚠️ Befehl nicht erkannt: " + command.action, 'assistant');
            }
        }

        /* OPTIMIERT: Normalisiert einen Regionsnamen für verbesserte Suche */
        function normalizeRegionName(name) {
            if (!name) return '';

            // Zu Kleinbuchstaben konvertieren
            let normalized = name.toLowerCase();

            // Umlaute korrekt normalisieren (statt nur ä -> a, auch ä -> ae usw.)
            normalized = normalized.replace(/ä/g, 'ae')
                                  .replace(/ö/g, 'oe')
                                  .replace(/ü/g, 'ue')
                                  .replace(/ß/g, 'ss');

            // Mehrfache Leerzeichen durch einzelne ersetzen
            normalized = normalized.replace(/\s+/g, ' ');

            // Sonderzeichen entfernen
            normalized = normalized.replace(/[^\wäöüÄÖÜß\s\-.,()]/g, ''); // Erlaubt auch Klammern und Punkte

            // Leerzeichen an Anfang und Ende entfernen
            normalized = normalized.trim();

            return normalized;
        }

        /* OPTIMIERT: Verbesserte und präzisere Regionstyp-Normalisierung mit "Region" */
        function normalizeRegionType(type) {
            if (!type) return '';

            // Zu Kleinbuchstaben und Entfernung überflüssiger Leerzeichen
            const typeLC = type.toLowerCase().trim();

            // Detailliertere Mapping-Tabelle für präzisere Unterscheidung
            // OPTIMIERT: Erweiterte Kategorien für "Landkreis", "Kreisfreie Stadt" und "Region"
            const typeMap = {
                // Landkreis-Varianten
                'landkreis': 'landkreis',
                'kreis': 'landkreis',
                'lk': 'landkreis',
                'lkr': 'landkreis',
                'landkr': 'landkreis',
                'landrat': 'landkreis',
                'staedteregion': 'landkreis', // HINZUGEFÜGT für "Städteregion Aachen"

                // Stadt-Varianten
                'kreisfreie stadt': 'kreisfreie stadt',
                'kreisfrei': 'kreisfreie stadt',
                'kreisstadt': 'kreisfreie stadt',
                'stadt': 'kreisfreie stadt',
                'stadtkreis': 'kreisfreie stadt',

                // Region-Varianten hinzugefügt
                'region': 'region'
            };

            // Direkter Schlüsselabgleich
            if (typeMap[typeLC]) {
                return typeMap[typeLC];
            }

            // Teilstring-Erkennung für komplexere Ausdrücke
            for (const [key, value] of Object.entries(typeMap)) {
                // Exaktere Teilstring-Erkennung mit Wortgrenzen
                // Das verbessert insbesondere die Unterscheidung zwischen "Stadt" und "Landkreis"
                if (typeLC.includes(key) ||
                    typeLC.match(new RegExp(`\\b${key}\\b`))) {
                    return value;
                }
            }

            // Gibt den ursprünglichen Wert zurück, wenn keine Übereinstimmung
            return typeLC;
        }

        /* NEU: Funktion zum Mischen von Farben für mehrere Vertriebsbezirke */
        function mixColors(colors) {
            if (!colors || colors.length === 0) return CONFIG.colors.default;
            if (colors.length === 1) return colors[0];

            // RGB-Werte extrahieren und mitteln
            let r = 0, g = 0, b = 0;
            colors.forEach(hexColor => {
                if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                const rValue = parseInt(hexColor.slice(1, 3), 16);
                const gValue = parseInt(hexColor.slice(3, 5), 16);
                const bValue = parseInt(hexColor.slice(5, 7), 16);
                r += rValue;
                g += gValue;
                b += bValue;
            });

            // Durchschnitt berechnen
            r = Math.round(r / colors.length);
            g = Math.round(g / colors.length);
            b = Math.round(b / colors.length);

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        /* NEU: Funktion zum Generieren einer eindeutigen ID */
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        /* NEU: Funktion zum Ermitteln der Farbe basierend auf dem höchsten Umsatz */
        function getRevenueBasedColor(salesEntries) {
            if (!salesEntries || salesEntries.length === 0) {
                return null; // Kein Eintrag, keine Farbe
            }

            let maxRevenue = -1;
            let colorOfMaxRevenueEntry = null;

            salesEntries.forEach(entry => {
                if (entry.revenue > maxRevenue) {
                    maxRevenue = entry.revenue;
                    colorOfMaxRevenueEntry = entry.color;
                }
            });

            // Wenn alle Umsätze 0 oder negativ sind, oder kein Umsatz gefunden wurde,
            // greife auf die gemischte Farbe zurück (falls vorhanden) oder Standardfarbe
            if (maxRevenue <= 0 && salesEntries.length > 0) {
                return mixColors(salesEntries.map(e => e.color)); // Fallback zur gemischten Farbe
            }

            return colorOfMaxRevenueEntry || CONFIG.colors.default;
        }

        /* KORRIGIERT: Markiere alle passenden Regionen mit verbesserter Regionstyp-Erkennung und Vertriebsdaten */
        function markAllMatchingRegions(searchTerm, regionType, color, suppressMessage = false, salesGroup = null, salesDistrict = null, revenue = null) {
            let matchCount = 0;
            let result = { success: false, count: 0 };

            try {
                // Verwenden Sie die robuste findRegionInTable, um alle potenziellen Übereinstimmungen zu erhalten
                const foundRegions = findRegionInTable(searchTerm, regionType, true); // true für findAll

                if (!foundRegions || foundRegions.length === 0) {
                    result = { success: false, count: 0 };
                    if (!suppressMessage) {
                        appendMessageToChatLog(
                            `❌ Die Region "${escapeHtml(searchTerm)}"${regionType ? ` (${regionType})` : ''} konnte nicht gefunden werden.`,
                            'assistant'
                        );
                    }
                    return suppressMessage ? result : false;
                }

                const numGeographicalParts = foundRegions.length; // Dies ist die Gesamtzahl der geografischen Teile für die administrative Einheit

                foundRegions.forEach(region => {
                    const layer = objIdToLayerMap.get(region.objid);

                    if (layer) {
                        const combinedKey = `${region.name}__${region.type}__${region.objid}`;

                        const newSalesEntry = {
                            id: generateUniqueId(),
                            color: color,
                            salesGroup: salesGroup || "",
                            salesDistrict: salesDistrict || "",
                            revenue: revenue // Vollständiger administrativer Umsatz
                        };

                        if (markedDistricts.has(combinedKey)) {
                            const existingData = markedDistricts.get(combinedKey);
                            let entryToUpdateIndex = -1;

                            // Vorhandenen Eintrag nach salesDistrict finden, oder den ersten leeren, wenn der neue leer ist
                            if (newSalesEntry.salesDistrict !== "") {
                                entryToUpdateIndex = existingData.salesEntries.findIndex(
                                    entry => entry.salesDistrict === newSalesEntry.salesDistrict
                                );
                            } else { // Wenn der neue Eintrag keinen salesDistrict hat, versuchen, einen vorhandenen leeren zu aktualisieren
                                entryToUpdateIndex = existingData.salesEntries.findIndex(
                                    entry => entry.salesDistrict === ""
                                );
                                // Wenn kein leerer salesDistrict-Eintrag, aber andere Einträge vorhanden sind, den ersten aktualisieren
                                if (entryToUpdateIndex === -1 && existingData.salesEntries.length > 0) {
                                    entryToUpdateIndex = 0;
                                }
                            }

                            if (entryToUpdateIndex !== -1) {
                                const originalId = existingData.salesEntries[entryToUpdateIndex].id;
                                existingData.salesEntries[entryToUpdateIndex] = { ...newSalesEntry, id: originalId };
                            } else {
                                existingData.salesEntries.push(newSalesEntry);
                            }

                            const colors = existingData.salesEntries.map(entry => entry.color);
                            existingData.displayColor = mixColors(colors);
                            existingData.numGeographicalParts = numGeographicalParts; // Auch für bestehende aktualisieren
                        } else {
                            // Neue Markierung
                            markedDistricts.set(combinedKey, {
                                layer: layer,
                                regionName: region.name,
                                regionType: region.type,
                                timestamp: Date.now(),
                                objid: region.objid,
                                salesEntries: [newSalesEntry],
                                displayColor: color,
                                numGeographicalParts: numGeographicalParts
                            });
                        }

                        layer.bringToFront();

                        if (layer._path) {
                            layer._path.setAttribute('aria-checked', 'true');
                            layer._path.setAttribute('aria-description',
                                `${region.name} (${region.type}) markiert mit Farbe ${getColorNameFromHex(color)}`);
                        }

                        matchCount++;
                    }
                });

                if (matchCount > 0) {
                    updateAllDisplays();

                    result = { success: true, count: matchCount };

                    if (!suppressMessage) {
                        const colorName = getColorNameFromHex(color);
                        const regTypeName = regionType || "alle Typen";

                        let message = `✅ ${matchCount} Region${matchCount !== 1 ? 'en' : ''} für ${escapeHtml(searchTerm)} (${regTypeName}) wurden ${colorName} markiert!`;

                        if (salesGroup || salesDistrict || revenue) {
                            message += "\nVertriebsdaten gesetzt:";
                            if (salesGroup) message += ` Gruppe=${escapeHtml(salesGroup)}`;
                            if (salesDistrict) message += ` Bezirk=${escapeHtml(salesDistrict)}`;
                            if (revenue) message += ` Umsatz=${revenue}`;
                        }

                        appendMessageToChatLog(message, 'assistant');
                    }
                    return suppressMessage ? result : true;
                } else {
                    // Dieser Pfad ist mit der verbesserten findRegionInTable weniger wahrscheinlich, aber zur Sicherheit beibehalten
                    result = { success: false, count: 0 };
                    if (!suppressMessage) {
                        appendMessageToChatLog(
                            `❌ Die Region "${escapeHtml(searchTerm)}"${regionType ? ` (${regionType})` : ''} konnte nicht gefunden werden.`,
                            'assistant'
                        );
                    }
                    return suppressMessage ? result : false;
                }

            } catch (error) {
                console.error(`Fehler bei der Mehrfachmarkierung: ${error.message}`);
                result = { success: false, count: 0, error: error.message };
                if (!suppressMessage) {
                    appendMessageToChatLog(`❌ Ein interner Fehler ist aufgetreten: ${error.message}`, 'assistant');
                }
                return suppressMessage ? result : false;
            }
        }

        /* Regionsmarkierung Funktionen (überarbeitet für Mehrfachmarkierung) */
        function highlightDistrictMulti(searchTerm, color = CONFIG.colors.default, additive = true, regionType = null) {
            // Diese Funktion ist jetzt ein Wrapper für markAllMatchingRegions
            return markAllMatchingRegions(searchTerm, regionType, color);
        }

        /* OPTIMIERT: Verbesserte Funktion zum Suchen einer Region in der Tabelle */
        function findRegionInTable(searchTerm, requestedType = null, findAll = false) {
            if (!searchTerm || typeof searchTerm !== 'string' || regionsTable.length === 0) return null;

            const normalizedSearch = normalizeRegionName(searchTerm);
            const normalizedRequestedType = requestedType ? normalizeRegionType(requestedType) : null;

            let bestMatches = [];

            // Stufe 1: Exakte Namensübereinstimmung
            if (normalizedNameMap.has(normalizedSearch)) {
                const candidates = normalizedNameMap.get(normalizedSearch);
                if (normalizedRequestedType) {
                    const typeMatches = candidates.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                    if (typeMatches.length > 0) {
                        bestMatches = typeMatches;
                    } else {
                        // Wenn kein exakter Typ übereinstimmt, aber der Name passt, alle Kandidaten für diesen Namen nehmen
                        bestMatches = candidates;
                    }
                } else {
                    // Kein angeforderter Typ, alle Kandidaten für diesen Namen nehmen
                    bestMatches = candidates;
                }
            }

            // Stufe 2: Partielle Namensübereinstimmung (wenn noch keine exakte Namensübereinstimmung gefunden wurde)
            if (bestMatches.length === 0) {
                for (const [normalizedNameInMap, regions] of normalizedNameMap.entries()) {
                    // Prüfen, ob der Suchbegriff Teil des Regionsnamens ist oder umgekehrt
                    if (normalizedNameInMap.includes(normalizedSearch) || normalizedSearch.includes(normalizedNameInMap)) {
                        if (normalizedRequestedType) {
                            const typeMatches = regions.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                            if (typeMatches.length > 0) {
                                bestMatches = [...bestMatches, ...typeMatches];
                            } else {
                                // Wenn kein exakter Typ übereinstimmt, aber der Name passt, trotzdem berücksichtigen
                                bestMatches = [...bestMatches, ...regions];
                            }
                        } else {
                            // Kein angeforderter Typ, alle Regionen hinzufügen, die dem partiellen Namen entsprechen
                            bestMatches = [...bestMatches, ...regions];
                        }
                    }
                }
            }

            // Stufe 3: Fuzzy-Matching (wenn noch keine Übereinstimmungen gefunden wurden)
            if (bestMatches.length === 0) {
                let bestScore = 0;
                let fuzzyCandidates = [];
                for (const [normalizedNameInMap, regions] of normalizedNameMap.entries()) {
                    const score = calculateSimilarity(normalizedSearch, normalizedNameInMap);
                    if (score > bestScore && score > 0.6) { // Schwellenwert für Fuzzy-Match
                        bestScore = score;
                        fuzzyCandidates = regions; // Fuzzy-Kandidaten für einen besseren Score zurücksetzen
                    } else if (score === bestScore && score > 0.6) {
                        fuzzyCandidates = [...fuzzyCandidates, ...regions]; // Hinzufügen, wenn gleicher Score
                    }
                }
                if (fuzzyCandidates.length > 0) {
                    // Typfilter auf Fuzzy-Matches anwenden, aber auch hier flexibel sein
                    if (normalizedRequestedType) {
                        const typeMatches = fuzzyCandidates.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                        if (typeMatches.length > 0) {
                            bestMatches = typeMatches;
                        } else {
                            bestMatches = fuzzyCandidates; // Fallback auf Namensübereinstimmung, wenn der Typ nicht passt
                        }
                    } else {
                        bestMatches = fuzzyCandidates;
                    }
                }
            }

            // Endgültige Filterung und Rückgabe
            if (bestMatches.length === 0) {
                return null; // Keine Übereinstimmung gefunden
            }

            // Duplikate entfernen (kann bei partiellen Übereinstimmungen vorkommen)
            const uniqueBestMatches = Array.from(new Set(bestMatches.map(r => r.objid)))
                                        .map(objid => bestMatches.find(r => r.objid === objid));

            if (findAll) {
                return uniqueBestMatches;
            } else {
                // Wenn mehrere Übereinstimmungen, nach Typ priorisieren, falls möglich, oder die erste zurückgeben
                if (uniqueBestMatches.length > 1 && normalizedRequestedType) {
                    const exactTypeMatches = uniqueBestMatches.filter(candidate => normalizeRegionType(candidate.type) === normalizedRequestedType);
                    if (exactTypeMatches.length > 0) {
                        return exactTypeMatches[0];
                    }
                }
                // Fallback auf die erste Übereinstimmung, wenn keine spezifische Typ-Präferenz oder keine exakte Typ-Übereinstimmung
                return uniqueBestMatches[0];
            }
        }

        /* OPTIMIERT: Verbesserte Funktion zur Ermittlung des Farbnamens aus Hex-Wert */
        function getColorNameFromHex(hexColor) {
            for (const [name, hex] of Object.entries(CONFIG.colors)) {
                if (hex === hexColor) {
                    // Nur deutsche Namen zurückgeben (keine englischen Duplikate)
                    if (name === 'red') return 'Rot';
                    if (name === 'green') return 'Grün';
                    if (name === 'blue') return 'Blau';
                    if (name === 'yellow') return 'Gelb';
                    if (name === 'purple') return 'Lila';
                    if (name === 'teal') return 'Türkis';
                    if (name === 'pink') return 'Rosa';
                    if (name === 'gray') return 'Grau';
                    if (name === 'brown') return 'Braun';
                    if (name === 'lightblue') return 'Hellblau';
                    if (name === 'darkgreen') return 'Dunkelgrün';
                    if (name === 'lightgreen') return 'Hellgrün';

                    // Erste Buchstabe groß
                    return name.charAt(0).toUpperCase() + name.slice(1);
                }
            }
            return 'Eigene Farbe';
        }

        /* Berechnet Ähnlichkeit zwischen zwei Strings */
        function calculateSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;

            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;

            if (longer.length === 0) return 1.0;

            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / parseFloat(longer.length);
        }

        /* Implementierung der Levenshtein-Distanz für Fuzzy-Matching */
        function levenshteinDistance(str1, str2) {
            if (!str1 || !str2) return 0;

            const matrix = [];

            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // Substitution
                            matrix[i][j - 1] + 1,     // Insertion
                            matrix[i - 1][j] + 1      // Deletion
                        );
                    }
                }
            }

            return matrix[str2.length][str1.length];
        }

        /* OPTIMIERT: Verbesserte Entfernung von Markierungen */
        function removeMarking(regionName, regionType = null) {
            try {
                // Normalisiere den Regionsnamen für bessere Suche
                const normalizedName = normalizeRegionName(regionName);

                // OPTIMIERT: Verbesserte Regionstyp-Normalisierung
                const normalizedRequestedType = regionType ? normalizeRegionType(regionType) : null;

                let removed = 0;

                // Suche passende Markierungen
                for (const [key, data] of markedDistricts.entries()) {
                    // Normalisiere den gespeicherten Namen für Vergleich
                    const storedNormalized = normalizeRegionName(data.regionName);

                    // Prüfe auf Übereinstimmung mit normalisiertem Namen
                    if (storedNormalized === normalizedName ||
                        storedNormalized.includes(normalizedName) ||
                        normalizedName.includes(storedNormalized)) {

                        // Überprüfe Typ, wenn angegeben
                        let typeMatches = true;

                        if (regionType) {
                            const storedNormalizedType = normalizeRegionType(data.regionType);
                            typeMatches = storedNormalizedType === normalizedRequestedType;
                        }

                        if (typeMatches) {
                            // Entferne Markierung
                            geojsonLayer.resetStyle(data.layer);
                            markedDistricts.delete(key);

                            if (data.layer._path) {
                                data.layer._path.setAttribute('aria-checked', 'false');
                                data.layer._path.removeAttribute('aria-description');
                            }

                            removed++;
                        }
                    }
                }

                if (removed > 0) {
                    updateAllDisplays();
                    appendMessageToChatLog(`✅ ${removed} Markierung${removed !== 1 ? 'en' : ''} für ${regionName}${regionType ? ` (${regionType})` : ''} entfernt.`, 'assistant');
                    return true;
                } else {
                    appendMessageToChatLog(`❌ Keine Markierungen für "${regionName}"${regionType ? ` (${regionType})` : ''} gefunden.`, 'assistant');
                    return false;
                }
            } catch (error) {
                console.error(`Fehler beim Entfernen der Markierung: ${error.message}`);
                appendMessageToChatLog(`❌ Fehler beim Entfernen: ${error.message}`, 'assistant');
                return false;
            }
        }

        /* Löscht alle Markierungen */
        function clearAllMarkings() {
            try {
                markedDistricts.forEach((data, key) => {
                    if (data.layer && geojsonLayer) {
                        geojsonLayer.resetStyle(data.layer);

                        if (data.layer._path) {
                            data.layer._path.setAttribute('aria-checked', 'false');
                            data.layer._path.removeAttribute('aria-description');
                        }
                    }
                });

                const totalMarked = markedDistricts.size;
                markedDistricts.clear();
                colorIndex = 0;
                // NEU: Vertriebsbezirksauswahl zurücksetzen
                selectedSalesDistricts.clear();
                isFilterActive = false; // Filterzustand zurücksetzen

                updateAllDisplays();

                appendMessageToChatLog(`🔄 Alle ${totalMarked} Markierungen wurden gelöscht. Die Karte ist bereit für neue Markierungen.`, 'assistant');
            } catch (error) {
                console.error(`Fehler beim Löschen aller Markierungen: ${error.message}`);
                appendMessageToChatLog(`❌ Fehler beim Löschen: ${error.message}`, 'assistant');
            }
        }

        /* UI-Update Funktionen */
        function updateAllDisplays() {
            try {
                populateSalesGroupFilter(); // NEU: Aktualisiert das Vertriebsgruppen-Filter-Dropdown
                populateSalesDistrictCheckboxes(); // NEU: Aktualisiert die Vertriebsbezirks-Checkboxen
                updateSalesDistrictInfoboxes();
                applyRegionColoring(); // Ruft applyRegionColoring auf
                announceForScreenReader(`${markedDistricts.size} Regionen markiert.`);
            } catch (error) {
                console.error(`Fehler beim Aktualisieren der Anzeigen: ${error.message}`);
            }
        }

        /* NEU: Funktion zum Anwenden der Regionen-Färbung basierend auf dem Toggle-Status */
        function applyRegionColoring() {
            const selectedFilterGroup = DOM.salesGroupFilter.value; // Holt die ausgewählte Gruppe

            geojsonLayer.eachLayer(layer => {
                const props = layer.feature.properties;
                const combinedKey = `${props.gen}__${props.bez}__${props.objid}`;
                const markingData = markedDistricts.get(combinedKey);

                if (markingData) {
                    // Filter nach Vertriebsgruppe
                    const passesGroupFilter = selectedFilterGroup === "" ||
                                              markingData.salesEntries.some(entry => entry.salesGroup === selectedFilterGroup);

                    // Filter nach ausgewählten Vertriebsbezirken
                    // Wenn der Filter nicht aktiv ist, werden alle markierten Bezirke angezeigt.
                    // Wenn der Filter aktiv ist, werden nur die im selectedSalesDistricts Set enthaltenen Bezirke angezeigt.
                    const passesDistrictFilter = !isFilterActive ||
                                                 markingData.salesEntries.some(entry => selectedSalesDistricts.has(entry.salesDistrict));

                    const shouldDisplay = passesGroupFilter && passesDistrictFilter;

                    if (shouldDisplay) {
                        let targetColor;
                        if (showRevenueBasedColoring) {
                            targetColor = getRevenueBasedColor(markingData.salesEntries);
                            if (!targetColor) {
                                targetColor = markingData.displayColor;
                            }
                        } else {
                            targetColor = markingData.displayColor;
                        }

                        layer.setStyle({
                            fillColor: targetColor,
                            fillOpacity: 0.7,
                            color: targetColor,
                            weight: 3,
                            dashArray: '3, 3'
                        });
                        layer.bringToFront();
                    } else {
                        // Region ist markiert, aber durch den Filter ausgeblendet
                        geojsonLayer.resetStyle(layer); // Setzt auf Standard zurück
                    }
                } else {
                    // Region ist nicht markiert, immer Standardstil
                    geojsonLayer.resetStyle(layer);
                }
            });
        }

        function announceForScreenReader(message) {
            const announcer = document.createElement('div');
            announcer.className = 'sr-only';
            announcer.setAttribute('role', 'status');
            announcer.setAttribute('aria-live', 'polite');
            announcer.textContent = message;

            document.body.appendChild(announcer);
            setTimeout(() => document.body.removeChild(announcer), 3000);
        }

        /* ENTFERNT: updateMarkedRegionsDisplay Funktion, da das Panel entfernt wurde */

        /* NEU: Verbesserte Funktion zum Anzeigen der Hover-Info mit allen Vertriebsbezirksnamen */
        function showHoverInfo(e, layer, markingData) {
            if (!hoverInfoPopup) return;

            const props = layer.feature.properties;
            const regionName = props.gen || "Unbekannt";
            const regionType = props.bez || "Unbekannt";

            let contentHTML = `
                <div class="hover-info-row">
                    <span class="hover-info-label">Name:</span>
                    <span class="hover-info-value">${escapeHtml(regionName)}</span>
                </div>
                <div class="hover-info-row">
                    <span class="hover-info-label">Typ:</span>
                    <span class="hover-info-value">${escapeHtml(regionType)}</span>
                </div>`;

            if (markingData) {
                let displayedColor = markingData.displayColor;
                if (showRevenueBasedColoring) {
                    const revenueColor = getRevenueBasedColor(markingData.salesEntries);
                    if (revenueColor) {
                        displayedColor = revenueColor;
                    }
                }

                contentHTML += `
                    <div class="hover-info-row">
                        <span class="hover-info-label">Farbe:</span>
                        <span class="hover-info-value">
                            <span style="display:inline-block; width:10px; height:10px; background-color:${displayedColor}; border-radius:50%; margin-right:4px;"></span>
                            ${getColorNameFromHex(displayedColor)}
                        </span>
                    </div>`;

                if (markingData.salesEntries && markingData.salesEntries.length > 0) {
                    // NEU: Der administrative Gesamtumsatz für diese Region ist im ersten Eintrag verfügbar
                    // (da alle Einträge für dieselbe administrative Einheit denselben vollen Umsatz haben sollten)
                    const administrativeTotalRevenue = markingData.salesEntries[0].revenue || 0;

                    contentHTML += `<div style="margin-top: 5px; padding-top: 5px; border-top: 1px dotted #ccc;">`;
                    contentHTML += `
                        <div class="hover-info-row">
                            <span class="hover-info-label">Vertriebsbezirke:</span>
                            <span class="hover-info-value">${markingData.salesEntries.length}</span>
                        </div>`;

                    if (administrativeTotalRevenue > 0) {
                        contentHTML += `
                            <div class="hover-info-row">
                                <span class="hover-info-label">Gesamtumsatz (Admin.):</span>
                                <span class="hover-info-value">${new Intl.NumberFormat('de-DE').format(administrativeTotalRevenue)} €</span>
                            </div>`;
                    }

                    contentHTML += `<div class="sales-districts-list">`;
                    markingData.salesEntries.forEach(entry => {
                        if (entry.salesDistrict) {
                            contentHTML += `
                                <div class="sales-district-item">
                                    <span style="display:inline-block; width:8px; height:8px; background-color:${entry.color}; border-radius:50%; margin-right:4px;"></span>
                                    ${escapeHtml(entry.salesDistrict)}
                                    (${escapeHtml(entry.salesGroup || "keine Gruppe")})
                                    ${entry.revenue ? ` - ${new Intl.NumberFormat('de-DE').format(entry.revenue)} €` : ''}
                                </div>`;
                        }
                    });
                    contentHTML += `</div>`;
                    contentHTML += `</div>`;
                } else {
                    contentHTML += `
                        <div style="margin-top: 5px; padding-top: 5px; border-top: 1px dotted #ccc; text-align:center; font-style:italic;">
                            Keine Vertriebsdaten vorhanden
                        </div>`;
                }

                hoverInfoPopup.querySelector('.hover-info-footer').textContent = 'Klick zum Bearbeiten';
            } else {
                contentHTML += `
                    <div class="hover-info-row">
                        <span class="hover-info-label">Hover-Farbe:</span>
                        <span class="hover-info-value">
                            <span style="display:inline-block; width:10px; height:10px; background-color:${CONFIG.mapStyles.default.fillColor}; border-radius:50%; margin-right:4px;"></span>
                            ${getColorNameFromHex(CONFIG.mapStyles.default.fillColor)}
                        </span>
                    </div>`;
                hoverInfoPopup.querySelector('.hover-info-footer').textContent = 'Klick zum Markieren und Bearbeiten';
            }

            const hoverInfoContent = document.getElementById('hoverInfoContent');
            if (hoverInfoContent) {
                hoverInfoContent.innerHTML = contentHTML;
            }

            const containerPoint = e.containerPoint;
            const x = containerPoint.x + 15;
            const y = containerPoint.y - hoverInfoPopup.offsetHeight / 2;

            hoverInfoPopup.style.left = x + 'px';
            hoverInfoPopup.style.top = y + 'px';

            hoverInfoPopup.classList.add('visible');
        }

        /* NEU: Initialisierung des Hover-Info-Popups */
        function initializeHoverInfoPopup() {
            hoverInfoPopup = document.getElementById('hoverInfoPopup');
            if (!hoverInfoPopup) {
                hoverInfoPopup = document.createElement('div');
                hoverInfoPopup.id = 'hoverInfoPopup';
                hoverInfoPopup.className = 'hover-info-popup';
                hoverInfoPopup.setAttribute('role', 'tooltip');
                hoverInfoPopup.innerHTML = `
                    <div class="hover-info-title">Regionsinformation</div>
                    <div class="hover-info-content" id="hoverInfoContent"></div>
                    <div class="hover-info-footer">Klick zum Bearbeiten</div>
                `;
                document.body.appendChild(hoverInfoPopup);
            }
        }

        /* NEU: Entfernt Hover-Effekt und Info-Popup */
        function resetHighlightMulti(e) {
            const layer = e.target;
            if (!layer || !layer.feature || !layer.feature.properties) return;

            // Wenn der Layer nicht mehr gehovered wird, setzen wir currentHoveredLayer zurück
            if (currentHoveredLayer === layer) {
                currentHoveredLayer = null;
            }

            // Setze Stil immer auf den durch applyRegionColoring bestimmten Zustand zurück
            applyRegionColoring();

            // Verstecke das Popup
            if (hoverInfoPopup) {
                hoverInfoPopup.classList.remove('visible');
            }
        }

        /* NEU: Behandelt Klicks auf Regionen - Öffnet direkt den Bearbeitungsdialog */
        function toggleDistrictMarking(e) {
            try {
                const layer = e.target;
                if (!layer || !layer.feature || !layer.feature.properties) return;

                // Bestimme Eigenschaften des Features
                const gen = layer.feature.properties.gen;
                const bez = layer.feature.properties.bez || 'Unbekannt';
                const objid = layer.feature.properties.objid;

                // Erstelle eindeutigen Schlüssel mit objID
                let combinedKey = `${gen}__${bez}__${objid}`;

                // Prüfe, ob diese exakte Region bereits markiert ist
                let isMarked = markedDistricts.has(combinedKey);
                let existingMarking = null;

                // Alternative: Prüfe, ob irgendeine Markierung diese Layer-Referenz verwendet
                if (!isMarked) {
                    markedDistricts.forEach((data, key) => {
                        if (data.layer === layer) {
                            isMarked = true;
                            existingMarking = data;
                            combinedKey = key; // Verwende den vorhandenen Schlüssel
                        }
                    });
                } else {
                    existingMarking = markedDistricts.get(combinedKey);
                }

                // NEU: Wenn noch nicht markiert, markiere die Region mit Standardfarbe
                if (!isMarked) {
                    const color = CONFIG.defaultColors[colorIndex % CONFIG.defaultColors.length];
                    colorIndex++;

                    // Neue Markierung hinzufügen mit salesEntries-Array
                    markedDistricts.set(combinedKey, {
                        layer: layer,
                        regionName: gen,
                        regionType: bez,
                        timestamp: Date.now(),
                        objid: objid,
                        // Leere Vertriebsdaten-Array mit eindeutiger ID
                        salesEntries: [
                            {
                                id: generateUniqueId(),
                                color: color,
                                salesGroup: "",
                                salesDistrict: "",
                                revenue: 0
                            }
                        ],
                        displayColor: color
                    });

                    // Stil wird durch applyRegionColoring gesetzt
                    // layer.setStyle({
                    //     fillColor: color, fillOpacity: 0.7, color: color, weight: 3, dashArray: '3, 3'
                    // });
                    layer.bringToFront();

                    if (layer._path) {
                        layer._path.setAttribute('aria-checked', 'true');
                        layer._path.setAttribute('aria-description',
                            `${gen} (${bez}) markiert mit Farbe ${getColorNameFromHex(color)}`);
                    }

                    // Display aktualisieren
                    updateAllDisplays();
                }

                // NEU: Öffne direkt den Bearbeitungsdialog für die Region
                openEditDialog(combinedKey);

            } catch (error) {
                console.error(`Fehler bei Karteninteraktion: ${error.message}`);
            }
        }

        /* NEU: Hover-Effekt für Regionen mit Daten-Popup */
        function highlightFeatureMulti(e) {
            const layer = e.target;
            if (!layer || !layer.feature || !layer.feature.properties) return;

            // Speichern des aktuell gehoverden Layers
            currentHoveredLayer = layer;

            // Prüfen ob Region bereits markiert ist
            // Suchen nach einer Markierung mit dieser Layer-Referenz
            let isMarked = false;
            let markingData = null;

            markedDistricts.forEach(data => {
                if (data.layer === layer) {
                    isMarked = true;
                    markingData = data;
                }
            });

            if (!isMarked) {
                geojsonLayer.resetStyle(layer); // Setzt auf Standard zurück
                layer.setStyle(CONFIG.mapStyles.default); // Wendet Hover-Stil an
            }
            layer.bringToFront();

            // NEU: Hover-Info anzeigen
            showHoverInfo(e, layer, markingData);
        }

        /* OPTIMIERT: Initialisiere Farbpicker im Dialog mit Farblöschungsoption */
        function initializeColorPicker() {
            const colorPickerContainer = DOM.colorPicker; // OPTIMIERT: DOM-Referenz nutzen
            if (!colorPickerContainer) return;

            // Entferne bestehende Farb-Optionen aber behalte die Löschoption
            const removeColorOption = document.getElementById('removeColorOption');
            colorPickerContainer.innerHTML = '';

            // Füge zuerst die Löschoption wieder hinzu
            if (removeColorOption) {
                colorPickerContainer.appendChild(removeColorOption);
            } else {
                // Falls nicht vorhanden, erstelle die Farblöschungsoption
                const removeOption = document.createElement('div');
                removeOption.id = 'removeColorOption';
                removeOption.className = 'color-remove-option';
                removeOption.title = 'Farbe löschen';
                removeOption.setAttribute('role', 'radio');
                removeOption.setAttribute('aria-label', 'Farbe löschen');
                removeOption.setAttribute('aria-checked', 'false');
                removeOption.tabIndex = 0;

                // OPTIMIERT: Verbesserte Zugänglichkeit mit Tastaturunterstützung
                removeOption.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.click();
                    }
                });

                removeOption.addEventListener('click', function() { // OPTIMIERT: Event-Listener direkt registrieren
                    // Entferne 'selected' von allen Optionen
                    document.querySelectorAll('.color-option, .color-remove-option').forEach(option => {
                        option.classList.remove('selected');
                        option.setAttribute('aria-checked', 'false');
                    });

                    // Markiere die Löschoption als ausgewählt
                    this.classList.add('selected');
                    this.setAttribute('aria-checked', 'true');

                    // Setze den Farbwert auf "" (keine Farbe)
                    DOM.selectedColor.value = ""; // OPTIMIERT: DOM-Referenz nutzen
                });

                colorPickerContainer.appendChild(removeOption);
            }

            // Füge alle Farben als Optionen hinzu
            for (const [name, hex] of Object.entries(CONFIG.colors)) {
                // Überspringe englische Duplikate
                if (['red', 'green', 'blue', 'yellow', 'purple', 'teal', 'pink', 'gray', 'brown', 'lightblue', 'darkgreen', 'lightgreen'].includes(name)) {
                    continue;
                }

                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = hex;
                colorOption.setAttribute('data-color', hex);
                colorOption.setAttribute('data-name', name);
                colorOption.title = name.charAt(0).toUpperCase() + name.slice(1);
                colorOption.setAttribute('role', 'radio');
                colorOption.setAttribute('aria-label', name);
                colorOption.setAttribute('aria-checked', 'false');
                colorOption.tabIndex = 0;

                // OPTIMIERT: Verbesserte Zugänglichkeit mit Tastaturunterstützung
                colorOption.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.click();
                    }
                });

                colorOption.addEventListener('click', function() { // OPTIMIERT: Event-Listener direkt registrieren
                    // Entferne 'selected' von allen Optionen
                    document.querySelectorAll('.color-option, .color-remove-option').forEach(option => {
                        option.classList.remove('selected');
                        option.setAttribute('aria-checked', 'false');
                    });

                    // Markiere die ausgewählte Option
                    this.classList.add('selected');
                    this.setAttribute('aria-checked', 'true');

                    // Speichere die ausgewählte Farbe
                    DOM.selectedColor.value = this.getAttribute('data-color'); // OPTIMIERT: DOM-Referenz nutzen
                });

                colorPickerContainer.appendChild(colorOption);
            }
        }

        /* OPTIMIERT: Dialog zum Bearbeiten der Vertriebsdaten und Farbe mit mehreren Einträgen */
        function openEditDialog(regionKey) {
            try {
                const data = markedDistricts.get(regionKey);
                if (!data) return;

                // Setze den regionKey für späteren Zugriff
                DOM.editingRegionKey.value = regionKey; // OPTIMIERT: DOM-Referenz nutzen

                // OPTIMIERT: Dialogtitel mit Regionsname
                DOM.editDialogTitle.textContent = `Region bearbeiten: ${data.regionName}`; // OPTIMIERT: DOM-Referenz nutzen

                // Zeige die Liste der vorhandenen Vertriebseinträge
                DOM.salesEntriesList.innerHTML = ''; // OPTIMIERT: DOM-Referenz nutzen

                if (data.salesEntries && data.salesEntries.length > 0) {
                    data.salesEntries.forEach(entry => {
                        const entryDiv = document.createElement('div');
                        entryDiv.className = 'sales-entry-item';
                        entryDiv.setAttribute('role', 'listitem');
                        entryDiv.innerHTML = `
                            <div class="sales-entry-header">
                                <div class="entry-color-indicator" style="background-color: ${entry.color}"
                                     aria-label="Farbe: ${getColorNameFromHex(entry.color)}"></div>
                                <div class="entry-title">
                                    ${entry.salesDistrict || 'Kein Vertriebsbezirk'}
                                    (${entry.salesGroup || 'Keine Gruppe'})
                                </div>
                                <div class="sales-entry-details">
                                    <div>Umsatz: ${new Intl.NumberFormat('de-DE').format(entry.revenue || 0)} €</div>
                                </div>
                                <div class="entry-actions">
                                    <button class="btn-edit-entry" data-entry-id="${entry.id}"
                                            aria-label="Eintrag bearbeiten">Bearbeiten</button>
                                    <button class="btn-delete-entry" data-entry-id="${entry.id}"
                                            aria-label="Eintrag löschen">Löschen</button>
                                </div>
                            </div>
                        `;
                        DOM.salesEntriesList.appendChild(entryDiv); // OPTIMIERT: DOM-Referenz nutzen
                    });
                } else {
                    DOM.salesEntriesList.innerHTML = '<div class="no-entries-message" role="status">Keine Vertriebsdaten vorhanden</div>'; // OPTIMIERT: DOM-Referenz nutzen
                }

                // Zeige den Dialog und die Liste der Einträge
                DOM.salesEntriesList.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.addEntryForm.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.dialogOverlay.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.editSalesDialog.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden

                // Setze Fokus auf ersten Button für bessere Tastaturnavigation
                setTimeout(() => {
                    const firstButton = DOM.editSalesDialog.querySelector('button');
                    if (firstButton) firstButton.focus();
                }, 100);
            } catch (error) {
                console.error(`Fehler beim Öffnen des Bearbeitungsdialogs: ${error.message}`);
            }
        }

        function closeEditDialog() {
            DOM.dialogOverlay.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.editSalesDialog.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.editingRegionKey.value = ''; // OPTIMIERT: DOM-Referenz nutzen
            DOM.editingEntryId.value = ''; // OPTIMIERT: DOM-Referenz nutzen
        }

        /* NEU: Funktion zum Bearbeiten eines bestehenden Vertriebseintrags */
        function editEntry(entryId) {
            const regionKey = DOM.editingRegionKey.value; // OPTIMIERT: DOM-Referenz nutzen
            const data = markedDistricts.get(regionKey);
            if (!data || !data.salesEntries) return;

            const entry = data.salesEntries.find(e => e.id === entryId);
            if (!entry) return;

            // Initialisiere den Farbpicker
            initializeColorPicker();

            // Setze die Werte im Formular
            DOM.salesGroupInput.value = entry.salesGroup || ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.salesDistrictInput.value = entry.salesDistrict || ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.revenueInput.value = entry.revenue || ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.editingEntryId.value = entryId; // OPTIMIERT: DOM-Referenz nutzen
            DOM.selectedColor.value = entry.color; // OPTIMIERT: DOM-Referenz nutzen

            // Markiere die ausgewählte Farbe im Farbpicker
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
                option.setAttribute('aria-checked', 'false');
                if (option.getAttribute('data-color') === entry.color) {
                    option.classList.add('selected');
                    option.setAttribute('aria-checked', 'true');
                }
            });

            // Deaktiviere die Farblöschung
            const removeColorOption = document.getElementById('removeColorOption');
            if (removeColorOption) {
                removeColorOption.classList.remove('selected');
                removeColorOption.setAttribute('aria-checked', 'false');
            }

            // Zeige das Formular an
            DOM.salesEntriesList.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.addEntryForm.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden

            // Setze Fokus auf erstes Eingabefeld
            setTimeout(() => DOM.salesGroupInput.focus(), 100); // OPTIMIERT: DOM-Referenz nutzen
        }

        /* NEU: Funktion zum Anzeigen des Formulars für einen neuen Vertriebseintrag */
        function showAddEntryForm() {
            // Initialisiere den Farbpicker
            initializeColorPicker();

            // Leere das Formular
            DOM.salesGroupInput.value = ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.salesDistrictInput.value = ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.revenueInput.value = ""; // OPTIMIERT: DOM-Referenz nutzen
            DOM.editingEntryId.value = ""; // Kein Entry-ID bedeutet neuer Eintrag // OPTIMIERT: DOM-Referenz nutzen

            // Wähle eine Standardfarbe
            const defaultColor = CONFIG.colors.default;
            DOM.selectedColor.value = defaultColor; // OPTIMIERT: DOM-Referenz nutzen

            // Markiere die Standardfarbe im Farbpicker
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
                option.setAttribute('aria-checked', 'false');
                if (option.getAttribute('data-color') === defaultColor) {
                    option.classList.add('selected');
                    option.setAttribute('aria-checked', 'true');
                }
            });

            // Deaktiviere die Farblöschung
            const removeColorOption = document.getElementById('removeColorOption');
            if (removeColorOption) {
                removeColorOption.classList.remove('selected');
                removeColorOption.setAttribute('aria-checked', 'false');
            }

            // Zeige das Formular an
            DOM.salesEntriesList.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.addEntryForm.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden

            // Setze den Fokus auf das erste Feld
            setTimeout(() => DOM.salesGroupInput.focus(), 100); // OPTIMIERT: DOM-Referenz nutzen
        }

        /* NEU: Funktion zum Abbrechen der Bearbeitung/Hinzufügung */
        function cancelAddEntry() {
            // Zurück zur Übersicht der Einträge
            DOM.addEntryForm.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            DOM.salesEntriesList.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
        }
        /* OPTIMIERT: Speichern eines neuen oder bearbeiteten Vertriebseintrags */
        DOM.addEntryForm.addEventListener('submit', function(e) { // OPTIMIERT: Event-Listener direkt registrieren
            e.preventDefault();

            const regionKey = DOM.editingRegionKey.value; // OPTIMIERT: DOM-Referenz nutzen
            if (!regionKey || !markedDistricts.has(regionKey)) {
                closeEditDialog();
                return;
            }

            const data = markedDistricts.get(regionKey);
            const entryId = DOM.editingEntryId.value; // This is the ID if we are editing an existing entry // OPTIMIERT: DOM-Referenz nutzen
            const newColor = DOM.selectedColor.value || CONFIG.colors.default; // OPTIMIERT: DOM-Referenz nutzen

            // Get the form data, remove spaces for internal storage
            const formData = {
                salesGroup: DOM.salesGroupInput.value.trim() || "", // Removed regex check // OPTIMIERT: DOM-Referenz nutzen
                salesDistrict: DOM.salesDistrictInput.value.trim() || "", // Removed regex check // OPTIMIERT: DOM-Referenz nutzen
                revenue: DOM.revenueInput.value ? parseInt(DOM.revenueInput.value) : 0, // OPTIMIERT: DOM-Referenz nutzen
                color: newColor
            };

            let entryUpdated = false;

            // If we are editing an existing entry (entryId is present)
            if (entryId) {
                const entryIndex = data.salesEntries.findIndex(e => e.id === entryId);
                if (entryIndex >= 0) {
                    data.salesEntries[entryIndex] = {
                        ...data.salesEntries[entryIndex], // Keep original ID
                        ...formData
                    };
                    entryUpdated = true;
                }
            }

            // If we are adding a new entry (entryId is NOT present)
            else {
                if (!data.salesEntries) data.salesEntries = [];

                // Check if an entry with the same salesDistrict already exists for this region
                const existingEntryIndex = data.salesEntries.findIndex(e => e.salesDistrict === formData.salesDistrict);

                if (existingEntryIndex >= 0) {
                    // Overwrite the existing entry with the same salesDistrict
                    data.salesEntries[existingEntryIndex] = {
                        ...data.salesEntries[existingEntryIndex], // Keep original ID
                        ...formData
                    };
                    entryUpdated = true;
                } else {
                    // Add a new entry with a unique ID
                    data.salesEntries.push({
                        id: generateUniqueId(),
                        ...formData
                    });
                    entryUpdated = true;
                }
            }

            // Die Warnung, wenn nichts verändert wurde, kommt aktuell nicht,
            // weil 'entryUpdated' fast immer auf 'true' gesetzt wird, sobald das Formular bearbeitet wird.
            // Wenn Sie möchten, dass der Dialog nur bei tatsächlicher Änderung geschlossen wird,
            // müsste die Logik hier komplexer sein (Vergleich der alten und neuen Daten).
            // Fürs Erste lassen wir es so, damit der Dialog immer schließt.
            if (!entryUpdated) {
                console.warn("Entry was neither updated nor added. Check logic.");
                closeEditDialog();
                return;
            }

            // Aktualisiere die Anzeigefarbe als Mischung aller Eintragsfarben
            const colors = data.salesEntries.map(entry => entry.color);
            data.displayColor = mixColors(colors);

            // Aktualisiere die Kartenanzeige (wird von updateAllDisplays übernommen)
            // data.layer.setStyle({
            //     fillColor: data.displayColor,
            //     color: data.displayColor,
            //     fillOpacity: 0.7,
            //     weight: 3,
            //     dashArray: '3, 3'
            // });
            data.layer.bringToFront();

            if (data.layer._path) {
                // KORREKTUR: 'layer' zu 'data.layer' geändert
                data.layer._path.setAttribute('aria-checked', 'true'); // Sicherstellen, dass es als markiert gilt
                data.layer._path.setAttribute('aria-description',
                    `${data.regionName} (${data.regionType}) markiert mit gemischter Farbe ${getColorNameFromHex(data.displayColor)}`);
            }

            // Aktualisiere die Anzeigen
            updateAllDisplays();

            // Diese Zeilen sind jetzt auskommentiert, da der gesamte Dialog geschlossen wird
            // DOM.addEntryForm.classList.add('hidden');
            // DOM.salesEntriesList.classList.remove('hidden');
            // openEditDialog(regionKey);

            // Hier wird der gesamte "Region bearbeiten"-Dialog geschlossen
            closeEditDialog();

        });

        /* NEU: Funktion zum Löschen eines Vertriebseintrags */
        function deleteEntry(entryId) {
            if (!confirm("Möchten Sie diesen Vertriebsbezirk wirklich löschen?")) return;

            const regionKey = DOM.editingRegionKey.value; // OPTIMIERT: DOM-Referenz nutzen
            const data = markedDistricts.get(regionKey);
            if (!data || !data.salesEntries) return;

            // Entferne den Eintrag aus dem Array
            const entryIndex = data.salesEntries.findIndex(e => e.id === entryId);
            if (entryIndex >= 0) {
                data.salesEntries.splice(entryIndex, 1);

                // Wenn keine Einträge mehr vorhanden sind, entferne die Markierung
                if (data.salesEntries.length === 0) {
                    geojsonLayer.resetStyle(data.layer);
                    markedDistricts.delete(regionKey);

                    // Schließe den Dialog
                    closeEditDialog();
                }

                // Sonst aktualisiere die Anzeigefarbe
                else {
                    const colors = data.salesEntries.map(entry => entry.color);
                    data.displayColor = mixColors(colors);

                    // Stil wird durch applyRegionColoring gesetzt
                    // data.layer.setStyle({
                    //     fillColor: data.displayColor,
                    //     color: data.displayColor,
                    //     fillOpacity: 0.7,
                    //     weight: 3,
                    //     dashArray: '3, 3'
                    // });

                    // Aktualisiere die Liste der Einträge
                    openEditDialog(regionKey);
                }

                // Aktualisiere die Anzeigen
                updateAllDisplays();
            }
        }

        /* OPTIMIERT: Verbesserte Event-Listener für Regionen mit ARIA-Support */
        function onEachFeature(feature, layer) {
            try {
                if (feature.properties) {
                    const props = feature.properties;

                    if (props.gen && typeof props.gen === 'string' && props.gen.trim().length > 0) {
                        const genName = props.gen.trim();
                        const bezType = props.bez || "Unbekannt";
                        // KORREKTUR: objid ist direkt in props, nicht props.properties
                        const objid = props.objid;

                        // 1. Erzeuge einen kombinierten Schlüssel aus Name und Typ
                        const combinedKey = `${genName}__${bezType}__${objid}`; // objid in Key für Eindeutigkeit

                        // 2. Speichere Layer-Info mit dem kombinierten Schlüssel
                        districtData[combinedKey] = {
                            layer: layer,
                            feature: feature,
                            properties: props,
                            regionName: genName,
                            regionType: bezType,
                            objid: objid
                        };

                        // 3. Füge zum Namensindex hinzu für schnellere Suche
                        if (!nameToKeysMap.has(genName)) {
                            nameToKeysMap.set(genName, []);
                        }
                        nameToKeysMap.get(genName).push(combinedKey);

                        // 4. Speichere Layer-Referenz nach objid
                        if (objid) {
                            objIdToLayerMap.set(objid, layer);
                        }
                    }
                }

                // Event-listener hinzufügen
                layer.on({
                    mouseover: (e) => highlightFeatureMulti(e),
                    mouseout: (e) => resetHighlightMulti(e),
                    click: (e) => toggleDistrictMarking(e)
                });

                // ARIA-Attribute für bessere Zugänglichkeit
                if (layer._path && feature.properties && feature.properties.gen) {
                    const regionType = feature.properties.bez || "Unbekannt";
                    layer._path.setAttribute('role', 'button');
                    layer._path.setAttribute('aria-label', `${regionType} ${feature.properties.gen}`);
                    layer._path.setAttribute('aria-checked', 'false');
                    layer._path.setAttribute('tabindex', '0');

                    // Tastatur-Interaktion
                    layer._path.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter' || e.key === ' ') {
                            toggleDistrictMarking({ target: layer });
                            e.preventDefault();
                        }
                    });
                }
            } catch (error) {
                console.error(`Fehler bei Feature-Registrierung: ${error.message}`);
            }
        }

        /* Sendet vordefinierten Prompt */
        function sendPrompt(promptText) {
            if (!promptText) return;

            DOM.questionInput.value = promptText;
            sendMessage();
        }

        /* Fügt Nachricht zum Chat-Verlauf hinzu */
        function appendMessageToChatLog(text, sender, action = null) {
            try {
                if (!text || !sender) return;

                const bubble = document.createElement('div');
                bubble.classList.add('bubble', sender);

                const senderLabel = sender === 'user' ? 'Sie' : 'KI-Assistent';
                let content = `<strong>${senderLabel}:</strong><br>${text}`;

                if (action) {
                    content += `<div class="assistant-action-buttons">`;
                    if (action.type === 'confirm') {
                        content += `<button onclick="${action.onConfirm}" aria-label="Bestätigen">Ja, ausführen</button>`;
                        content += `<button onclick="${action.onCancel || ''}" aria-label="Abbrechen">Abbrechen</button>`;
                    }
                    content += `</div>`;
                }

                bubble.innerHTML = content;

                if (sender === 'assistant') {
                    bubble.setAttribute('role', 'region');
                    bubble.setAttribute('aria-label', 'Antwort des KI-Assistenten');
                } else {
                    bubble.setAttribute('aria-label', 'Ihre Nachricht');
                }

                DOM.chatlog.appendChild(bubble); // OPTIMIERT: DOM-Referenz nutzen
                DOM.chatlog.scrollTop = DOM.chatlog.scrollHeight; // OPTIMIERT: DOM-Referenz nutzen

                if (sender === 'assistant') {
                    const announcement = document.createElement('div');
                    announcement.setAttribute('role', 'status');
                    announcement.setAttribute('aria-live', 'polite');
                    announcement.className = 'sr-only';
                    announcement.textContent = 'Neue Antwort erhalten';
                    document.body.appendChild(announcement);

                    setTimeout(() => {
                        if (document.body.contains(announcement)) {
                            document.body.removeChild(announcement);
                        }
                    }, 3000);
                }
            } catch (error) {
                console.error(`Fehler beim Hinzufügen zum Chat: ${error.message}`);
            }
        }

        /* Zeigt Tipp-Indikator an */
        function showTypingIndicator() {
            removeTypingIndicator();

            const bubble = document.createElement('div');
            bubble.classList.add('bubble', 'assistant', 'typing-indicator');
            bubble.setAttribute('aria-label', 'KI denkt nach');
            bubble.setAttribute('role', 'status');

            bubble.innerHTML = `<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>`;
            DOM.chatlog.appendChild(bubble); // OPTIMIERT: DOM-Referenz nutzen
            DOM.chatlog.scrollTop = DOM.chatlog.scrollHeight; // OPTIMIERT: DOM-Referenz nutzen
        }

        /* Entfernt Tipp-Indikator */
        function removeTypingIndicator() {
            const indicator = document.querySelector('.typing-indicator');
            if (indicator) indicator.remove();
        }

        /* Mobile-Responsive Funktionen */
        function setupMobileResponsive() {
            function checkMobileLayout() {
                if (window.innerWidth <= 1024) {
                    DOM.mobileSidebarToggle.style.display = 'flex'; // Ensure it's visible
                    // WICHTIGE ÄNDERUNG: Die 'active'-Klasse sollte NICHT hier entfernt werden.
                    // Sie sollte nur durch die explizite Aktion des Benutzers (Klick auf den Toggle-Button) umgeschaltet werden.
                    // Wenn die Sidebar bereits aktiv ist, soll sie aktiv bleiben.
                    // Wenn sie nicht aktiv ist, sorgt ihr Standard-CSS (transform: translateX(100%)) dafür, dass sie ausgeblendet bleibt.
                } else {
                    DOM.mobileSidebarToggle.style.display = 'none'; // Hide on larger screens
                    // Auf größeren Bildschirmen stellen Sie sicher, dass die 'active'-Klasse entfernt wird,
                    // damit die Sidebar zu ihrer standardmäßigen Desktop-Positionierung (die sichtbar ist) zurückkehrt.
                    DOM.sidebar.classList.remove('active'); // OPTIMIERT: CSS-Klasse verwenden
                }
            }

            // OPTIMIERT: Event-Listener direkt registrieren
            DOM.mobileSidebarToggle.addEventListener('click', function() {
                DOM.sidebar.classList.toggle('active'); // OPTIMIERT: CSS-Klasse verwenden

                const isOpen = DOM.sidebar.classList.contains('active'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.mobileSidebarToggle.setAttribute('aria-label',
                    isOpen ? 'Schließe Steuerung' : 'Öffne Steuerung');
                DOM.mobileSidebarToggle.innerHTML = isOpen ?
                    '<span aria-hidden="true">×</span>' :
                    '<span aria-hidden="true">≡</span>';
            });

            // Initial call to set up the correct state
            checkMobileLayout();
            // Add event listener for window resize
            window.addEventListener('resize', checkMobileLayout);
        }

        /* ÜBERARBEITET: Speichern und Laden von Markierungen als Dateien mit Vertriebsdaten und Farben */
        function saveMarkings() {
            try {
                if (markedDistricts.size === 0 && selectedSalesDistricts.size === 0 && !isFilterActive) {
                    appendMessageToChatLog("❌ Es gibt keine Daten zum Speichern.", 'assistant');
                    return;
                }

                // Konvertiere die Map in ein serialisierbares Format
                const markingsToSave = [];

                markedDistricts.forEach((data, key) => {
                    markingsToSave.push({
                        key: key,
                        regionName: data.regionName,
                        regionType: data.regionType,
                        objid: data.objid,
                        displayColor: data.displayColor,
                        salesEntries: data.salesEntries || []
                    });
                });

                // Erstelle ein Exportobjekt mit Metadaten
                const exportData = {
                    version: "2.2", // Version aktualisiert für isFilterActive
                    timestamp: Date.now(),
                    colorIndex: colorIndex,
                    markings: markingsToSave,
                    selectedSalesDistricts: Array.from(selectedSalesDistricts), // NEU: Speichere ausgewählte Vertriebsbezirke
                    isFilterActive: isFilterActive // NEU: Speichere den Filterzustand
                };

                // Konvertiere in JSON
                const jsonData = JSON.stringify(exportData, null, 2);

                // Erstelle eine temporäre URL für den Download
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Erstelle einen Download-Link und klicke darauf
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = `multi-landkreis-markierungen-${new Date().toISOString().slice(0,10)}.json`;
                downloadLink.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                document.body.appendChild(downloadLink);
                downloadLink.click();

                // Bereinige
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                    document.body.removeChild(downloadLink);
                }, 100);

                appendMessageToChatLog(
                    `💾 ${markingsToSave.length} Datensätze wurden als Datei gespeichert!`,
                    'assistant'
                );
            } catch (error) {
                console.error(`Fehler beim Speichern der Daten: ${error.message}`);
                appendMessageToChatLog(`❌ Fehler beim Speichern: ${error.message}`, 'assistant');
            }
        }

        /* OPTIMIERT: Laden von Markierungen mit Vertriebsdaten und Farben */
        function loadMarkings() {
            try {
                // Erstelle einen unsichtbaren Datei-Input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                fileInput.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                fileInput.setAttribute('aria-label', 'Datei zum Laden von Markierungen auswählen');
                document.body.appendChild(fileInput);

                // Wenn eine Datei ausgewählt wurde
                fileInput.onchange = function(e) {
                    const file = e.target.files[0];
                    if (!file) {
                        document.body.removeChild(fileInput);
                        return;
                    }

                    const reader = new FileReader();

                    reader.onload = function(event) {
                        try {
                            const content = event.target.result;
                            const importData = JSON.parse(content);

                            // Prüfe auf gültiges Format
                            if (!importData.markings || !Array.isArray(importData.markings)) {
                                throw new Error("Die Datei enthält keine gültigen Markierungsdaten");
                            }

                            // Lösche vorhandene Markierungen (setzt auch selectedSalesDistricts und isFilterActive zurück)
                            clearAllMarkings();

                            // Wende gespeicherte Markierungen an
                            let loadedCount = 0;
                            let failedCount = 0;

                            importData.markings.forEach(marking => {
                                // Finde die entsprechende Region
                                if (marking.objid) {
                                    const layer = objIdToLayerMap.get(marking.objid);

                                    if (layer) {
                                        // Überprüfen auf das neue Format mit salesEntries
                                        const salesEntries = marking.salesEntries || [
                                            {
                                                id: generateUniqueId(),
                                                color: marking.color || CONFIG.colors.default,
                                                salesGroup: marking.salesGroup || "",
                                                salesDistrict: marking.salesDistrict || "",
                                                revenue: marking.revenue || 0
                                            }
                                        ];

                                        // Stelle sicher, dass jeder Eintrag eine ID hat
                                        salesEntries.forEach(entry => {
                                            if (!entry.id) entry.id = generateUniqueId();
                                        });

                                        // Stil setzen mit der gespeicherten Anzeigefarbe oder berechneten Mischfarbe
                                        const displayColor = marking.displayColor || mixColors(salesEntries.map(e => e.color));

                                        // layer.setStyle({
                                        //     fillColor: displayColor,
                                        //     fillOpacity: 0.7,
                                        //     color: displayColor,
                                        //     weight: 3,
                                        //     dashArray: '3, 3'
                                        // });
                                        layer.bringToFront();

                                        // Markierung speichern
                                        markedDistricts.set(marking.key, {
                                            layer: layer,
                                            regionName: marking.regionName,
                                            regionType: marking.regionType,
                                            timestamp: Date.now(),
                                            objid: marking.objid,
                                            salesEntries: salesEntries,
                                            displayColor: displayColor
                                        });

                                        if (layer._path) {
                                            layer._path.setAttribute('aria-checked', 'true');
                                            layer._path.setAttribute('aria-description',
                                                `${marking.regionName} (${marking.regionType}) markiert`);
                                        }

                                        loadedCount++;
                                    } else {
                                        failedCount++;
                                    }
                                } else {
                                    failedCount++;
                                }
                            });

                            // Setze Farbindex zurück, falls vorhanden
                            if (importData.colorIndex !== undefined) {
                                colorIndex = importData.colorIndex;
                            }

                            // NEU: Lade ausgewählte Vertriebsbezirke und Filterzustand
                            if (importData.selectedSalesDistricts && Array.isArray(importData.selectedSalesDistricts)) {
                                selectedSalesDistricts = new Set(importData.selectedSalesDistricts);
                            } else {
                                selectedSalesDistricts.clear(); // Falls nicht vorhanden oder ungültig, leeren
                            }
                            // isFilterActive sollte nur auf true gesetzt werden, wenn es explizit im Import ist,
                            // oder wenn selectedSalesDistricts nach dem Laden nicht leer ist (für ältere Versionen).
                            // Wenn importData.isFilterActive existiert, verwenden wir es. Ansonsten leiten wir es ab.
                            if (typeof importData.isFilterActive === 'boolean') {
                                isFilterActive = importData.isFilterActive;
                            } else {
                                // Für ältere Versionen ohne isFilterActive: Wenn selectedSalesDistricts nach dem Laden nicht leer ist,
                                // bedeutet das, dass der Filter aktiv war.
                                isFilterActive = selectedSalesDistricts.size > 0;
                            }

                            // Aktualisiere Anzeige
                            updateAllDisplays(); // Ruft applyRegionColoring auf

                            appendMessageToChatLog(
                                `📂 ${loadedCount} Datensätze wurden aus der Datei geladen!` +
                                (failedCount > 0 ? `\n❓ ${failedCount} Datensätze konnten nicht wiederhergestellt werden.` : ''),
                                'assistant'
                            );
                        } catch (error) {
                            console.error(`Fehler beim Verarbeiten der geladenen Datei: ${error.message}`);
                            appendMessageToChatLog(`❌ Fehler beim Laden der Datei: ${error.message}`, 'assistant');
                        } finally {
                            document.body.removeChild(fileInput);
                        }
                    };

                    reader.onerror = function() {
                        appendMessageToChatLog("❌ Die Datei konnte nicht gelesen werden.", 'assistant');
                        document.body.removeChild(fileInput);
                    };

                    reader.readAsText(file);
                };

                // Öffne den Datei-Dialog
                fileInput.click();

            } catch (error) {
                console.error(`Fehler beim Laden der Daten: ${error.message}`);
                appendMessageToChatLog(`❌ Fehler beim Laden: ${error.message}`, 'assistant');
            }
        }

        /* OPTIMIERT: Funktion zum Aggregieren der Umsatzdaten nach Vertriebsbezirk (administrative Sicht) */
        function aggregateSalesDistrictData() {
            try {
                const salesDistrictData = {};

                markedDistricts.forEach((data) => {
                    if (!data.salesEntries || data.salesEntries.length === 0) return;

                    const regionName = data.regionName;
                    const regionType = data.regionType;
                    const regionObjid = data.objid;

                    data.salesEntries.forEach(entry => {
                        if (!entry.salesDistrict) return;

                        const district = entry.salesDistrict;

                        if (!salesDistrictData[district]) {
                            salesDistrictData[district] = {
                                salesDistrict: district,
                                salesGroup: '',
                                conceptualRegions: new Map(), // Map zum Speichern konzeptioneller Regionen (Name__Typ -> {Daten})
                                totalRevenue: 0, // Gesamtumsatz für diesen Vertriebsbezirk (Summe der administrativen Einheiten)
                                center: null,
                                entryCount: 0, // Gesamtzahl der Sales Entries für diesen Vertriebsbezirk
                                layerCount: 0 // Für die Mittelpunktberechnung
                            };
                        }

                        salesDistrictData[district].entryCount++; // Zählt weiterhin die Anzahl der Sales Entries

                        const conceptualRegionKey = `${regionName}__${regionType}`;
                        let conceptualRegion = salesDistrictData[district].conceptualRegions.get(conceptualRegionKey);

                        if (!conceptualRegion) {
                            conceptualRegion = {
                                name: regionName,
                                type: regionType,
                                objids: new Set(), // Set zum Verfolgen eindeutiger objids, die zu dieser konzeptionellen Region gehören
                                totalRevenue: 0, // Umsatz für diese konzeptionelle Region (der administrative Gesamtumsatz)
                                entryCount: 0 // Anzahl der Sales Entries für diese konzeptionelle Region
                            };
                            salesDistrictData[district].conceptualRegions.set(conceptualRegionKey, conceptualRegion);
                        }

                        // Füge die objid hinzu, um die geografischen Teile zu verfolgen
                        conceptualRegion.objids.add(regionObjid);
                        conceptualRegion.entryCount++;

                        // WICHTIGE LOGIKÄNDERUNG:
                        // Der Umsatz der administrativen Einheit (entry.revenue) wird nur einmal zur conceptualRegion.totalRevenue
                        // und zum salesDistrictData[district].totalRevenue addiert, wenn es sich um den ersten geografischen Teil
                        // dieser spezifischen administrativen Einheit (definiert durch Name, Typ und objid) handelt,
                        // der zu diesem Vertriebsbezirk beiträgt.
                        // Die Bedingung `conceptualRegion.objids.size === 1` stellt sicher, dass dies nur beim ersten
                        // geografischen Teil dieser konzeptionellen Region geschieht, um Doppelzählungen zu vermeiden.
                        // Der `entry.revenue` enthält den vollen administrativen Umsatz, der für alle geografischen Teile derselben
                        // administrativen Einheit gleich sein sollte.
                        if (conceptualRegion.objids.size === 1) {
                            conceptualRegion.totalRevenue = entry.revenue || 0; // Setze den administrativen Gesamtumsatz für die konzeptionelle Region
                            salesDistrictData[district].totalRevenue += (entry.revenue || 0); // Addiere zum Gesamtumsatz des Vertriebsbezirks
                        }

                        // Setze die Vertriebsgruppe (nehme die erste gefundene)
                        if (!salesDistrictData[district].salesGroup && entry.salesGroup) {
                            salesDistrictData[district].salesGroup = entry.salesGroup;
                        }

                        // Berechne den Mittelpunkt (gewichteter Durchschnitt) - basiert weiterhin auf tatsächlichen objids
                        const layer = objIdToLayerMap.get(regionObjid);
                        if (layer && layer.getCenter) {
                            const center = layer.getCenter();
                            const currentCount = salesDistrictData[district].layerCount;
                            const currentCenter = salesDistrictData[district].center;

                            if (!currentCenter) {
                                salesDistrictData[district].center = center;
                            } else {
                                const lat = (currentCenter.lat * currentCount + center.lat) / (currentCount + 1);
                                const lng = (currentCenter.lng * currentCount + center.lng) / (currentCount + 1);
                                salesDistrictData[district].center = L.latLng(lat, lng);
                            }
                            salesDistrictData[district].layerCount++;
                        }
                    });
                });

                // Konvertiere die conceptualRegions Map in ein Array für die einfachere Iteration in der UI
                for (const districtKey in salesDistrictData) {
                    salesDistrictData[districtKey].regions = Array.from(salesDistrictData[districtKey].conceptualRegions.values());
                    // Sortiere konzeptionelle Regionen nach Namen für eine konsistente Anzeige
                    salesDistrictData[districtKey].regions.sort((a, b) => a.name.localeCompare(b.name));
                }

                return salesDistrictData;
            } catch (error) {
                console.error(`Fehler beim Aggregieren der Vertriebsdaten: ${error.message}`);
                return {};
            }
        }

        /* GEÄNDERT: Aktualisiert die Infoboxen für Vertriebsbezirke mit Kollisionsvermeidung */
        function updateSalesDistrictInfoboxes() {
            try {
                // Entferne alle vorhandenen Infoboxen
                for (const district in salesDistrictInfoboxes) {
                    if (salesDistrictInfoboxes[district].parentNode) {
                        salesDistrictInfoboxes[district].parentNode.removeChild(salesDistrictInfoboxes[district]);
                    }
                }
                salesDistrictInfoboxes = {};

                // NEU: Nur erstellen, wenn Infoboxen angezeigt werden sollen UND Zoom-Level passt
                if (!showSalesDistrictInfoboxes || leafletMap.getZoom() < MIN_ZOOM_FOR_INFOBOXES) {
                    return;
                }

                // Aggregiere Vertriebsdaten
                const salesDistrictData = aggregateSalesDistrictData();

                // NEU: Array zum Speichern der Infobox-Informationen für die Positionierung
                const infoboxesToProcess = [];

                // Erstelle neue Infoboxen und speichere ihre Referenzen und initialen Positionen
                for (const district in salesDistrictData) {
                    const data = salesDistrictData[district];

                    // NEU: Filtern nach ausgewählten Vertriebsbezirken
                    // Zeige Infobox nur, wenn Filter nicht aktiv ist ODER der Bezirk explizit ausgewählt ist.
                    if (isFilterActive && !selectedSalesDistricts.has(district)) {
                        continue; // Überspringe diesen Bezirk, wenn er nicht ausgewählt ist und der Filter aktiv ist
                    }

                    // Nur Infoboxen für Bezirke mit Zentrum erstellen
                    if (data.center) {
                        const infobox = document.createElement('div');
                        infobox.className = 'sales-district-infobox';
                        infobox.setAttribute('role', 'button'); /* Rolle für Klickbarkeit */
                        infobox.setAttribute('aria-label', `Vertriebsbezirk ${data.salesDistrict} Details anzeigen`);
                        infobox.setAttribute('data-district-name', data.salesDistrict); /* Speichert den Namen für den Klick-Handler */

                        // Setze den Inhalt nur auf den Vertriebsbezirksnamen
                        infobox.innerHTML = `<div class="sales-district-infobox-title">${escapeHtml(data.salesDistrict)}</div>`;

                        // Füge Klick-Handler hinzu
                        infobox.addEventListener('click', () => openSalesDistrictDetailPopup(data.salesDistrict)); // OPTIMIERT: Event-Listener registrieren

                        // Füge Infobox zum Dokument hinzu (temporär, um Breite/Höhe zu erhalten)
                        document.body.appendChild(infobox);

                        // Berechne die initiale Bildschirmposition
                        const point = leafletMap.latLngToContainerPoint(data.center);

                        infoboxesToProcess.push({
                            element: infobox,
                            districtName: data.salesDistrict,
                            originalLatLng: data.center, // Store original LatLng for map move
                            originalX: point.x,
                            originalY: point.y,
                            currentX: point.x, // These will be adjusted
                            currentY: point.y, // These will be adjusted
                            width: infobox.offsetWidth,
                            height: infobox.offsetHeight
                        });

                        // Speichere Referenz (für spätere Entfernung)
                        salesDistrictInfoboxes[district] = infobox;
                    }
                }

                // NEU: Kollisionserkennung und Repositionierung
                // Sortiere die Boxen nach ihrer Y-Koordinate, um von oben nach unten zu verarbeiten
                infoboxesToProcess.sort((a, b) => a.originalY - b.originalY);

                const verticalPadding = 5; // Vertikaler Abstand zwischen gestapelten Boxen

                // Einfacher Algorithmus zur Kollisionsvermeidung (vertikale Stapelung)
                // Iteriere über alle Boxen und verschiebe sie, wenn sie mit vorherigen Boxen überlappen
                for (let i = 0; i < infoboxesToProcess.length; i++) {
                    const currentBox = infoboxesToProcess[i];

                    // Initialisiere die aktuelle Position mit der ursprünglichen
                    currentBox.currentX = currentBox.originalX;
                    currentBox.currentY = currentBox.originalY;

                    for (let j = 0; j < i; j++) {
                        const previousBox = infoboxesToProcess[j];

                        // Überprüfe auf Überlappung (Bounding Box Collision)
                        // Prüfe, ob sich die X-Bereiche überlappen UND die Y-Bereiche überlappen
                        if (currentBox.currentX < previousBox.currentX + previousBox.width &&
                            currentBox.currentX + currentBox.width > previousBox.currentX &&
                            currentBox.currentY < previousBox.currentY + previousBox.height &&
                            currentBox.currentY + currentBox.height > previousBox.currentY) {

                            // Überlappung erkannt: Verschiebe die aktuelle Box nach unten
                            currentBox.currentY = previousBox.currentY + previousBox.height + verticalPadding;
                        }
                    }
                }

                // Wende die angepassten Positionen auf die DOM-Elemente an
                infoboxesToProcess.forEach(box => {
                    box.element.style.left = (box.currentX - box.width / 2) + 'px';
                    box.element.style.top = (box.currentY - box.height / 2) + 'px';
                    box.element.style.opacity = '1'; // Make visible with fade-in
                });

            } catch (error) {
                console.error(`Fehler beim Aktualisieren der Vertriebsbezirk-Infoboxes: ${error.message}`);
            }
        }

        /* NEU: Funktion zum Öffnen des Detail-Popups für Vertriebsbezirke */
        function openSalesDistrictDetailPopup(districtName) {
            const salesDistrictData = aggregateSalesDistrictData();
            const data = salesDistrictData[districtName];

            if (!data) {
                console.warn(`Keine Daten für Vertriebsbezirk ${districtName} gefunden.`);
                return;
            }

            // Fülle das Popup mit Daten
            DOM.detailDistrict.textContent = data.salesDistrict;
            DOM.detailGroup.textContent = data.salesGroup || 'N/A';
            DOM.detailRevenue.textContent = `${new Intl.NumberFormat('de-DE').format(data.totalRevenue)} €`;
            // Jetzt wird die Anzahl der konzeptionellen Regionen angezeigt
            DOM.detailRegionCount.textContent = data.regions.length;
            DOM.detailEntryCount.textContent = data.entryCount;

            // Liste der Regionen
            DOM.detailRegionList.innerHTML = '';
            if (data.regions.length > 0) {
                // Iteriere über die konzeptionellen Regionen
                data.regions.forEach(conceptualRegion => {
                    const listItem = document.createElement('li');
                    listItem.className = 'detail-list-item';
                    let regionText = `${escapeHtml(conceptualRegion.name)} (${escapeHtml(conceptualRegion.type)})`;

                    // Füge die Anzahl der zugrunde liegenden objids hinzu, wenn mehr als eine
                    if (conceptualRegion.objids.size > 1) {
                        regionText += ` (${conceptualRegion.objids.size} Teile)`;
                    }

                    // Füge den Gesamtumsatz für diese konzeptionelle Region hinzu
                    if (conceptualRegion.totalRevenue > 0) {
                        regionText += ` - ${new Intl.NumberFormat('de-DE').format(conceptualRegion.totalRevenue)} €`;
                    }
                    listItem.textContent = regionText;
                    DOM.detailRegionList.appendChild(listItem);
                });
            } else {
                const listItem = document.createElement('li');
                listItem.textContent = 'Keine zugeordneten Regionen.';
                DOM.detailRegionList.appendChild(listItem);
            }

// Setzt die Kartenansicht auf die ursprüngliche Zoom-Ebene und Position zurück
            leafletMap.setView([51.16, 10.45], 7);

            // Zeige das Popup und das Overlay
            DOM.salesDistrictDetailPopup.classList.remove('hidden');
            DOM.dialogOverlay.classList.remove('hidden');
        }

        /* NEU: Funktion zum Schließen des Detail-Popups für Vertriebsbezirke */
        function closeSalesDistrictDetailPopup() {
            DOM.salesDistrictDetailPopup.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            // ENTFERNT: Die Zeile DOM.dialogOverlay.classList.add('hidden'); wurde hier entfernt.
        }

        /* NEU: Eine generische Funktion zum Schließen aller offenen Dialoge, die das Overlay verwenden */
        function closeAnyOpenDialogs() {
            let dialogClosed = false;
            // Prüfe, ob der Bearbeitungsdialog geöffnet ist und schließe ihn
            if (!DOM.editSalesDialog.classList.contains('hidden')) {
                closeEditDialog(); // Diese Funktion schließt auch das Overlay
                dialogClosed = true;
            }
            // Prüfe, ob der Vertriebsbezirks-Detaildialog geöffnet ist und schließe ihn
            if (!DOM.salesDistrictDetailPopup.classList.contains('hidden')) {
                // Hier rufen wir die spezifische Schließfunktion auf,
                // die sich nun nur um das Ausblenden des Popups selbst kümmert.
                DOM.salesDistrictDetailPopup.classList.add('hidden');
                dialogClosed = true;
            }
            // Wenn kein spezifischer Dialog geschlossen wurde, aber das Overlay sichtbar ist,
            // dann schließe das Overlay explizit (dies sollte nur passieren, wenn alle Dialoge schon zu sind).
            if (!dialogClosed && !DOM.dialogOverlay.classList.contains('hidden')) {
                DOM.dialogOverlay.classList.add('hidden');
            }

 // Unabhängig davon, welcher Dialog geschlossen wurde (oder ob keiner spezifisch geschlossen wurde,
            // aber das Overlay sichtbar ist), stellen wir sicher, dass das Overlay ausgeblendet wird.
            DOM.dialogOverlay.classList.add('hidden');
        }


        /* NEU: Toggle für Vertriebsbezirk-Infoboxen */
        DOM.salesDistrictToggle.addEventListener('change', function() { // OPTIMIERT: Event-Listener direkt registrieren
            showSalesDistrictInfoboxes = this.checked;
            updateSalesDistrictInfoboxes(); // Ruft die Funktion auf, die auch den Zoom-Level prüft
        });

        /* NEU: Toggle für Umsatzvolumen-Färbung */
        DOM.revenueColoringToggle.addEventListener('change', function() { // OPTIMIERT: Event-Listener direkt registrieren
            showRevenueBasedColoring = this.checked;
            applyRegionColoring(); // Farben neu anwenden
        });

        /* NEU: Aktualisiere Infoboxen bei Karten-Move */
        function updateInfoboxPositionsOnMapMove() {
            // Nur aktualisieren, wenn Infoboxen angezeigt werden sollen
            if (!showSalesDistrictInfoboxes) return;

            // Führe die gesamte Update-Logik erneut aus, um die Positionen einschließlich der Kollisionsvermeidung neu zu berechnen
            updateSalesDistrictInfoboxes();
        }

        /* NEU: Funktion zum Befüllen des Vertriebsgruppen-Filter-Dropdowns */
        function populateSalesGroupFilter() {
            const currentSelectedValue = DOM.salesGroupFilter.value; // OPTIMIERT: DOM-Referenz nutzen
            DOM.salesGroupFilter.innerHTML = '<option value="">Alle Gruppen</option>'; // Standardoption // OPTIMIERT: DOM-Referenz nutzen

            const uniqueSalesGroups = new Set();
            markedDistricts.forEach(data => {
                data.salesEntries.forEach(entry => {
                    // Berücksichtige nur Vertriebsbezirke, die im salesDistrictFilter ausgewählt sind
                    // UND die den aktuellen Vertriebsbezirksfiltern entsprechen
                    const passesDistrictFilter = !isFilterActive || selectedSalesDistricts.has(entry.salesDistrict);

                    if (entry.salesGroup && passesDistrictFilter) {
                        uniqueSalesGroups.add(entry.salesGroup);
                    }
                });
            });

            const sortedGroups = Array.from(uniqueSalesGroups).sort();
            sortedGroups.forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                option.textContent = group;
                DOM.salesGroupFilter.appendChild(option); // OPTIMIERT: DOM-Referenz nutzen
            });

            // Setze den vorherigen Wert wieder, falls er noch gültig ist
            if (currentSelectedValue && uniqueSalesGroups.has(currentSelectedValue)) {
                DOM.salesGroupFilter.value = currentSelectedValue; // OPTIMIERT: DOM-Referenz nutzen
            } else {
                DOM.salesGroupFilter.value = ""; // Setze auf "Alle Gruppen", wenn der vorherige Wert nicht mehr existiert // OPTIMIERT: DOM-Referenz nutzen
            }
        }

        /* NEU: Funktion zum Befüllen der Vertriebsbezirks-Checkboxen */
        function populateSalesDistrictCheckboxes() {
            DOM.salesDistrictCheckboxes.innerHTML = ''; // Clear existing checkboxes // OPTIMIERT: DOM-Referenz nutzen
            allSalesDistricts.clear(); // Clear the set before re-populating

            markedDistricts.forEach(data => {
                data.salesEntries.forEach(entry => {
                    if (entry.salesDistrict) {
                        allSalesDistricts.add(entry.salesDistrict);
                    }
                });
            });

            const sortedDistricts = Array.from(allSalesDistricts).sort();
            const searchTerm = DOM.salesDistrictFilterSearch.value.toLowerCase().trim(); // OPTIMIERT: DOM-Referenz nutzen

            sortedDistricts.forEach(district => {
                if (searchTerm && !district.toLowerCase().includes(searchTerm)) {
                    return; // Skip if search term doesn't match
                }

                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'sales-district-checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `district-${district}`;
                checkbox.value = district;

                // Bestimme den checked-Status basierend auf isFilterActive und selectedSalesDistricts
                const isChecked = !isFilterActive || selectedSalesDistricts.has(district);
                checkbox.checked = isChecked;
                checkbox.setAttribute('aria-checked', isChecked);

                const label = document.createElement('label');
                label.htmlFor = `district-${district}`;
                label.textContent = district;

                checkbox.addEventListener('change', (event) => {
                    // Wenn der Filter vorher nicht aktiv war (alle waren implizit ausgewählt)
                    if (!isFilterActive) {
                        isFilterActive = true; // Jetzt ist der Filter aktiv
                        // Fülle selectedSalesDistricts mit allen aktuell angezeigten Bezirken
                        // (d.h. denen, die im Suchfilter passieren)
                        selectedSalesDistricts.clear();
                        sortedDistricts.forEach(d => {
                            if (d.toLowerCase().includes(searchTerm)) { // Nur die, die im Suchfeld sichtbar sind
                                selectedSalesDistricts.add(d);
                            }
                        });
                        // Entferne den gerade abgewählten Bezirk
                        selectedSalesDistricts.delete(district);
                    } else {
                        // Wenn der Filter bereits aktiv war, einfach hinzufügen/entfernen
                        if (event.target.checked) {
                            selectedSalesDistricts.add(district);
                        } else {
                            selectedSalesDistricts.delete(district);
                        }
                    }

                    // Überprüfe, ob alle sichtbaren Bezirke ausgewählt sind, um zum "alle anzeigen"-Modus zurückzukehren
                    const currentlyVisibleDistricts = sortedDistricts.filter(d => d.toLowerCase().includes(searchTerm));
                    if (selectedSalesDistricts.size === currentlyVisibleDistricts.length && isFilterActive) {
                        isFilterActive = false;
                        selectedSalesDistricts.clear(); // Set leeren für Effizienz
                    } else if (selectedSalesDistricts.size === 0 && isFilterActive && currentlyVisibleDistricts.length > 0) {
                        // Wenn alle sichtbar waren und jetzt alle abgewählt wurden, bleiben wir im isFilterActive = true Zustand
                        // Das bedeutet "nichts anzeigen"
                    }

                    updateAllDisplays(); // Filter neu anwenden und Infoboxen aktualisieren
                });

                checkboxContainer.appendChild(checkbox);
                checkboxContainer.appendChild(label);
                DOM.salesDistrictCheckboxes.appendChild(checkboxContainer); // OPTIMIERT: DOM-Referenz nutzen
            });

            // Blende den Filterbereich aus/ein, wenn keine Bezirke markiert sind
            if (allSalesDistricts.size === 0) {
                DOM.salesDistrictSelectionContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            } else {
                DOM.salesDistrictSelectionContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            }
        }

        /* NEUE HILFSFUNKTIONEN FÜR KI-ANALYSE */

        // Helper to get all sales entries from marked districts
        function getAllSalesEntries() {
            const allEntries = [];
            markedDistricts.forEach(data => {
                if (data.salesEntries) {
                    data.salesEntries.forEach(entry => {
                        allEntries.push({
                            regionName: data.regionName,
                            regionType: data.regionType,
                            objid: data.objid,
                            ...entry // id, color, salesGroup, salesDistrict, revenue
                        });
                    });
                }
            });
            return allEntries;
        }

        // Analyze Revenue (sum/average)
        function analyzeRevenue(type, filter) {
            const allSalesEntries = getAllSalesEntries();
            let revenuesToSum = [];

            if (filter) {
                if (filter.salesDistrict) {
                    const filteredByDistrict = allSalesEntries.filter(e => e.salesDistrict === filter.salesDistrict);
                    revenuesToSum = filteredByDistrict.map(e => e.revenue || 0);
                } else if (filter.salesGroup) {
                    // NEW LOGIC: Sum aggregated revenues of sales districts within this group
                    const aggregatedDistrictData = aggregateSalesDistrictData();
                    const districtsInGroup = Object.values(aggregatedDistrictData).filter(
                        district => district.salesGroup === filter.salesGroup
                    );
                    revenuesToSum = districtsInGroup.map(district => district.totalRevenue);
                } else {
                    revenuesToSum = allSalesEntries.map(e => e.revenue || 0);
                }
            } else {
                revenuesToSum = allSalesEntries.map(e => e.revenue || 0);
            }

            if (revenuesToSum.length === 0) {
                return "Es wurden keine Umsätze für die angegebenen Kriterien gefunden.";
            }

            const totalRevenue = revenuesToSum.reduce((sum, revenue) => sum + revenue, 0);

            let message = "";
            const filterDescription = filter ? (filter.salesDistrict ? `Vertriebsbezirk "${filter.salesDistrict}"` : `Vertriebsgruppe "${filter.salesGroup}"`) : "alle markierten Daten";

            if (type === "sum") {
                message = `Der Gesamtumsatz für ${filterDescription} beträgt: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(totalRevenue)}.`;
            } else if (type === "average") {
                const averageRevenue = totalRevenue / revenuesToSum.length;
                message = `Der Durchschnittsumsatz pro ${filter.salesGroup ? 'Vertriebsbezirk' : 'Eintrag'} für ${filterDescription} beträgt: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(averageRevenue)}.`;
            }
            return message;
        }

        // Get Top N Regions/Districts by Revenue
        function getTopList(listType, limit) {
            const allSalesEntries = getAllSalesEntries();
            if (allSalesEntries.length === 0) {
                return "Es sind keine Umsatzdaten vorhanden, um eine Top-Liste zu erstellen.";
            }

            const regionMaxRevenues = new Map(); // Map to store max revenue for each region
            allSalesEntries.forEach(entry => {
                const regionKey = `${entry.regionName}__${entry.regionType}`; // Unique key for the region
                const currentMax = regionMaxRevenues.get(regionKey) || 0;
                if ((entry.revenue || 0) > currentMax) {
                    regionMaxRevenues.set(regionKey, (entry.revenue || 0));
                }
            });

            // Convert map to array of objects for sorting
            const regionsWithRevenue = Array.from(regionMaxRevenues.entries()).map(([key, revenue]) => {
                const [name, type] = key.split('__');
                return { name, type, totalRevenue: revenue };
            });

            const sorted = regionsWithRevenue.sort((a, b) => b.totalRevenue - a.totalRevenue);
            const topItems = sorted.slice(0, limit);

            if (topItems.length === 0) {
                return `Keine ${listType} Daten gefunden.`;
            }

            let message = `Top ${topItems.length} Regionen nach Umsatz:\n`;
            topItems.forEach((item, index) => {
                message += `${index + 1}. ${item.name} (${item.type}): ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(item.totalRevenue)}\n`;
            });
            return message;
        }

        function analyzeDistrict(filter) {
            // allSalesEntries wird hier nicht mehr direkt für die Summation verwendet,
            // da wir auf die korrekt aggregierten Daten aus aggregateSalesDistrictData zugreifen.
            // const allSalesEntries = getAllSalesEntries();

            let filterTarget = "";
            let totalRevenue = 0;
            let uniqueRegionsInFilter = new Set();
            let totalEntriesCount = 0;

            const aggregatedDistrictData = aggregateSalesDistrictData(); // Aggregierte Daten einmal holen

            if (filter.salesDistrict) {
                filterTarget = `Vertriebsbezirk: ${filter.salesDistrict}`;
                const districtData = aggregatedDistrictData[filter.salesDistrict]; // Daten für den spezifischen Bezirk holen

                if (districtData) {
                    totalRevenue = districtData.totalRevenue; // Den bereits korrekt aggregierten Umsatz nutzen
                    districtData.regions.forEach(region => uniqueRegionsInFilter.add(region.name));
                    totalEntriesCount = districtData.entryCount; // Anzahl der Sales Entries für diesen Bezirk
                } else {
                    return `Keine Daten für ${filterTarget} gefunden.`;
                }

            } else if (filter.salesGroup) {
                filterTarget = `Vertriebsgruppe: ${filter.salesGroup}`;
                const districtsInGroup = Object.values(aggregatedDistrictData).filter(
                    district => district.salesGroup === filter.salesGroup
                );

                if (districtsInGroup.length === 0) {
                    return `Keine Daten für ${filterTarget} gefunden.`;
                }

                totalRevenue = districtsInGroup.reduce((sum, district) => sum + district.totalRevenue, 0);
                districtsInGroup.forEach(district => {
                    district.regions.forEach(region => uniqueRegionsInFilter.add(region.name));
                    totalEntriesCount += district.entryCount;
                });
            } else {
                return "Bitte geben Sie einen Vertriebsbezirk oder eine Vertriebsgruppe für die Analyse an.";
            }

            // ... Rest der Funktion bleibt gleich
            const averageRevenuePerEntry = totalEntriesCount > 0 ? totalRevenue / totalEntriesCount : 0;

            let message = `📊 Analyse ${filterTarget}\n`;
            message += `💰 Gesamtumsatz: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(totalRevenue)}\n`;
            message += `📈 Durchschnittsumsatz pro Eintrag: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(averageRevenuePerEntry)}\n`;
            message += `🏛️ Anzahl Regionen: ${uniqueRegionsInFilter.size}\n`;
            message += `📍 Regionen: ${Array.from(uniqueRegionsInFilter).join(', ')}`;
            return message;
        }

        // Compare sales districts
        function compareDistricts(districts) {
            if (!Array.isArray(districts) || districts.length !== 2) {
                return "Bitte geben Sie genau zwei Vertriebsbezirke zum Vergleichen an.";
            }

            const data1 = aggregateSalesDataForDistrict(districts[0]); // This calls the helper
            const data2 = aggregateSalesDataForDistrict(districts[1]); // This calls the helper

            let message = `Vergleich von ${districts[0]} und ${districts[1]}:\n\n`;

            message += `--- ${districts[0]} ---\n`;
            message += `Gesamtumsatz: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data1.totalRevenue)}\n`;
            message += `Anzahl Regionen: ${data1.regions.length}\n`; // Use data1.regions.length as it's now unique regions
            message += `Durchschnitt pro Eintrag: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data1.totalRevenue / data1.entryCount)}\n\n`; // Recalculate average based on new totalRevenue and entryCount

            message += `--- ${districts[1]} ---\n`;
            message += `Gesamtumsatz: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data2.totalRevenue)}\n`;
            message += `Anzahl Regionen: ${data2.regions.length}\n`; // Use data2.regions.length
            message += `Durchschnitt pro Eintrag: ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(data2.totalRevenue / data2.entryCount)}\n\n`; // Recalculate average

            if (data1.totalRevenue > data2.totalRevenue) {
                message += `${districts[0]} hat einen höheren Gesamtumsatz.`;
            } else if (data2.totalRevenue > data1.totalRevenue) {
                message += `${districts[1]} hat einen höheren Gesamtumsatz.`;
            } else {
                message += `Beide Bezirke haben den gleichen Gesamtumsatz.`;
            }
            return message;
        }

        // Helper for compareDistricts and other aggregations
        function aggregateSalesDataForDistrict(districtName) {
            const districtData = aggregateSalesDistrictData(); // Get all aggregated district data
            return districtData[districtName] || { // Return data for specific district or empty object if not found
                salesDistrict: districtName,
                salesGroup: '',
                regions: [],
                totalRevenue: 0,
                center: null,
                entryCount: 0,
                layerCount: 0
            };
        }

        // Get region with highest revenue (single entry)
        function getRegionWithHighestRevenue() {
            const entries = getAllSalesEntries();
            if (entries.length === 0) {
                return "Es sind keine Umsatzdaten vorhanden, um die Region mit dem höchsten Umsatz zu finden.";
            }

            let highestRevenueEntry = null;
            entries.forEach(entry => {
                if (!highestRevenueEntry || (entry.revenue || 0) > (highestRevenueEntry.revenue || 0)) {
                    highestRevenueEntry = entry;
                }
            });

            if (highestRevenueEntry) {
                return `Die Region mit dem höchsten Einzelumsatz ist ${highestRevenueEntry.regionName} (${highestRevenueEntry.regionType}) mit einem Umsatz von ${new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(highestRevenueEntry.revenue || 0)} im Vertriebsbezirk ${highestRevenueEntry.salesDistrict || 'N/A'}.`;
            }
            return "Keine Region mit Umsatzdaten gefunden.";
        }

        // Count regions in a sales group
        function countRegionsInSalesGroup(salesGroup) {
            const entries = getAllSalesEntries().filter(e => e.salesGroup === salesGroup);
            const uniqueRegions = new Set(entries.map(e => e.regionName));
            if (uniqueRegions.size === 0) {
                return `Es wurden keine Regionen in der Vertriebsgruppe "${salesGroup}" gefunden.`;
            }
            return `In der Vertriebsgruppe "${salesGroup}" gibt es ${uniqueRegions.size} Regionen: ${Array.from(uniqueRegions).join(', ')}.`;
        }

        /* NEU: Funktion zum Generieren des dynamischen System-Prompts */
        function generateDynamicSystemPrompt() {
            let dynamicPrompt = baseSystemPrompt;

            // --- START DES NEUEN ABSCHNITTS: Zusammenfassung der markierten Daten ---
            const allEntries = getAllSalesEntries(); // Nutzt Ihre bestehende Hilfsfunktion
            const uniqueDistricts = new Set();
            const uniqueGroups = new Set();
            const totalMarkedRegions = markedDistricts.size;

            allEntries.forEach(entry => {
                if (entry.salesDistrict) uniqueDistricts.add(entry.salesDistrict);
                if (entry.salesGroup) uniqueGroups.add(entry.salesGroup);
            });

            dynamicPrompt += "\n\nÜBERSICHT DER MARKIERUNGEN:\n";
            dynamicPrompt += `- Es sind aktuell ${totalMarkedRegions} Regionen markiert.\n`;
            dynamicPrompt += `- Diese umfassen ${uniqueDistricts.size} eindeutige Vertriebsbezirke und ${uniqueGroups.size} eindeutige Vertriebsgruppen.\n`;

            // Optional: Liste eine kleine Anzahl der häufigsten/ersten Vertriebsbezirke/Gruppen auf
            if (uniqueDistricts.size > 0) {
                const districtCounts = {};
                allEntries.forEach(entry => {
                    if (entry.salesDistrict) {
                        districtCounts[entry.salesDistrict] = (districtCounts[entry.salesDistrict] || 0) + 1;
                    }
                });
                const sortedDistricts = Object.keys(districtCounts).sort((a, b) => districtCounts[b] - districtCounts[a]);
                dynamicPrompt += `- Einige Vertriebsbezirke: ${sortedDistricts.slice(0, Math.min(sortedDistricts.length, 5)).join(', ')}${sortedDistricts.length > 5 ? '...' : ''}\n`;
            }

            if (uniqueGroups.size > 0) {
                const groupCounts = {};
                allEntries.forEach(entry => {
                    if (entry.salesGroup) {
                        groupCounts[entry.salesGroup] = (groupCounts[entry.salesGroup] || 0) + 1;
                    }
                });
                const sortedGroups = Object.keys(groupCounts).sort((a, b) => groupCounts[b] - groupCounts[a]);
                dynamicPrompt += `- Einige Vertriebsgruppen: ${sortedGroups.slice(0, Math.min(sortedGroups.length, 5)).join(', ')}${sortedGroups.length > 5 ? '...' : ''}\n`;
            }
            // --- ENDE DES NEUEN ABSCHNITTS ---

            dynamicPrompt += "\n\nNEUE VERFÜGBARE BEFEHLE (immer als JSON zurückgeben):\n";
            dynamicPrompt += `
1. Umsatzanalyse: {"action": "analyze_revenue", "type": "sum|average", "filter": {"salesDistrict": "Bezirk", "salesGroup": "Gruppe"}}
   - Berechnet die Summe oder den Durchschnitt des Umsatzes basierend auf dem Filter.
   - Beispiel: "Summe der Umsätze von H30L" -> {"action": "analyze_revenue", "type": "sum", "filter": {"salesDistrict": "H30L"}}
   - Beispiel: "Durchschnittsumsatz in Vertriebsgruppe ISL3" -> {"action": "analyze_revenue", "type": "average", "filter": {"salesGroup": "ISL3"}}
2. Top-Liste: {"action": "top_list", "type": "revenue", "limit": 5}
   - Zeigt die Top N Regionen/Bezirke nach Umsatz an.
   - Beispiel: "Top 5 Regionen nach Umsatz" -> {"action": "top_list", "type": "revenue", "limit": 5}
3. Vergleich von Vertriebsbezirken: {"action": "compare", "type": "districts", "items": ["Bezirk1", "Bezirk2"]}
   - Vergleicht die angegebenen Vertriebsbezirke.
   - Beispiel: "Vergleiche Vertriebsbezirke H30L und H10A" -> {"action": "compare", "type": "districts", "items": ["H30L", "H10A"]}
4. Detailanalyse eines Vertriebsbezirks oder einer Vertriebsgruppe: {"action": "analyze_district", "salesDistrict": "Bezirk"} ODER {"action": "analyze_district", "salesGroup": "Gruppe"}
   - Gibt detaillierte Informationen zu einem Vertriebsbezirk oder einer Vertriebsgruppe aus.
   - Beispiel: "Analyse Vertriebsbezirk H30L" -> {"action": "analyze_district", "salesDistrict": "H30L"}
   - Beispiel: "Analyse Vertriebsgruppe ISL3" -> {"action": "analyze_district", "salesGroup": "ISL3"}
`;
            // Add list of all available regions to the prompt
            dynamicPrompt += "\n\nLISTE ALLER VERFÜGBARER REGIONEN (Name (Typ)):\n";
            const allRegionNames = [];
            regionsTable.forEach(region => {
                allRegionNames.push(`${region.name} (${region.type})`);
            });
            dynamicPrompt += allRegionNames.slice(0, 200).join(', ') + (allRegionNames.length > 200 ? '...' : ''); // Limit to avoid prompt overflow

            return dynamicPrompt;
        }

        /* Karten-Initialisierung */
        async function initializeMultiMap() {
            try {
                leafletMap = L.map('map', {
                    attributionControl: false,
                    keyboard: true,
                    tap: true,
                    maxBoundsViscosity: 1.0,
                    zoomSnap: 0.5, // Feinere Zoom-Schritte
                    zoomControl: false // Disable default zoom control
                }).setView([51.16, 10.45], 6);

                // Add custom zoom control to topleft (position will be overridden by CSS)
                L.control.zoom({ position: 'topleft' }).addTo(leafletMap);

                const germanBounds = [
                    [47.0, 5.0],
                    [55.5, 16.0]
                ];
                leafletMap.setMaxBounds(germanBounds);

                L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                    maxZoom: 19,
                    minZoom: 5,
                    attribution: '&copy; OpenStreetMap & CARTO',
                    crossOrigin: true
                }).addTo(leafletMap);

                const loader = document.getElementById('loader');
                loader.setAttribute('role', 'status');
                loader.setAttribute('aria-live', 'assertive');

                const wfsUrl = 'https://sgx.geodatenzentrum.de/wfs_vg250';
                const params = new URLSearchParams({
                    SERVICE: 'WFS',
                    VERSION: '2.0.0',
                    REQUEST: 'GetFeature',
                    TYPENAMES: 'vg250:vg250_krs',
                    OUTPUTFORMAT: 'application/json',
                    SRSNAME: 'urn:ogc:def:crs:EPSG::4326'
                });

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);

                const response = await fetch(`${wfsUrl}?${params.toString()}`, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                loader.style.display = 'none';
                allFeaturesData = data.features;

                // Wichtig: Erst Tabelle initialisieren
                initializeRegionsTable(allFeaturesData);

                // Dann GeoJSON-Layer erstellen
                geojsonLayer = L.geoJSON(data, {
                    style: CONFIG.mapStyles.default,
                    onEachFeature: onEachFeature
                }).addTo(leafletMap);

                // Dann explizit die Layer mit objIDs verknüpfen
                // Dieser Block ist nicht mehr notwendig, da objIdToLayerMap bereits in onEachFeature gefüllt wird
                // for (const key in districtData) {
                //     if (key === 'nameIndex') continue;

                //     const entry = districtData[key];
                //     if (entry.objid && entry.layer) {
                //         objIdToLayerMap.set(entry.objid, entry.layer);
                //     }
                // }

                // NEU: Hover-Info-Popup initialisieren
                initializeHoverInfoPopup();

                // Farbpicker initialisieren
                initializeColorPicker();

                // NEU: Event-Handler für Karten-Bewegung hinzufügen
                leafletMap.on('moveend zoomend', updateInfoboxPositionsOnMapMove);

                const allDistrictNames = nameToKeysMap.size;
                currentSystemPrompt = baseSystemPrompt;

                setupMobileResponsive();

                // Initialisiere die Vertriebsbezirks-Checkboxen (leer, da noch nichts markiert)
                populateSalesDistrictCheckboxes();

                // NEU: Initial die Regionen einfärben, nachdem alles geladen ist
                applyRegionColoring();

                // OPTIMIERT: Screenreader-Announcement für erfolgreiche Kartenladung
                announceForScreenReader("Karte erfolgreich geladen. Sie können jetzt mit den Regionen interagieren.");

            } catch (error) {
                console.error(`Initialisierungsfehler: ${error.message}`);
                const loader = document.getElementById('loader');
                if (loader) {
                    loader.innerHTML = `<div class="loader-content">
                        <div style="color: #ef4444; font-weight: bold;">❌ Fehler beim Laden der Geodaten</div>
                        <div style="font-size: 0.8em;">${error.name === 'AbortError' ? 'Zeitüberschreitung bei der Anfrage.' : error.message}</div>
                        <button onclick="window.location.reload()" style="padding: 8px 16px; margin-top: 10px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">Neu laden</button>
                    </div>`;
                }
            }
        }

        /* Initialisierung der Regionstabelle */
        function initializeRegionsTable(features) {
            // Leere die vorhandenen Datenstrukturen
            regionsTable = [];
            objIdToLayerMap.clear();
            nameToRegionsMap.clear();
            normalizedNameMap.clear();

            try {
                features.forEach(feature => {
                    if (feature.properties && feature.properties.gen) {
                        const regionName = feature.properties.gen.trim();
                        const bezType = feature.properties.bez || "Unbekannt";
                        const objid = feature.properties.objid; // Hier ist es korrekt

                        // Erstelle Regionseintrag
                        const regionEntry = {
                            objid: objid,
                            name: regionName,
                            type: bezType, // Korrigiert: bezType verwenden
                            properties: feature.properties
                        };

                        // In Tabelle speichern
                        regionsTable.push(regionEntry);

                        // Nach Namen indizieren für schnelle Suche
                        if (!nameToRegionsMap.has(regionName)) {
                            nameToRegionsMap.set(regionName, []);
                        }
                        nameToRegionsMap.get(regionName).push(regionEntry);

                        // Normalisierter Namensindex für verbesserte Suche
                        const normalizedName = normalizeRegionName(regionName);
                        if (!normalizedNameMap.has(normalizedName)) {
                            normalizedNameMap.set(normalizedName, []);
                        }
                        normalizedNameMap.get(normalizedName).push(regionEntry);
                    }
                });
            } catch (error) {
                console.error(`Fehler bei der Initialisierung der Regionstabelle: ${error.message}`);
            }
        }

        /* Event Listeners Setup */
        // OPTIMIERT: Event-Listener direkt registrieren
        DOM.questionInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });

        document.addEventListener('keydown', (event) => {
            // Angepasst für Tablet-Querformat
            if (event.key === 'Escape' && window.innerWidth <= 1024) {
                if (DOM.sidebar.classList.contains('active')) { // OPTIMIERT: CSS-Klasse verwenden
                    DOM.sidebar.classList.remove('active'); // OPTIMIERT: CSS-Klasse verwenden
                    DOM.mobileSidebarToggle.innerHTML = '<span aria-hidden="true">≡</span>'; // Change to 'x' // OPTIMIERT: DOM-Referenz nutzen
                    DOM.mobileSidebarToggle.setAttribute('aria-label', 'Öffne Steuerung'); // OPTIMIERT: DOM-Referenz nutzen
                }
            }
        });

        // OPTIMIERT: Event-Listener für Prompt-Buttons (Event-Delegation)
        DOM.promptButtons.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const promptText = event.target.dataset.prompt;
                if (promptText) {
                    sendPrompt(promptText);
                }
            }
        });

        // OPTIMIERT: Event-Listener für Haupt-Aktionsbuttons
        DOM.sendButton.addEventListener('click', sendMessage);
        DOM.clearButton.addEventListener('click', clearAllMarkings);

        // OPTIMIERT: Event-Listener für Storage-Buttons
        DOM.saveDataButton.addEventListener('click', saveMarkings);
        DOM.loadDataButton.addEventListener('click', loadMarkings);

        // OPTIMIERT: Event-Listener für Edit-Dialog Buttons
        DOM.addEntryButton.addEventListener('click', showAddEntryForm);
        DOM.closeEditDialogButton.addEventListener('click', closeEditDialog);
        DOM.cancelAddEntryButton.addEventListener('click', cancelAddEntry);

        // WICHTIGE ÄNDERUNGEN HIER:
        // 1. Der Event-Listener für das Overlay ruft nun die generische Funktion auf.
        DOM.dialogOverlay.addEventListener('click', closeAnyOpenDialogs);
         // 2. Der "Schließen"-Button des Vertriebsbezirks-Detail-Popups ruft ebenfalls die generische Funktion auf.
        DOM.closeSalesDistrictDetailPopupButton.addEventListener('click', closeAnyOpenDialogs);

        // NEU: Event-listener für die Liste der Vertriebseinträge (Event-Delegation)
        // OPTIMIERT: Behebung des Fehlers beim Löschen/Bearbeiten von Einträgen
        DOM.salesEntriesList.addEventListener('click', (event) => {
            const target = event.target;
            const entryId = target.dataset.entryId;

            if (entryId) {
                if (target.classList.contains('btn-edit-entry')) {
                    editEntry(entryId);
                } else if (target.classList.contains('btn-delete-entry')) {
                    deleteEntry(entryId);
                }
            }
        });


        /* Event-Listener für Modellauswahl-Änderungen */
        DOM.modelSelector.addEventListener('change', (e) => { // OPTIMIERT: Event-Listener direkt registrieren
            const selectedModel = document.querySelector('input[name="model"]:checked').value;
            if (selectedModel === 'openai') {
                DOM.openaiKeyContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.geminiKeyContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            } else {
                DOM.openaiKeyContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.geminiKeyContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            }
        });

        // NEU: Event-listener für Vertriebsgruppen-Filter
        DOM.salesGroupFilter.addEventListener('change', function() { // OPTIMIERT: Event-Listener direkt registrieren
            applyRegionColoring(); // Wende die Farben basierend auf dem neuen Filter an
        });

        // NEU: Event-listener für Vertriebsbezirks-Filter-Suche
        DOM.salesDistrictFilterSearch.addEventListener('input', populateSalesDistrictCheckboxes); // OPTIMIERT: Event-Listener direkt registrieren

        // NEU: Event-listener für "Alle auswählen" Button
        DOM.selectAllDistrictsButton.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
            selectedSalesDistricts.clear(); // Explizite Auswahl löschen
            isFilterActive = false; // Zurück zum impliziten "alle anzeigen" Modus
            updateAllDisplays();
        });

        // NEU: Event-listener für "Alle abwählen" Button
        DOM.deselectAllDistrictsButton.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
            selectedSalesDistricts.clear(); // Explizite Auswahl löschen
            isFilterActive = true; // Filter aktivieren, aber nichts ist ausgewählt, also nichts anzeigen
            updateAllDisplays();
        });

        // NEW: Event listener for welcome message truncation
        if (DOM.welcomeMessageContainer && DOM.readMoreBtn) {
            DOM.readMoreBtn.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
                DOM.welcomeMessageContainer.classList.toggle('expanded');
                if (DOM.welcomeMessageContainer.classList.contains('expanded')) {
                    DOM.readMoreBtn.textContent = 'Weniger anzeigen';
                } else {
                    DOM.readMoreBtn.textContent = 'Weiter lesen';
                }
            });
        }

        // NEW: Event listener for contact info toggle and DSGVO truncation
        if (DOM.toggleContactBtn && DOM.contactInfoContainer && DOM.dsgvoContentContainer && DOM.readMoreDsgvoBtn) {
            // Split the DSGVO text
            const markerIndex = FULL_DSGVO_TEXT_RAW.indexOf(DSGVO_TRUNCATION_MARKER);
            if (markerIndex !== -1) {
                // MODIFIED: Adjust substring logic to hide the marker and everything after it initially
                truncatedDsgvoContent = FULL_DSGVO_TEXT_RAW.substring(0, markerIndex).trim();
                expandedDsgvoContent = FULL_DSGVO_TEXT_RAW.substring(markerIndex).trim();
            } else {
                truncatedDsgvoContent = FULL_DSGVO_TEXT_RAW;
                expandedDsgvoContent = ''; // No expansion possible if marker not found
            }

            // Convert newlines to <br> for HTML display
            truncatedDsgvoContent = truncatedDsgvoContent.trim().replace(/\n/g, '<br>');
            expandedDsgvoContent = expandedDsgvoContent.trim().replace(/\n/g, '<br>');

            // Initial setup for DSGVO content (hidden by default with contact container)
            DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent;
            if (expandedDsgvoContent) {
                DOM.readMoreDsgvoBtn.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                DOM.readMoreDsgvoBtn.textContent = 'Weiter lesen';
            } else {
                DOM.readMoreDsgvoBtn.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
            }

            // Event listener for DSGVO read more button
            DOM.readMoreDsgvoBtn.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
                DOM.dsgvoContentContainer.classList.toggle('expanded');
                if (DOM.dsgvoContentContainer.classList.contains('expanded')) {
                    DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent + expandedDsgvoContent;
                    DOM.readMoreDsgvoBtn.textContent = 'Weniger anzeigen';
                } else {
                    DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent;
                    DOM.readMoreDsgvoBtn.textContent = 'Weiter lesen';
                }
            });

            // Event listener for main contact toggle button
            DOM.toggleContactBtn.addEventListener('click', () => { // OPTIMIERT: Event-Listener direkt registrieren
                if (DOM.contactInfoContainer.classList.contains('hidden')) { // OPTIMIERT: CSS-Klasse verwenden
                    DOM.contactInfoContainer.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                    DOM.toggleContactBtn.textContent = 'DSGVO ausblenden'; // <-- ANPASSUNG: 'DSGVO'
                    // Ensure DSGVO content is initially truncated when container is shown
                    DOM.dsgvoContentContainer.classList.remove('expanded');
                    DOM.dsgvoContentContainer.innerHTML = truncatedDsgvoContent;
                    if (expandedDsgvoContent) {
                        DOM.readMoreDsgvoBtn.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                        DOM.readMoreDsgvoBtn.textContent = 'Weiter lesen';
                    }
                } else {
                    DOM.contactInfoContainer.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                    DOM.toggleContactBtn.textContent = 'DSGVO'; // <-- ANPASSUNG: 'DSGVO'
                }
            });
        }

        /* Hauptinitialisierung */
        window.addEventListener('load', async () => { // OPTIMIERT: Event-Listener direkt registrieren
            try {
                // Karte initialisieren
                await initializeMultiMap();

                // API-Key und Chat-Interface prüfen
                const selectedModel = sessionStorage.getItem('selected_model');
                if (selectedModel) {
                     const apiKey = sessionStorage.getItem(selectedModel === 'openai' ? 'openai_api_key' : 'gemini_api_key');
                     if(apiKey) {
                        DOM.apiKeySection.classList.add('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                        DOM.chatInterface.classList.remove('hidden'); // OPTIMIERT: CSS-Klasse verwenden
                        initializeChatInterface();
                     }
                }
            } catch (error) {
                console.error(`Fehler bei der Hauptinitialisierung: ${error.message}`);
                appendErrorMessage("Es ist ein Fehler bei der Initialisierung aufgetreten. Bitte laden Sie die Seite neu.");
            }
        });
        })(); // Ende des IIFE
    </script>
</body>
</html>